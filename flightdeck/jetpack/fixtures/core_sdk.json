[
    {
        "pk": 14, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "attachment", 
            "name": "attachment", 
            "app_label": "jetpack"
        }
    }, 
    {
        "pk": 6, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "contenttype", 
            "name": "content type", 
            "app_label": "contenttypes"
        }
    }, 
    {
        "pk": 3, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "group", 
            "name": "group", 
            "app_label": "auth"
        }
    }, 
    {
        "pk": 9, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "limit", 
            "name": "limit", 
            "app_label": "person"
        }
    }, 
    {
        "pk": 1, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "logentry", 
            "name": "log entry", 
            "app_label": "admin"
        }
    }, 
    {
        "pk": 5, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "message", 
            "name": "message", 
            "app_label": "auth"
        }
    }, 
    {
        "pk": 13, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "module", 
            "name": "module", 
            "app_label": "jetpack"
        }
    }, 
    {
        "pk": 11, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "package", 
            "name": "package", 
            "app_label": "jetpack"
        }
    }, 
    {
        "pk": 12, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "packagerevision", 
            "name": "package revision", 
            "app_label": "jetpack"
        }
    }, 
    {
        "pk": 2, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "permission", 
            "name": "permission", 
            "app_label": "auth"
        }
    }, 
    {
        "pk": 10, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "profile", 
            "name": "profile", 
            "app_label": "person"
        }
    }, 
    {
        "pk": 15, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "sdk", 
            "name": "sdk", 
            "app_label": "jetpack"
        }
    }, 
    {
        "pk": 7, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "session", 
            "name": "session", 
            "app_label": "sessions"
        }
    }, 
    {
        "pk": 8, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "site", 
            "name": "site", 
            "app_label": "sites"
        }
    }, 
    {
        "pk": 4, 
        "model": "contenttypes.contenttype", 
        "fields": {
            "model": "user", 
            "name": "user", 
            "app_label": "auth"
        }
    }, 
    {
        "pk": "25d8733f2a033e026eedba028693d3a5", 
        "model": "sessions.session", 
        "fields": {
            "expire_date": "2010-10-11 05:43:32", 
            "session_data": "gAJ9cQEuOTE5Yjc0MDhlZTU2YTQ5NGIyY2UxZWFmNDg0ZDlmYjM=\n"
        }
    }, 
    {
        "pk": 1, 
        "model": "sites.site", 
        "fields": {
            "domain": "example.com", 
            "name": "example.com"
        }
    }, 
    {
        "pk": 1, 
        "model": "person.profile", 
        "fields": {
            "nickname": null, 
            "location": null, 
            "user": 1, 
            "photo": null, 
            "homepage": null, 
            "occupation": null
        }
    }, 
    {
        "pk": 1, 
        "model": "jetpack.package", 
        "fields": {
            "public_key": null, 
            "private_key": null, 
            "name": "jetpack-core", 
            "license": "", 
            "author": 1, 
            "id_number": "1000000", 
            "lib_dir": null, 
            "jid": null, 
            "program_id": null, 
            "last_update": "2010-09-27 05:39:25", 
            "url": "", 
            "version": 1, 
            "full_name": "Jetpack Core", 
            "active": true, 
            "version_name": "0.6", 
            "latest": 1, 
            "type": "l", 
            "created_at": "2010-09-27 05:39:25", 
            "public_permission": 2, 
            "description": "The core Jetpack library."
        }
    }, 
    {
        "pk": 1, 
        "model": "jetpack.packagerevision", 
        "fields": {
            "origin": null, 
            "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
            "author": 1, 
            "created_at": "2010-09-27 05:39:25", 
            "package": 1, 
            "module_main": "main", 
            "revision_number": 0, 
            "dependencies": [], 
            "version_name": "0.6", 
            "message": "", 
            "sdk": null
        }
    }, 
    {
        "pk": 22, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *   Edward Lee <edilee@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// The possible return values of getTypeOf.\nconst VALID_TYPES = [\n  \"array\",\n  \"boolean\",\n  \"function\",\n  \"null\",\n  \"number\",\n  \"object\",\n  \"string\",\n  \"undefined\",\n];\n\n/**\n * Returns a function C that creates instances of privateCtor.  C may be called\n * with or without the new keyword.  The prototype of each instance returned\n * from C is C.prototype, and C.prototype is an object whose prototype is\n * privateCtor.prototype.  Instances returned from C will therefore be instances\n * of both C and privateCtor.  Additionally, the constructor of each instance\n * returned from C is C.\n *\n * @param  privateCtor\n *         A constructor.\n * @return A function that makes new instances of privateCtor.\n */\nexports.publicConstructor = function publicConstructor(privateCtor) {\n  function PublicCtor() {\n    let obj = { constructor: PublicCtor, __proto__: PublicCtor.prototype };\n    memory.track(obj, privateCtor.name);\n    privateCtor.apply(obj, arguments);\n    return obj;\n  }\n  PublicCtor.prototype = { __proto__: privateCtor.prototype };\n  return PublicCtor;\n};\n\n/**\n * Returns a validated options dictionary given some requirements.  If any of\n * the requirements are not met, an exception is thrown.\n *\n * @param  options\n *         An object, the options dictionary to validate.  It's not modified.\n *         If it's null or otherwise falsey, an empty object is assumed.\n * @param  requirements\n *         An object whose keys are the expected keys in options.  Any key in\n *         options that is not present in requirements is ignored.  Each value\n *         in requirements is itself an object describing the requirements of\n *         its key.  There are four optional keys in this object:\n *           map: A function that's passed the value of the key in options.\n *                map's return value is taken as the key's value in the final\n *                validated options, is, and ok.  If map throws an exception\n *                it's caught and discarded, and the key's value is its value in\n *                options.\n *           is:  An array containing any number of the typeof type names.  If\n *                the key's value is none of these types, it fails validation.\n *                Arrays and null are identified by the special type names\n *                \"array\" and \"null\"; \"object\" will not match either.  No type\n *                coercion is done.\n *           ok:  A function that's passed the key's value.  If it returns\n *                false, the value fails validation.\n *           msg: If the key's value fails validation, an exception is thrown.\n *                This string will be used as its message.  If undefined, a\n *                generic message is used, unless is is defined, in which case\n *                the message will state that the value needs to be one of the\n *                given types.\n * @return An object whose keys are those keys in requirements that are also in\n *         options and whose values are the corresponding return values of map\n *         or the corresponding values in options.  Note that any keys not\n *         shared by both requirements and options are not in the returned\n *         object.\n */\nexports.validateOptions = function validateOptions(options, requirements) {\n  options = options || {};\n  let validatedOptions = {};\n  let mapThrew = false;\n\n  for (let [key, req] in Iterator(requirements)) {\n    let [optsVal, keyInOpts] = (key in options) ?\n                               [options[key], true] :\n                               [undefined, false];\n    if (req.map) {\n      try {\n        optsVal = req.map(optsVal);\n      }\n      catch (err) {\n        mapThrew = true;\n      }\n    }\n    if (req.is) {\n      // Sanity check the caller's type names.\n      req.is.forEach(function (typ) {\n        if (VALID_TYPES.indexOf(typ) < 0) {\n          let msg = 'Internal error: invalid requirement type \"' + typ + '\".';\n          throw new Error(msg);\n        }\n      });\n      if (req.is.indexOf(getTypeOf(optsVal)) < 0)\n        throw requirementError(key, req);\n    }\n    if (req.ok && !req.ok(optsVal))\n      throw requirementError(key, req);\n\n    if (keyInOpts || (req.map && !mapThrew))\n      validatedOptions[key] = optsVal;\n  }\n\n  return validatedOptions;\n};\n\nexports.addIterator = function addIterator(obj, keysValsGen) {\n  // Define a getter so that we can determine if the Iterator wrapper is used.\n  obj.__defineGetter__(\"__iterator__\", function() {\n    // Detect that we're in a \"for (.. in Iterator(.., keysonly))\" context.\n    if (Error().stack.split(/\\n/)[2].indexOf(\"Iterator(\") == 0) {\n      return function(keysonly) {\n        let keysVals = keysValsGen.call(this);\n\n        // Get only keys if the optional second Iterator argument is true.\n        // Otherwise, get both keys and vals for the standard Iterator usage.\n        while (true)\n          yield keysonly ? keysVals.next()[0] : keysVals.next();\n      };\n    }\n\n    // Provide an iterator that handles the non-Iterator-wrapped contexts.\n    return function(keysonly) {\n      let keysVals = keysValsGen.call(this);\n\n      // \"for (.. in ..)\" gets only keys and \"for each (.. in ..)\" gets values.\n      let index = keysonly ? 0 : 1;\n      while (true)\n        yield keysVals.next()[index];\n    };\n  });\n};\n\n// Similar to typeof, except arrays and null are identified by \"array\" and\n// \"null\", not \"object\".\nfunction getTypeOf(val) {\n  let typ = typeof(val);\n  if (typ === \"object\") {\n    if (!val)\n      return \"null\";\n    // TODO: Replace this check with the ES5 Array.isArray() when Spidermonkey\n    // supports it.\n    if (Object.prototype.toString.call(val) === \"[object Array]\")\n      return \"array\";\n  }\n  return typ;\n}\n\n// Returns a new Error with a nice message.\nfunction requirementError(key, requirement) {\n  let msg = requirement.msg;\n  if (!msg) {\n    msg = 'The option \"' + key + '\" ';\n    msg += requirement.is ?\n           \"must be one of the following types: \" + requirement.is.join(\", \") :\n           \"is invalid.\";\n  }\n  return new Error(msg);\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "api-utils"
        }
    }, 
    {
        "pk": 31, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is String Bundle.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst apiUtils = require(\"api-utils\");\n\n/**\n * A bundle of strings.\n *\n * @param url {String}\n *        the URL of the string bundle\n */\nexports.StringBundle = apiUtils.publicConstructor(function StringBundle(url) {\n\n  let stringBundle = Cc[\"@mozilla.org/intl/stringbundle;1\"].\n                     getService(Ci.nsIStringBundleService).\n                     createBundle(url);\n\n  this.__defineGetter__(\"url\", function () url);\n\n  /**\n   * Get a string from the bundle.\n   *\n   * @param name {String}\n   *        the name of the string to get\n   * @param args {array} [optional]\n   *        an array of arguments that replace occurrences of %S in the string\n   *\n   * @returns {String} the value of the string\n   */\n  this.get = function strings_get(name, args) {\n    try {\n      if (args)\n        return stringBundle.formatStringFromName(name, args, args.length);\n      else\n        return stringBundle.GetStringFromName(name);\n    }\n    catch(ex) {\n      // f.e. \"Component returned failure code: 0x80004005 (NS_ERROR_FAILURE)\n      // [nsIStringBundle.GetStringFromName]\"\n      throw new Error(\"String '\" + name + \"' could not be retrieved from the \" +\n                      \"bundle due to an unknown error (it doesn't exist?).\");\n    }\n  },\n\n  /**\n   * Iterate the strings in the bundle.\n   *\n   */\n  apiUtils.addIterator(\n    this,\n    function keysValsGen() {\n      let enumerator = stringBundle.getSimpleEnumeration();\n      while (enumerator.hasMoreElements()) {\n        let elem = enumerator.getNext().QueryInterface(Ci.nsIPropertyElement);\n        yield [elem.key, elem.value];\n      }\n    }\n  );\n});\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "app-strings"
        }
    }, 
    {
        "pk": 18, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nexports.ByteReader = ByteReader;\nexports.ByteWriter = ByteWriter;\n\nconst {Cc, Ci} = require(\"chrome\");\n\n// This just controls the maximum number of bytes we read in at one time.\nconst BUFFER_BYTE_LEN = 0x8000;\n\nfunction ByteReader(inputStream) {\n  const self = this;\n\n  let stream = Cc[\"@mozilla.org/binaryinputstream;1\"].\n               createInstance(Ci.nsIBinaryInputStream);\n  stream.setInputStream(inputStream);\n\n  let manager = new StreamManager(this, stream);\n\n  this.read = function ByteReader_read(numBytes) {\n    manager.ensureOpened();\n    if (typeof(numBytes) !== \"number\")\n      numBytes = Infinity;\n\n    let data = \"\";\n    let read = 0;\n    try {\n      while (true) {\n        let avail = stream.available();\n        let toRead = Math.min(numBytes - read, avail, BUFFER_BYTE_LEN);\n        if (toRead <= 0)\n          break;\n        data += stream.readBytes(toRead);\n        read += toRead;\n      }\n    }\n    catch (err) {\n      throw new Error(\"Error reading from stream: \" + err);\n    }\n\n    return data;\n  };\n}\n\nfunction ByteWriter(outputStream) {\n  const self = this;\n\n  let stream = Cc[\"@mozilla.org/binaryoutputstream;1\"].\n               createInstance(Ci.nsIBinaryOutputStream);\n  stream.setOutputStream(outputStream);\n\n  let manager = new StreamManager(this, stream);\n\n  this.write = function ByteWriter_write(str) {\n    manager.ensureOpened();\n    try {\n      stream.writeBytes(str, str.length);\n    }\n    catch (err) {\n      throw new Error(\"Error writing to stream: \" + err);\n    }\n  };\n}\n\n\n// This manages the lifetime of stream, a ByteReader or ByteWriter.  It defines\n// closed and close() on stream and registers an unload listener that closes\n// rawStream if it's still opened.  It also provides ensureOpened(), which\n// throws an exception if the stream is closed.\nfunction StreamManager(stream, rawStream) {\n  const self = this;\n  this.rawStream = rawStream;\n  this.opened = true;\n\n  stream.__defineGetter__(\"closed\", function stream_closed() {\n    return !self.opened;\n  });\n\n  stream.close = function stream_close() {\n    self.ensureOpened();\n    self.unload();\n  };\n\n  require(\"unload\").ensure(this);\n}\n\nStreamManager.prototype = {\n  ensureOpened: function StreamManager_ensureOpened() {\n    if (!this.opened)\n      throw new Error(\"The stream is closed and cannot be used.\");\n  },\n  unload: function StreamManager_unload() {\n    this.rawStream.close();\n    this.opened = false;\n  }\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "byte-streams"
        }
    }, 
    {
        "pk": 10, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nexports.Collection = Collection;\n\n/**\n * Adds a collection property to the given object.  Setting the property to a\n * scalar value empties the collection and adds the value.  Setting it to an\n * array empties the collection and adds all the items in the array.\n *\n * @param obj\n *        The property will be defined on this object.\n * @param propName\n *        The name of the property.\n * @param array\n *        If given, this will be used as the collection's backing array.\n */\nexports.addCollectionProperty = function addCollProperty(obj, propName, array) {\n  array = array || [];\n  let publicIface = new Collection(array);\n\n  obj.__defineSetter__(propName, function (itemOrItems) {\n    array.splice(0, array.length);\n    publicIface.add(itemOrItems);\n  });\n\n  obj.__defineGetter__(propName, function () {\n    return publicIface;\n  });\n};\n\n/**\n * A collection is ordered, like an array, but its items are unique, like a set.\n *\n * @param array\n *        The collection is backed by an array.  If this is given, it will be\n *        used as the backing array.  This way the caller can fully control the\n *        collection.  Otherwise a new empty array will be used, and no one but\n *        the collection will have access to it.\n */\nfunction Collection(array) {\n  array = array || [];\n\n  /**\n   * Provides iteration over the collection.  Items are yielded in the order\n   * they were added.\n   */\n  this.__iterator__ = function Collection___iterator__() {\n    for (let i = 0; i < array.length; i++)\n      yield array[i];\n  };\n\n  /**\n   * The number of items in the collection.\n   */\n  this.__defineGetter__(\"length\", function Collection_get_length() {\n    return array.length;\n  });\n\n  /**\n   * Adds a single item or an array of items to the collection.  Any items\n   * already contained in the collection are ignored.\n   *\n   * @param  itemOrItems\n   *         An item or array of items.\n   * @return The collection.\n   */\n  this.add = function Collection_add(itemOrItems) {\n    let items = toArray(itemOrItems);\n    for (let i = 0; i < items.length; i++) {\n      let item = items[i];\n      if (array.indexOf(item) < 0)\n        array.push(item);\n    }\n    return this;\n  };\n\n  /**\n   * Removes a single item or an array of items from the collection.  Any items\n   * not contained in the collection are ignored.\n   *\n   * @param  itemOrItems\n   *         An item or array of items.\n   * @return The collection.\n   */\n  this.remove = function Collection_remove(itemOrItems) {\n    let items = toArray(itemOrItems);\n    for (let i = 0; i < items.length; i++) {\n      let idx = array.indexOf(items[i]);\n      if (idx >= 0)\n        array.splice(idx, 1);\n    }\n    return this;\n  };\n};\n\nfunction toArray(itemOrItems) {\n  let isArr = itemOrItems &&\n              itemOrItems.constructor &&\n              itemOrItems.constructor.name === \"Array\";\n  return isArr ? itemOrItems : [itemOrItems];\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "collection"
        }
    }, 
    {
        "pk": 14, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Ci} = require(\"chrome\");\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The context-menu module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nconst apiUtils = require(\"api-utils\");\nconst collection = require(\"collection\");\n\n// All user items we add have this class name.\nconst ITEM_CLASS = \"jetpack-context-menu-item\";\n\n// Items in the top-level context menu also have this class.\nconst TOPLEVEL_ITEM_CLASS = \"jetpack-context-menu-item-toplevel\";\n\n// Items in the overflow submenu also have this class.\nconst OVERFLOW_ITEM_CLASS = \"jetpack-context-menu-item-overflow\";\n\n// The ID of the menu separator that separates standard context menu items from\n// our user items.\nconst SEPARATOR_ID = \"jetpack-context-menu-separator\";\n\n// If more than this number of items are added to the context menu, all items\n// overflow into a \"Jetpack\" submenu.\nconst OVERFLOW_THRESH_DEFAULT = 10;\nconst OVERFLOW_THRESH_PREF =\n  \"jetpack.jetpack-core.context-menu.overflowThreshold\";\n\n// The label of the overflow sub-<menu>.\n//\n// TODO: Localize this.\nconst OVERFLOW_MENU_LABEL = \"Jetpack\";\n\n// The ID of the overflow sub-<menu>.\nconst OVERFLOW_MENU_ID = \"jetpack-content-menu-overflow-menu\";\n\n// The ID of the overflow submenu's <menupopup>.\nconst OVERFLOW_POPUP_ID = \"jetpack-content-menu-overflow-popup\";\n\n// These are used by BrowserWindow._isPageContextCurrent below.  If the\n// popupNode or any of its ancestors is one of these, Firefox uses a tailored\n// context menu, and so the page context doesn't apply.\nconst NON_PAGE_CONTEXT_ELTS = [\n  Ci.nsIDOMHTMLAnchorElement,\n  Ci.nsIDOMHTMLAppletElement,\n  Ci.nsIDOMHTMLAreaElement,\n  Ci.nsIDOMHTMLButtonElement,\n  Ci.nsIDOMHTMLCanvasElement,\n  Ci.nsIDOMHTMLEmbedElement,\n  Ci.nsIDOMHTMLImageElement,\n  Ci.nsIDOMHTMLInputElement,\n  Ci.nsIDOMHTMLIsIndexElement,\n  Ci.nsIDOMHTMLMapElement,\n  Ci.nsIDOMHTMLMediaElement,\n  Ci.nsIDOMHTMLMenuElement,\n  Ci.nsIDOMHTMLObjectElement,\n  Ci.nsIDOMHTMLOptionElement,\n  Ci.nsIDOMHTMLSelectElement,\n  Ci.nsIDOMHTMLTextAreaElement,\n];\n\n\nexports.Item = apiUtils.publicConstructor(Item);\nexports.Menu = apiUtils.publicConstructor(Menu);\nexports.Separator = apiUtils.publicConstructor(Separator);\n\n/**\n * Adds an item to the context menu.\n *\n * @param item\n *        The item to add, an Item or Menu.  Separators can only be added to\n *        submenus, not the top-level context menu.\n */\nexports.add = function contextMenu_add(item) {\n  if (item instanceof Separator) {\n    throw new Error(\"Separators cannot be added to the top-level \" +\n                    \"context menu.\");\n  }\n  browserManager.addItem(item);\n};\n\n/**\n * Removes an item from the context menu.\n *\n * @param item\n *        The item to remove.  It must have been previously added.\n */\nexports.remove = function contextMenu_remove(item) {\n  browserManager.removeItem(item);\n};\n\n// This is exported only to test it, on the suggestion of bug 548590 comment 30.\nexports._insertionPoint = insertionPoint;\n\n\n/**\n * Creates a simple menu item.\n *\n * @params options\n *         If any of the following options are invalid, an error is thrown:\n *         @prop label\n *               The item's label.  It must be either a string or an object that\n *               implements toString().\n *         @prop data\n *               An optional arbitrary value to associate with the item.  It\n *               must be either a string or an object that implements\n *               toString().\n *         @prop onClick\n *               An optional function that will be called when the item is\n *               clicked.  It is called as onClick(contextObj, item).\n *               contextObj is an object describing the context in which the\n *               context menu was invoked: { node, document, window }, where\n *               node is the node the user right-clicked to invoke the menu,\n *               document is the node's document, and window is the document's\n *               window.  item is the item itself.\n *         @prop context\n *               If the item is added to the top-level context menu, this\n *               specifies the context under which the item will appear.  It\n *               must be a string, function, undefined or null, or an array.  If\n *               undefined, the page context is assumed.  Ignored if the item is\n *               contained in a submenu.\n */\nfunction Item(options) {\n  options = apiUtils.validateOptions(options, {\n    context: {\n      is: [\"undefined\", \"null\", \"string\", \"function\", \"array\"]\n    },\n    data: {\n      map: function (v) v.toString(),\n      is: [\"string\", \"undefined\"]\n    },\n    label: {\n      map: function (v) v.toString(),\n      is: [\"string\"],\n      ok: function (v) !!v,\n      msg: \"The item must have a non-empty string label.\"\n    },\n    onClick: {\n      is: [\"function\", \"undefined\"]\n    }\n  });\n\n  // TODO: Add setters for these.  Updating label and data would require finding\n  // this item's DOM element and changing its attributes as well.\n  this.__defineGetter__(\"label\", function () options.label);\n  this.__defineGetter__(\"onClick\", function () options.onClick || undefined);\n  this.__defineGetter__(\"data\", function () {\n    return \"data\" in options ? options.data : undefined;\n  });\n\n  collection.addCollectionProperty(this, \"context\");\n  if (options.context)\n    this.context.add(options.context);\n\n  this.toString = function Item_toString() {\n    return '[object Item \"' + options.label + '\"]';\n  };\n}\n\n/**\n * Creates an item that expands into a submenu.\n *\n * @params options\n *         If any of the following options are invalid, an error is thrown:\n *         @prop label\n *               The menu's label.  It must be either a string or an object that\n *               implements toString().\n *         @prop items\n *               An array of items that the menu will contain.\n *         @prop onClick\n *               An optional function that will be called when any of the menu's\n *               Item descendants is clicked. (The onClicks of descendants are\n *               invoked first, in a bottom-up, bubbling manner.)  It is called\n *               as onClick(contextObj, item).  contextObj is an object\n *               describing the context in which the context menu was invoked:\n *               { node, document, window }, where node is the node the user\n *               right-clicked to invoke the menu, document is the node's\n *               document, and window is the document's window.  item is the\n *               the item that was clicked.\n *         @prop context\n *               If the item is added to the top-level context menu, this\n *               specifies the context under which the item will appear.  It\n *               must be a string, function, undefined or null, or an array.  If\n *               undefined, the page context is assumed.  Ignored if the item is\n *               contained in a submenu.\n */\nfunction Menu(options) {\n  options = apiUtils.validateOptions(options, {\n    context: {\n      is: [\"undefined\", \"null\", \"string\", \"function\", \"array\"]\n    },\n    items: {\n      is: [\"array\"]\n    },\n    label: {\n      map: function (v) v.toString(),\n      is: [\"string\"],\n      ok: function (v) !!v,\n      msg: \"The menu must have a non-empty string label.\"\n    },\n    onClick: {\n      is: [\"function\", \"undefined\"]\n    }\n  });\n\n  // TODO: Add setters for these.  Updating label and items would require\n  // finding this menus's DOM element updating it as well.\n  this.__defineGetter__(\"label\", function () options.label);\n  this.__defineGetter__(\"items\", function () options.items.slice(0));\n  this.__defineGetter__(\"onClick\", function () options.onClick || undefined);\n\n  collection.addCollectionProperty(this, \"context\");\n  if (options.context)\n    this.context.add(options.context);\n\n  this.toString = function Menu_toString() {\n    return '[object Menu \"' + options.label + '\"]';\n  };\n}\n\n/**\n * Creates a menu separator.\n */\nfunction Separator() {\n  this.toString = function Separator_toString() {\n    return \"[object Separator]\";\n  };\n}\n\n\n// Does a binary search on elts, a NodeList, and returns the DOM element\n// before which an item with targetLabel should be inserted.  null is returned\n// if the new item should be inserted at the end.\nfunction insertionPoint(targetLabel, elts) {\n  let from = 0;\n  let to = elts.length - 1;\n\n  while (from <= to) {\n    let i = Math.floor((from + to) / 2);\n    let comp = targetLabel.localeCompare(elts[i].getAttribute(\"label\"));\n    if (comp < 0)\n      to = i - 1;\n    else if (comp > 0)\n      from = i + 1;\n    else\n      return elts[i];\n  }\n  return elts[from] || null;\n}\n\n\n// Keeps track of all browser windows.\nlet browserManager = {\n  items: [],\n  windows: [],\n\n  // Registers an item with the manager.  It's added to the context menus of\n  // all currently registered windows, and when new windows are registered it\n  // will be added to them, too.\n  addItem: function browserManager_addItem(item) {\n    this.items.push(item);\n    this.windows.forEach(function (w) w.addItems([item]));\n  },\n\n  // Registers the manager to listen for window openings and closings.  Note\n  // that calling this method can cause onTrack to be called immediately if\n  // there are open windows.\n  init: function browserManager_init() {\n    let windowTracker = new (require(\"window-utils\").WindowTracker)(this);\n    require(\"unload\").ensure(windowTracker);\n  },\n\n  // Registers a window with the manager.  This is a WindowTracker callback.\n  onTrack: function browserManager_onTrack(window) {\n    if (this._isBrowserWindow(window)) {\n      let win = new BrowserWindow(window);\n      this.windows.push(win);\n      win.addItems(this.items);\n    }\n  },\n\n  // Unregisters a window from the manager.  It's told to undo all menu\n  // modifications.  This is a WindowTracker callback.  Note that when\n  // WindowTracker is unloaded, it calls onUntrack for every currently opened\n  // window.  The browserManager therefore doesn't need to specially handle\n  // unload itself, since unloading the browserManager means untracking all\n  // currently opened windows.\n  onUntrack: function browserManager_onUntrack(window) {\n    if (this._isBrowserWindow(window)) {\n      for (let i = 0; i < this.windows.length; i++) {\n        if (this.windows[i].window == window) {\n          let win = this.windows.splice(i, 1)[0];\n          win.destroy();\n          return;\n        }\n      }\n    }\n  },\n\n  // Unregisters an item from the manager.  It's removed from the context menus\n  // of all windows that are currently registered.\n  removeItem: function browserManager_removeItem(item) {\n    let idx = this.items.indexOf(item);\n    if (idx < 0) {\n      throw new Error(\"The item \" + item + \" has not been added to the menu \" +\n                      \"and therefore cannot be removed.\");\n    }\n    this.items.splice(idx, 1);\n    this.windows.forEach(function (w) w.removeItems([item]));\n  },\n\n  _isBrowserWindow: function browserManager__isBrowserWindow(win) {\n    let winType = win.document.documentElement.getAttribute(\"windowtype\");\n    return winType === \"navigator:browser\";\n  }\n};\n\n\n// Keeps track of a single browser window.  Responsible for providing a\n// description of the window's current context and determining whether an item\n// matches the current context.\n//\n// TODO: If other apps besides Firefox want to support the context menu in\n// whatever way is appropriate for them, plugging in a substitute for this class\n// should be the way to do it.  Make it easy for them.  See bug 560716.\nfunction BrowserWindow(window) {\n  this.window = window;\n  this.doc = window.document;\n\n  let popup = this.doc.getElementById(\"contentAreaContextMenu\");\n  if (!popup)\n    throw new Error(\"Internal error: Context menu popup not found.\");\n\n  this.contextMenuPopup = new ContextMenuPopup(popup, this);\n}\n\nBrowserWindow.prototype = {\n\n  // Adds an array of items to the window's context menu.\n  addItems: function BW_addItems(items) {\n    this.contextMenuPopup.addItems(items);\n  },\n\n  // Returns an object describing the current context.  This object may need to\n  // be slightly adjusted to match the context of a top-level item.  If not,\n  // topLevelItem need not be given.\n  contextObj: function BW_contextObj(topLevelItem) {\n    let node = this.doc.popupNode;\n\n    if (topLevelItem) {\n      for (let ctxt in topLevelItem.context) {\n        if (typeof(ctxt) === \"string\") {\n          let ctxtNode = this._popupNodeMatchingSelector(ctxt);\n          if (ctxtNode) {\n            node = ctxtNode;\n            break;\n          }\n        }\n      }\n    }\n\n    return {\n      node: node,\n      // Just to be safe, don't assume popupNode is non-null.\n      document: node ? node.ownerDocument : null,\n      window: node ? node.ownerDocument.defaultView : null\n    };\n  },\n\n  // Undoes all modifications to the window's context menu.  The BrowserWindow\n  // should not be used afterward.\n  destroy: function BW_destroy() {\n    this.contextMenuPopup.destroy();\n  },\n\n  // Returns true if any of item's contexts is current in the window.\n  isAnyContextCurrent: function BW_isAnyContextCurrent(item) {\n    if (!item.context.length)\n      return this._isPageContextCurrent();\n\n    for (let ctxt in item.context) {\n      let t = typeof(ctxt);\n      let curr = !ctxt ? this._isPageContextCurrent() :\n                 t === \"string\" ? this._isSelectorContextCurrent(ctxt) :\n                 t === \"function\" ? this._isFunctionContextCurrent(item, ctxt) :\n                 false;\n      if (curr)\n        return true;\n    }\n    return false;\n  },\n\n  // Removes an array of items from the window's context menu.\n  removeItems: function BW_removeItems(items) {\n    this.contextMenuPopup.removeItems(items);\n  },\n\n  // Returns true if func returns true given the window's current context.  item\n  // is needed because it is |this| inside of func.\n  _isFunctionContextCurrent: function BW__isFunctionContextCurrent(item, func) {\n    try {\n      return !!func.call(item, this.contextObj());\n    }\n    catch (err) {\n      console.exception(err);\n    }\n    return false;\n  },\n\n  // Returns true if the page context is current in the window.  The page\n  // context arises when the user invokes the context menu on a non-interactive\n  // part of the page.\n  _isPageContextCurrent: function BW__isPageContextCurrent() {\n    let popupNode = this.doc.popupNode;\n    let contentWin = popupNode ? popupNode.ownerDocument.defaultView : null;\n    if (contentWin && !contentWin.getSelection().isCollapsed)\n      return false;\n\n    let cursor = popupNode;\n    while (cursor && !(cursor instanceof Ci.nsIDOMHTMLHtmlElement)) {\n      if (NON_PAGE_CONTEXT_ELTS.some(function (iface) cursor instanceof iface))\n        return false;\n      cursor = cursor.parentNode;\n    }\n    return true;\n  },\n\n  // Returns true if the node the user clicked to invoke the context menu or\n  // any of the node's ancestors matches the given CSS selector.\n  _isSelectorContextCurrent: function BW__isSelectorContextCurrent(selector) {\n    return !!this._popupNodeMatchingSelector(selector);\n  },\n\n  // Returns popupNode if it matches selector, or the closest ancestor of\n  // popupNode that matches selector, or null if popupNode and none of its\n  // ancestors matches selector.\n  _popupNodeMatchingSelector: function BW__popupNodeMatchingSelector(selector) {\n    let cursor = this.doc.popupNode;\n    while (cursor && !(cursor instanceof Ci.nsIDOMHTMLHtmlElement)) {\n      if (cursor.mozMatchesSelector(selector))\n        return cursor;\n      cursor = cursor.parentNode;\n    }\n    return null;\n  }\n};\n\n\n// Represents a container of items that's the child of the given Menu and Popup.\n// popupElt is a <menupopup> that represents the popup in the DOM, and window is\n// the BrowserWindow containing the popup.  The popup is responsible for\n// creating and adding items to poupElt and handling command events.\nfunction Popup(parentMenu, parentPopup, popupElt, window) {\n  this.parentMenu = parentMenu;\n  this.parentPopup = parentPopup;\n  this.popupElt = popupElt;\n  this.window = window;\n  this.doc = popupElt.ownerDocument;\n\n  // Keeps track of the DOM elements owned by this popup: { item, elt }.\n  this.itemWrappers = [];\n\n  popupElt.addEventListener(\"command\", this, false);\n}\n\nPopup.prototype = {\n\n  // Adds an array of items to the popup.\n  addItems: function Popup_addItems(items) {\n    for (let i = 0; i < items.length; i++) {\n      let wrapper = { item: items[i], elt: this._makeItemElt(items[i]) };\n      this.itemWrappers.push(wrapper);\n      this.popupElt.appendChild(wrapper.elt);\n    }\n  },\n\n  // Undoes all modifications to the popup.  The popup should not be used\n  // afterward.\n  destroy: function Popup_destroy() {\n    this.popupElt.removeEventListener(\"command\", this, false);\n  },\n\n  // The popup is responsible for two command events: those originating at items\n  // in the popup and those bubbling to the popup's parent menu.  In the first\n  // case the popup calls the item's onClick method, and in the second the popup\n  // calls its parent menu's onClick -- in that order.\n  handleEvent: function Popup_handleEvent(event) {\n    try {\n      let elt = event.target;\n      if (elt.className.split(/\\s+/).indexOf(ITEM_CLASS) >= 0) {\n        // If the event originated at an item in the popup, call its onClick.\n        // Also set Popup.clickedItem and contextObj so ancestor popups know\n        // which item was clicked and under what context.\n        let childItemWrapper = this._findItemWrapper(elt);\n        if (childItemWrapper) {\n          let clickedItem = childItemWrapper.item;\n          let topLevelItem = this._topLevelItem(clickedItem);\n          let contextObj = this.window.contextObj(topLevelItem);\n          Popup.clickedItem = clickedItem;\n          Popup.contextObj = contextObj;\n\n          if (clickedItem.onClick) {\n            try {\n              clickedItem.onClick(contextObj, clickedItem);\n            }\n            catch (err) {\n              console.exception(err);\n            }\n          }\n        }\n\n        // Call the onClick of this popup's parent menu.\n        if (this.parentMenu && this.parentMenu.onClick) {\n          try {\n            this.parentMenu.onClick(Popup.contextObj, Popup.clickedItem);\n          }\n          catch (err) {\n            console.exception(err);\n          }\n        }\n      }\n    }\n    catch (err) {\n      console.exception(err);\n    }\n  },\n\n  // Returns true if the DOM element is owned by the wrapper.\n  _eltMatchesItemWrapper: function Popup__eltMatchesItemWrap(elt, itemWrapper) {\n    return elt == itemWrapper.elt;\n  },\n\n  // Given a DOM element, returns the item wrapper that owns it or null if none.\n  _findItemWrapper: function Popup__findItemWrapper(elt) {\n    for (let i = 0; i < this.itemWrappers.length; i++) {\n      let wrapper = this.itemWrappers[i];\n      if (this._eltMatchesItemWrapper(elt, wrapper))\n        return wrapper;\n    }\n    return null;\n  },\n\n  // Returns a DOM element representing the item.  All elements will have the\n  // ITEM_CLASS class, and className can optionally be used to add another.\n  _makeItemElt: function Popup__makeItemElt(item, className) {\n    let elt = item instanceof Item ? this._makeMenuitem(item, className) :\n              item instanceof Menu ? this._makeMenu(item, className) :\n              item instanceof Separator ? this._makeSeparator(className) :\n              null;\n    if (!elt)\n      throw new Error(\"Internal error: can't make element, unknown item type\");\n\n    return elt;\n  },\n\n  // Returns a new <menu> representing the menu.\n  _makeMenu: function Popup__makeMenu(menu, className) {\n    let menuElt = this.doc.createElement(\"menu\");\n    menuElt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    menuElt.setAttribute(\"label\", menu.label);\n    let popupElt = this.doc.createElement(\"menupopup\");\n    menuElt.appendChild(popupElt);\n\n    // Once items are added, this value can be thrown away.  The popup handles\n    // popupshowing on its own.\n    let popup = new Popup(menu, this, popupElt, this.window);\n    popup.addItems(menu.items);\n\n    return menuElt;\n  },\n\n  // Returns a new <menuitem> representing the item.\n  _makeMenuitem: function Popup__makeMenuitem(item, className) {\n    let elt = this.doc.createElement(\"menuitem\");\n    elt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    elt.setAttribute(\"label\", item.label);\n    if (item.data)\n      elt.setAttribute(\"value\", item.data);\n    return elt;\n  },\n\n  // Returns a new <menuseparator>.\n  _makeSeparator: function Popup__makeSeparator(className) {\n    let elt = this.doc.createElement(\"menuseparator\");\n    elt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    return elt;\n  },\n\n  // Returns the top-level menu that contains item or item if it is top-level.\n  _topLevelItem: function Popup__topLevelItem(item) {\n    let popup = this;\n    let topLevelItem = item;\n    while (popup.parentPopup) {\n      topLevelItem = popup.parentMenu;\n      popup = popup.parentPopup;\n    }\n    return topLevelItem;\n  }\n};\n\n\n// A subclass of Popup, this represents a window's context menu popup.  It's\n// responsible for hiding and showing items according to the window's current\n// context.\nfunction ContextMenuPopup(popupElt, window) {\n  const self = this;\n  Popup.call(this, null, null, popupElt, window);\n\n  // Adds an array of items to the popup.\n  this.addItems = function CMP_addItems(items) {\n    // Don't do anything if there are no items.\n    if (items.length) {\n      ensureStaticEltsExist();\n      ensureListeningForPopups();\n\n      // Add each item to the top-level menu and the overflow submenu.\n      let submenuPopup = overflowPopup();\n      for (let i = 0; i < items.length; i++) {\n        let item = items[i];\n        let wrapper = {\n          item: item,\n          elt: this._makeItemElt(item, TOPLEVEL_ITEM_CLASS),\n          overflowElt: this._makeItemElt(item, OVERFLOW_ITEM_CLASS)\n        };\n        this.itemWrappers.push(wrapper);\n\n        let targetElt = insertionPoint(item.label, topLevelElts());\n        this.popupElt.insertBefore(wrapper.elt, targetElt);\n\n        targetElt = insertionPoint(item.label, overflowElts());\n        submenuPopup.insertBefore(wrapper.overflowElt, targetElt);\n      }\n    }\n  };\n\n  // Undoes all modifications to the popup.  The popup should not be used\n  // afterward.\n  this.destroy = function CMP_destroy() {\n    // Remove all the items registered with this instance of the module from the\n    // top-level menu and overflow submenu.\n    let submenuPopup = overflowPopup();\n    for (let i = 0; i < this.itemWrappers.length; i++) {\n      this.popupElt.removeChild(this.itemWrappers[i].elt);\n      if (submenuPopup)\n        submenuPopup.removeChild(this.itemWrappers[i].overflowElt);\n    }\n\n    // If there are no more items from any instance of the module, remove the\n    // separator and overflow submenu, if they exist.\n    let elts = topLevelElts();\n    if (!elts.length) {\n      let submenu = overflowMenu();\n      if (submenu)\n        this.popupElt.removeChild(submenu);\n\n      let sep = separator();\n      if (sep)\n        this.popupElt.removeChild(sep);\n    }\n\n    // Remove event listeners.\n    if (this._listeningForPopups) {\n      this.popupElt.removeEventListener(\"popupshowing\", this, false);\n      delete this._listeningForPopups;\n    }\n    this.__proto__.destroy.call(this);\n  };\n\n  // The context menu popup needs to handle popupshowing in addition to command\n  // events.  popupshowing is used to show top-level items that match the\n  // window's current context and hide items that don't.  Each module instance\n  // is responsible for showing and hiding the items it owns.\n  this.handleEvent = function CMP_handleEvent(event) {\n    if (event.type === \"command\") {\n      this.__proto__.handleEvent.call(this, event);\n    }\n    else if (event.type === \"popupshowing\") {\n      try {\n        // Show and hide items.  Set a \"jetpackContextCurrent\" property on the\n        // DOM elements to signal which of our items match the current context.\n        this.itemWrappers.forEach(function (wrapper) {\n          let contextCurr = window.isAnyContextCurrent(wrapper.item);\n          wrapper.elt.jetpackContextCurrent = contextCurr;\n          wrapper.overflowElt.jetpackContextCurrent = contextCurr;\n          wrapper.elt.hidden = !contextCurr;\n          wrapper.overflowElt.hidden = !contextCurr;\n        });\n\n        // Get the total number of items that match the current context.  It's a\n        // little tricky:  There may be other instances of this module loaded,\n        // each hiding and showing their items.  So we can't base this number on\n        // only our items, or on the hidden state of items.  That's why we set\n        // the jetpackContextCurrent property above.  The last instance to run\n        // will leave the menupopup in the correct state.\n        let elts = topLevelElts();\n        let numShown = Array.reduce(elts, function (total, elt) {\n          return total + (elt.jetpackContextCurrent ? 1 : 0);\n        }, 0);\n\n        // If too many items are shown, show the submenu and hide the top-level\n        // items.  Otherwise, hide the submenu and show the top-level items.\n        let overflow = numShown > overflowThreshold();\n        if (overflow)\n          Array.forEach(elts, function (e) e.hidden = true);\n\n        let submenu = overflowMenu();\n        if (submenu)\n          submenu.hidden = !overflow;\n\n        // If no items are shown, hide the menu separator.\n        let sep = separator();\n        if (sep)\n          sep.hidden = numShown === 0;\n      }\n      catch (err) {\n        console.exception(err);\n      }\n    }\n  };\n\n  // Removes an array of items from the popup.\n  this.removeItems = function CMP_removeItems(items) {\n    let overPopup = overflowPopup();\n    for (let i = 0; i < items.length; i++) {\n      let idx = indexOfItemWrapper(items[i]);\n      if (idx < 0) {\n        // Don't throw here; continue the loop.\n        let err = new Error(\"Internal error: item for removal not found.\");\n        console.exception(err);\n      }\n\n      let wrapper = this.itemWrappers[idx];\n      this.popupElt.removeChild(wrapper.elt);\n      overPopup.removeChild(wrapper.overflowElt);\n      this.itemWrappers.splice(idx, 1);\n    }\n  };\n\n  // Returns true if the DOM element is owned by the wrapper.\n  this._eltMatchesItemWrapper = function CMP__eltMatchesWrap(elt, itemWrapper) {\n    return elt == itemWrapper.elt || elt == itemWrapper.overflowElt;\n  };\n\n  // Adds the popupshowing listener if it hasn't been added already.\n  function ensureListeningForPopups() {\n    if (!self._listeningForPopups) {\n      self.popupElt.addEventListener(\"popupshowing\", self, false);\n      self._listeningForPopups = true;\n    }\n  }\n\n  // Adds the menu separator and overflow submenu if they don't exist.\n  function ensureStaticEltsExist() {\n    let sep = separator();\n    if (!sep) {\n      sep = makeSeparator();\n      self.popupElt.appendChild(sep);\n    }\n\n    let submenu = overflowMenu();\n    if (!submenu) {\n      submenu = makeOverflowMenu();\n      self.popupElt.insertBefore(submenu, sep.nextSibling);\n    }\n  }\n\n  // Returns the index of the item wrapper containing item, -1 if none.\n  function indexOfItemWrapper(item) {\n    for (let i = 0; i < self.itemWrappers.length; i++) {\n      if (self.itemWrappers[i].item === item)\n        return i;\n    }\n    return -1;\n  }\n\n  // Creates and returns the <menu> that's shown when too many items are added\n  // to the popup.\n  function makeOverflowMenu() {\n    let submenu = self.doc.createElement(\"menu\");\n    submenu.id = OVERFLOW_MENU_ID;\n    submenu.setAttribute(\"label\", OVERFLOW_MENU_LABEL);\n    let popup = self.doc.createElement(\"menupopup\");\n    popup.id = OVERFLOW_POPUP_ID;\n    submenu.appendChild(popup);\n    return submenu;\n  }\n\n  // Creates and returns the <menuseparator> that separates the standard context\n  // menu items from our items.\n  function makeSeparator() {\n    let elt = self.doc.createElement(\"menuseparator\");\n    elt.id = SEPARATOR_ID;\n    return elt;\n  }\n\n  // Returns the item elements contained in the overflow menu, a NodeList.\n  function overflowElts() {\n    return overflowPopup().getElementsByClassName(OVERFLOW_ITEM_CLASS);\n  }\n\n  // Returns the overflow <menu>.\n  function overflowMenu() {\n    return self.doc.getElementById(OVERFLOW_MENU_ID);\n  }\n\n  // Returns the overflow <menupopup>.\n  function overflowPopup() {\n    return self.doc.getElementById(OVERFLOW_POPUP_ID);\n  }\n\n  // Returns the OVERFLOW_THRESH_PREF pref value if it exists or\n  // OVERFLOW_THRESH_DEFAULT if it doesn't.\n  function overflowThreshold() {\n    let prefs = require(\"preferences-service\");\n    return prefs.get(OVERFLOW_THRESH_PREF, OVERFLOW_THRESH_DEFAULT);\n  }\n\n  // Returns the <menuseparator>.\n  function separator() {\n    return self.doc.getElementById(SEPARATOR_ID);\n  }\n\n  // Returns the item elements contained in the top-level menu, a NodeList.\n  function topLevelElts() {\n    return self.popupElt.getElementsByClassName(TOPLEVEL_ITEM_CLASS);\n  }\n};\n\nContextMenuPopup.prototype = Popup.prototype;\n\n\n// Init the browserManager only after setting prototypes and such above, because\n// it will cause browserManager.onTrack to be called immediately if there are\n// open windows.\nbrowserManager.init();\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "context-menu"
        }
    }, 
    {
        "pk": 7, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n(function(global) {\n   const Cc = Components.classes;\n   const Ci = Components.interfaces;\n   const Cu = Components.utils;\n   const Cr = Components.results;\n\n   var exports = {};\n\n   // Load the SecurableModule prerequisite.\n   var securableModule;\n\n   if (global.require)\n     // We're being loaded in a SecurableModule.\n     securableModule = require(\"securable-module\");\n   else {\n     var myURI = Components.stack.filename.split(\" -> \").slice(-1)[0];\n     var ios = Cc['@mozilla.org/network/io-service;1']\n               .getService(Ci.nsIIOService);\n     var securableModuleURI = ios.newURI(\"securable-module.js\", null,\n                                         ios.newURI(myURI, null, null));\n     if (securableModuleURI.scheme == \"chrome\") {\n       // The securable-module module is at a chrome URI, so we can't\n       // simply load it via Cu.import(). Let's assume we're in a\n       // chrome-privileged document and use mozIJSSubScriptLoader.\n       var loader = Cc[\"@mozilla.org/moz/jssubscript-loader;1\"]\n                    .getService(Ci.mozIJSSubScriptLoader);\n\n       // Import the script, don't pollute the global scope.\n       securableModule = {__proto__: global};\n       loader.loadSubScript(securableModuleURI.spec, securableModule);\n       securableModule = securableModule.SecurableModule;\n     } else {\n       securableModule = {};\n       try {\n         Cu.import(securableModuleURI.spec, securableModule);\n       } catch (e if e.result == Cr.NS_ERROR_ILLEGAL_VALUE) {\n         Cu.reportError(\"Failed to load \" + securableModuleURI.spec);\n       }\n     }\n   }\n\n   function unloadLoader(reason) {\n     this.require(\"unload\").send(reason);\n   }\n\n   var cuddlefishSandboxFactory = {\n     createSandbox: function(options) {\n       var filename = options.filename ? options.filename : null;\n       var sandbox = this.__proto__.createSandbox(options);\n       sandbox.defineProperty(\"__url__\", filename);\n       return sandbox;\n     },\n     __proto__: new securableModule.SandboxFactory(\"system\")\n   };\n\n   function CuddlefishModule(loader) {\n     this.parentLoader = loader;\n     this.__proto__ = exports;\n   }\n\n   var Loader = exports.Loader = function Loader(options) {\n     var globals = {};\n\n     if (options.globals)\n       for (var name in options.globals)\n         globals[name] = options.globals[name];\n\n     if (options.console)\n       globals.console = options.console;\n     if (options.memory)\n       globals.memory = options.memory;\n\n     var modules = options.modules || {};\n\n     var loaderOptions = {rootPath: options.rootPath,\n                          rootPaths: options.rootPaths,\n                          fs: options.fs,\n                          sandboxFactory: cuddlefishSandboxFactory,\n                          globals: globals,\n                          modules: modules};\n\n     var loader = new securableModule.Loader(loaderOptions);\n     var path = loader.fs.resolveModule(null, \"cuddlefish\");\n     modules[path] = new CuddlefishModule(loader);\n\n     if (!globals.console) {\n       var console = loader.require(\"plain-text-console\");\n       globals.console = new console.PlainTextConsole(options.print);\n     }\n     if (!globals.memory)\n       globals.memory = loader.require(\"memory\");\n\n     loader.console = globals.console;\n     loader.memory = globals.memory;\n     loader.unload = unloadLoader;\n\n     return loader;\n   };\n\n   if (global.window) {\n     // We're being loaded in a chrome window, or a web page with\n     // UniversalXPConnect privileges.\n     global.Cuddlefish = exports;\n   } else if (global.exports) {\n     // We're being loaded in a SecurableModule.\n     for (name in exports) {\n       global.exports[name] = exports[name];\n     }\n   } else {\n     // We're being loaded in a JS module.\n     global.EXPORTED_SYMBOLS = [];\n     for (name in exports) {\n       global.EXPORTED_SYMBOLS.push(name);\n       global[name] = exports[name];\n     }\n   }\n })(this);\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "cuddlefish"
        }
    }, 
    {
        "pk": 32, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nfunction logToConsole(e) {\n  console.exception(e);\n}\n\nvar catchAndLog = exports.catchAndLog = function(callback,\n                                                 defaultResponse,\n                                                 logException) {\n  if (!logException)\n    logException = logToConsole;\n\n  return function() {\n    try {\n      return callback.apply(this, arguments);\n    } catch (e) {\n      logException(e);\n      return defaultResponse;\n    }\n  };\n};\n\nexports.catchAndLogProps = function catchAndLogProps(object,\n                                                     props,\n                                                     defaultResponse,\n                                                     logException) {\n  if (typeof(props) == \"string\")\n    props = [props];\n  props.forEach(\n    function(property) {\n      object[property] = catchAndLog(object[property],\n                                     defaultResponse,\n                                     logException);\n    });\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "errors"
        }
    }, 
    {
        "pk": 26, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is nsINarwhal.\n *\n * The Initial Developer of the Original Code is\n * Irakli Gozalishvili <rfobic@gmail.com>.\n * Portions created by the Initial Developer are Copyright (C) 2009\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <rfobic@gmail.com>\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\nconst byteStreams = require(\"byte-streams\");\nconst textStreams = require(\"text-streams\");\nconst xpcom = require(\"xpcom\");\n\n// Flags passed when opening a file.  See nsprpub/pr/include/prio.h.\nconst OPEN_FLAGS = {\n  RDONLY: 0x01,\n  WRONLY: 0x02,\n  CREATE_FILE: 0x08,\n  APPEND: 0x10,\n  TRUNCATE: 0x20,\n  EXCL: 0x80\n};\n\nvar dirsvc = Cc[\"@mozilla.org/file/directory_service;1\"]\n             .getService(Ci.nsIProperties);\n\nfunction MozFile(path) {\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  return file;\n}\n\nfunction ensureReadable(file) {\n  if (!file.isReadable())\n    throw new Error(\"path is not readable: \" + file.path);\n}\n\nfunction ensureDir(file) {\n  ensureExists(file);\n  if (!file.isDirectory())\n    throw new Error(\"path is not a directory: \" + file.path);\n}\n\nfunction ensureFile(file) {\n  ensureExists(file);\n  if (!file.isFile())\n    throw new Error(\"path is not a file: \" + file.path);\n}\n\nfunction ensureExists(file) {\n  if (!file.exists()) {\n    throw xpcom.friendlyError(Cr.NS_ERROR_FILE_NOT_FOUND, {\n      filename: file.path\n    });\n  }\n}\n\nexports.exists = function exists(filename) {\n  return MozFile(filename).exists();\n};\n\nexports.read = function read(filename) {\n  var stream = exports.open(filename);\n  try {\n    var str = stream.read();\n  }\n  finally {\n    stream.close();\n  }\n\n  return str;\n};\n\nexports.join = function join(base) {\n  if (arguments.length < 2)\n    throw new Error(\"need at least 2 args\");\n  base = MozFile(base);\n  for (var i = 1; i < arguments.length; i++)\n    base.append(arguments[i]);\n  return base.path;\n};\n\nexports.dirname = function dirname(path) {\n  return MozFile(path).parent.path;\n};\n\nexports.list = function list(path) {\n  var file = MozFile(path);\n  ensureDir(file);\n  ensureReadable(file);\n\n  var entries = file.directoryEntries;\n  var entryNames = [];\n  while(entries.hasMoreElements()) {\n    var entry = entries.getNext();\n    entry.QueryInterface(Ci.nsIFile);\n    entryNames.push(entry.leafName);\n  }\n  return entryNames;\n};\n\nexports.open = function open(filename, mode) {\n  var file = MozFile(filename);\n  if (typeof(mode) !== \"string\")\n    mode = \"\";\n\n  // File opened for write only.\n  if (/w/.test(mode)) {\n    if (file.exists())\n      ensureFile(file);\n    var stream = Cc['@mozilla.org/network/file-output-stream;1'].\n                 createInstance(Ci.nsIFileOutputStream);\n    var openFlags = OPEN_FLAGS.WRONLY |\n                    OPEN_FLAGS.CREATE_FILE |\n                    OPEN_FLAGS.TRUNCATE;\n    var permFlags = 0644; // u+rw go+r\n    try {\n      stream.init(file, openFlags, permFlags, 0);\n    }\n    catch (err) {\n      throw xpcom.friendlyError(err, { filename: filename });\n    }\n    return /b/.test(mode) ?\n           new byteStreams.ByteWriter(stream) :\n           new textStreams.TextWriter(stream);\n  }\n\n  // File opened for read only, the default.\n  ensureFile(file);\n  stream = Cc['@mozilla.org/network/file-input-stream;1'].\n           createInstance(Ci.nsIFileInputStream);\n  try {\n    stream.init(file, OPEN_FLAGS.RDONLY, 0, 0);\n  }\n  catch (err) {\n    throw xpcom.friendlyError(err, { filename: filename });\n  }\n  return /b/.test(mode) ?\n         new byteStreams.ByteReader(stream) :\n         new textStreams.TextReader(stream);\n};\n\nexports.remove = function remove(path) {\n  var file = MozFile(path);\n  ensureFile(file);\n  file.remove(false);\n};\n\nexports.mkpath = function mkpath(path) {\n  var file = MozFile(path);\n  if (!file.exists())\n    file.create(Ci.nsIFile.DIRECTORY_TYPE, 0755); // u+rwx go+rx\n  else if (!file.isDirectory())\n    throw new Error(\"The path already exists and is not a directory: \" + path);\n};\n\nexports.rmdir = function rmdir(path) {\n  var file = MozFile(path);\n  ensureDir(file);\n  try {\n    file.remove(false);\n  }\n  catch (err) {\n    // Bug 566950 explains why we're not catching a specific exception here.\n    throw new Error(\"The directory is not empty: \" + path);\n  }\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "file"
        }
    }, 
    {
        "pk": 15, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Zbigniew Braniecki <gandalf@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nlet xhr = require('xhr');\nlet timer = require(\"timer\");\nlet prefs = require(\"preferences-service\");\nlet file = require(\"file\");\nlet {Cc, Ci} = require(\"chrome\");\n\n/**\n * An interface jetpack localization capabilities\n *\n * The primary method exposed by this interface is |get| which\n * should be provided with each string used in the jetpack\n * and returns the string itself or its localization if available.\n *\n * @version 0.1\n */\n\n// common pool service object\nlet locale = prefs.get(\"general.useragent.locale\", \"en-US\");\nlet programID = require('self').id;\n// check if update is over one day old\nconst STORAGE_UPDATE_INTERVAL = 86400;\n// update memory twice per day\nconst MEMORY_UPDATE_INTERVAL = 43200;\n\n/**\n * Returns translation of a string if one is available,\n * otherwise returns the string itself\n *\n * @param   k\n *          The string to be localized\n *\n * @returns localized or source string\n */\nexports.get = function (k) {\n  let pool = cps.pool;\n  // testing if we have this entity\n  // for this locale in the pool\n  if (pool !== null && k in cps.pool && locale in cps.pool[k]) {\n    let entity = cps.pool[k][locale];\n    // testing if we have a per-app exception\n    // for this entity/locale pair\n    if (\"apps\" in entity &&\n        programID in entity[\"apps\"])\n      return entity[\"apps\"][programID][\"translation\"];\n    return entity[\"translation\"];\n  }\n  return k;\n}\n\nlet cps = {\n  pool: null,\n  last_update: null,\n  I: null,\n  url: \"http://l10n.mozillalabs.com/\",\n  /**\n   * Executes triggered request for updating\n   * memory object from local storage\n   */\n  updateMemory: function() {\n    let path = getStoragePath();\n    // update storage if the file\n    // does not exist or is older than we want\n    if (!file.exists(path) ||\n        (getUnixTimeStamp()-\n         getLastModificationTime(path)/1000>=STORAGE_UPDATE_INTERVAL)) {\n      console.debug('Updating storage!');\n      cps.updateStorage();\n      return;\n    }\n    console.debug('Not updating storage!');\n    let str = file.read(path);\n    cps.pool = JSON.parse(str);\n    cps.last_update = getUnixTimeStamp();\n  },\n  /**\n   * Executes triggered request for updating\n   * local storage from remote server\n   */\n  updateStorage: function() {\n    if (cps.url === undefined) {\n      console.debug('Cannot update the storage due to lack of server!');\n      return;\n    }\n    let req = new xhr.XMLHttpRequest();\n    req.overrideMimeType(\"text/plain\");\n    req.open(\"GET\", cps.url+'?locale='+locale+'&jid='+programID, true);\n    req.onreadystatechange = function() {\n      if (req.readyState == 4) {\n        try {\n          var obj = JSON.parse(req.responseText);\n        } catch (e) {\n          console.debug('Bad JSON!');\n          return;\n        }\n        cps.pool = obj;\n        cps.last_update = getUnixTimeStamp();\n        let path = getStoragePath();\n        let l10n_cp = file.open(path, 'w');\n        l10n_cp.write(req.responseText);\n        l10n_cp.close();\n      }\n    }\n    req.send(null);\n  }\n};\n\nif (cps.pool === null && cps.url !== null)\n  cps.updateMemory();\n\ncps.I = timer.setInterval(cps.updateMemory,\n              MEMORY_UPDATE_INTERVAL*1000);\n\n/**\n * Creates and returns a path to common pool json file\n *\n * @returns string with a path\n */\nfunction getStoragePath() {\n  let fh = Cc[\"@mozilla.org/file/directory_service;1\"].\n           getService(Ci.nsIProperties).\n           get(\"ProfD\", Ci.nsIFile);\n  fh.append(\"jetpack\");\n  fh.append(programID);\n  fh.append(\"localization\");\n  file.mkpath(fh.path);\n  fh.append(\"l10n_cp.json\");\n  return fh.path;\n}\n\n/**\n * Returns last modification time for a file\n *\n * @returns integer with time in *milliseconds*\n */\nfunction getLastModificationTime(path) {\n  let file = Cc['@mozilla.org/file/local;1'].\n             createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  return file.lastModifiedTime;\n}\n\n/**\n * Returns a unix timestamp\n *\n * @returns integer with a unix timestamp\n */\nfunction getUnixTimeStamp() {\n  return parseInt(new Date().getTime().toString().substring(0,10));\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "localization"
        }
    }, 
    {
        "pk": 29, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cu,components} = require(\"chrome\");\nvar trackedObjects = {};\n\nvar Compacter = {\n  INTERVAL: 5000,\n  notify: function(timer) {\n    var newTrackedObjects = {};\n    for (name in trackedObjects) {\n      var oldBin = trackedObjects[name];\n      var newBin = [];\n      var strongRefs = [];\n      for (var i = 0; i < oldBin.length; i++) {\n        var strongRef = oldBin[i].weakref.get();\n        if (strongRef && strongRefs.indexOf(strongRef) == -1) {\n          strongRefs.push(strongRef);\n          newBin.push(oldBin[i]);\n        }\n      }\n      if (newBin.length)\n        newTrackedObjects[name] = newBin;\n    }\n    trackedObjects = newTrackedObjects;\n  }\n};\n\nvar timer = Cc[\"@mozilla.org/timer;1\"]\n            .createInstance(Ci.nsITimer);\n\ntimer.initWithCallback(Compacter,\n                       Compacter.INTERVAL,\n                       Ci.nsITimer.TYPE_REPEATING_SLACK);\n\nvar track = exports.track = function track(object, bin, stackFrameNumber) {\n  var frame = components.stack.caller;\n  var weakref = Cu.getWeakReference(object);\n  if (!bin)\n    bin = object.constructor.name;\n  if (bin == \"Object\")\n    bin = frame.name;\n  if (!bin)\n    bin = \"generic\";\n  if (!(bin in trackedObjects))\n    trackedObjects[bin] = [];\n\n  if (stackFrameNumber > 0)\n    for (var i = 0; i < stackFrameNumber; i++)\n      frame = frame.caller;\n\n  trackedObjects[bin].push({weakref: weakref,\n                            created: new Date(),\n                            filename: frame.filename,\n                            lineNo: frame.lineNumber});\n};\n\nvar getBins = exports.getBins = function getBins() {\n  var names = [];\n  for (name in trackedObjects)\n    names.push(name);\n  return names;\n};\n\nvar getObjects = exports.getObjects = function getObjects(bin) {\n  function getLiveObjectsInBin(bin, array) {\n    for (var i = 0; i < bin.length; i++) {\n      var object = bin[i].weakref.get();\n      if (object)\n        array.push(bin[i]);\n    }\n  }\n\n  var results = [];\n  if (bin) {\n    if (bin in trackedObjects)\n      getLiveObjectsInBin(trackedObjects[bin], results);\n  } else\n    for (name in trackedObjects)\n      getLiveObjectsInBin(trackedObjects[name], results);\n  return results;\n};\n\nvar gc = exports.gc = function gc() {\n  // Components.utils.forceGC() doesn't currently perform\n  // cycle collection, which means that e.g. DOM elements\n  // won't be collected by it. Fortunately, there are\n  // other ways...\n\n  var window = Cc[\"@mozilla.org/appshell/appShellService;1\"]\n               .getService(Ci.nsIAppShellService)\n               .hiddenDOMWindow;\n  var test_utils = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                   .getInterface(Ci.nsIDOMWindowUtils);\n  test_utils.garbageCollect();\n  Compacter.notify();\n\n  // Not sure why, but sometimes it appears that we don't get\n  // them all with just one CC, so let's do it again.\n  test_utils.garbageCollect();\n};\n\nrequire(\"unload\").when(\n  function() {\n    trackedObjects = {};\n    if (timer) {\n      timer.cancel();\n      timer = null;\n    }\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "memory"
        }
    }, 
    {
        "pk": 4, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Observers.\n *\n * The Initial Developer of the Original Code is Daniel Aquino.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Daniel Aquino <mr.danielaquino@gmail.com>\n *   Myk Melez <myk@mozilla.org>\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nvar xpcom = require(\"xpcom\");\n\n/**\n * A service for adding, removing and notifying observers of notifications.\n * Wraps the nsIObserverService interface.\n *\n * @version 0.2\n */\n\nvar service = Cc[\"@mozilla.org/observer-service;1\"].\n              getService(Ci.nsIObserverService);\n\n/**\n * A cache of observers that have been added.\n *\n * We use this to remove observers when a caller calls |Observers.remove|.\n */\nvar cache = [];\n\n/**\n * Topics specifically available to Jetpack-generated extensions.\n *\n * Using these predefined consts instead of the platform strings is good:\n *   - allows us to scope topics specifically for Jetpacks\n *   - addons aren't dependent on strings nor behavior of core platform topics\n *   - the core platform topics are not clearly named\n *\n */\nexports.topics = {\n  /**\n   * A topic indicating that the application is in a state usable\n   * by add-ons.\n   */\n  get APPLICATION_READY() packaging.jetpackID + \"_APPLICATION_READY\"\n};\n\n/**\n * Register the given callback as an observer of the given topic.\n *\n * @param   topic       {String}\n *          the topic to observe\n *\n * @param   callback    {Object}\n *          the callback; an Object that implements nsIObserver or a Function\n *          that gets called when the notification occurs\n *\n * @param   thisObject  {Object}  [optional]\n *          the object to use as |this| when calling a Function callback\n *\n * @returns the observer\n */\nvar add = exports.add = function add(topic, callback, thisObject) {\n  var observer = new Observer(topic, callback, thisObject);\n  service.addObserver(observer, topic, true);\n  cache.push(observer);\n\n  return observer;\n};\n\n/**\n * Unregister the given callback as an observer of the given topic.\n *\n * @param   topic       {String}\n *          the topic being observed\n *\n * @param   callback    {Object}\n *          the callback doing the observing\n *\n * @param   thisObject  {Object}  [optional]\n *          the object being used as |this| when calling a Function callback\n */\nvar remove = exports.remove = function remove(topic, callback, thisObject) {\n  // This seems fairly inefficient, but I'm not sure how much better\n  // we can make it.  We could index by topic, but we can't index by callback\n  // or thisObject, as far as I know, since the keys to JavaScript hashes\n  // (a.k.a. objects) can apparently only be primitive values.\n  var [observer] = cache.filter(function(v) {\n                                  return (v.topic      == topic    &&\n                                          v.callback   == callback &&\n                                          v.thisObject == thisObject);\n                                });\n  if (observer) {\n    service.removeObserver(observer, topic);\n    cache.splice(cache.indexOf(observer), 1);\n  }\n};\n\n/**\n * Notify observers about something.\n *\n * @param topic   {String}\n *        the topic to notify observers about\n *\n * @param subject {Object}  [optional]\n *        some information about the topic; can be any JS object or primitive\n *\n * @param data    {String}  [optional] [deprecated]\n *        some more information about the topic; deprecated as the subject\n *        is sufficient to pass all needed information to the JS observers\n *        that this module targets; if you have multiple values to pass to\n *        the observer, wrap them in an object and pass them via the subject\n *        parameter (i.e.: { foo: 1, bar: \"some string\", baz: myObject })\n */\nvar notify = exports.notify = function notify(topic, subject, data) {\n  subject = (typeof subject == \"undefined\") ? null : new Subject(subject);\n  data = (typeof    data == \"undefined\") ? null : data;\n  service.notifyObservers(subject, topic, data);\n};\n\nfunction Observer(topic, callback, thisObject) {\n  memory.track(this);\n  this.topic = topic;\n  this.callback = callback;\n  this.thisObject = thisObject;\n}\n\nObserver.prototype = {\n  QueryInterface: xpcom.utils.generateQI([Ci.nsIObserver,\n                                          Ci.nsISupportsWeakReference]),\n  observe: function(subject, topic, data) {\n    // Extract the wrapped object for subjects that are one of our\n    // wrappers around a JS object.  This way we support both wrapped\n    // subjects created using this module and those that are real\n    // XPCOM components.\n    if (subject && typeof subject == \"object\" &&\n        (\"wrappedJSObject\" in subject) &&\n        (\"observersModuleSubjectWrapper\" in subject.wrappedJSObject))\n      subject = subject.wrappedJSObject.object;\n\n    try {\n      if (typeof this.callback == \"function\") {\n        if (this.thisObject)\n          this.callback.call(this.thisObject, subject, data);\n        else\n          this.callback(subject, data);\n      } else // typeof this.callback == \"object\" (nsIObserver)\n        this.callback.observe(subject, topic, data);\n    } catch (e) {\n      console.exception(e);\n    }\n  }\n};\n\nfunction Subject(object) {\n  // Double-wrap the object and set a property identifying the\n  // wrappedJSObject as one of our wrappers to distinguish between\n  // subjects that are one of our wrappers (which we should unwrap\n  // when notifying our observers) and those that are real JS XPCOM\n  // components (which we should pass through unaltered).\n  this.wrappedJSObject = {\n    observersModuleSubjectWrapper: true,\n    object: object\n  };\n}\n\nSubject.prototype = {\n  QueryInterface: xpcom.utils.generateQI([]),\n  getHelperForLanguage: function() {},\n  getInterfaces: function() {}\n};\n\nrequire(\"unload\").when(\n  function removeAllObservers() {\n    // Make a copy of cache first, since cache will be changing as we\n    // iterate through it.\n    cache.slice().forEach(\n      function(observer) {\n        remove(observer.topic, observer.callback, observer.thisObject);\n      });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "observer-service"
        }
    }, 
    {
        "pk": 24, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Felipe Gomes <felipc@gmail.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\n\nconst XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\nlet hostFrame, hostDocument, hiddenWindow, isHostFrameReady = false;\n\nif (!require(\"xul-app\").isOneOf([\"Firefox\", \"Thunderbird\"])) {\n  throw new Error([\n    \"The page-worker module currently supports only Firefox and Thunderbird. \",\n    \"In the future we would like it to support other applications, however. Please \",\n    \"see https://bugzilla.mozilla.org/show_bug.cgi?id=546740 for more information.\"\n  ].join(\"\"));\n}\n\nlet appShellService = Cc[\"@mozilla.org/appshell/appShellService;1\"].\n                        getService(Ci.nsIAppShellService);\nhiddenWindow = appShellService.hiddenDOMWindow;\n\nif (!hiddenWindow) {\n  throw new Error([\n    \"The page-worker module needs an app that supports a hidden window. \",\n    \"We would like it to support other applications, however. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=546740 for more information.\"\n  ].join(\"\"));\n}\n\n// Check if we can use the hidden window itself to host our iframes.\n// If it's not a suitable host, the hostFrame will be lazily created\n// by the first Page Worker instance.\nif (hiddenWindow.location.protocol == \"chrome:\" &&\n    (hiddenWindow.document.contentType == \"application/vnd.mozilla.xul+xml\" ||\n     hiddenWindow.document.contentType == \"application/xhtml+xml\")) {\n  hostFrame = hiddenWindow;\n  hostDocument = hiddenWindow.document;\n  isHostFrameReady = true;\n}\n\nfunction setHostFrameReady() {\n  hostDocument = hostFrame.contentDocument;\n  hostFrame.removeEventListener(\"DOMContentLoaded\", setHostFrameReady, false);\n  isHostFrameReady = true;\n}\n\n// This cache is used to access friend properties between functions\n// without exposing them on the public API\nlet pageWorkerCache = [];\n\nfunction findInCache(pageWorker) {\n  for (let i in pageWorkerCache)\n    if (pageWorkerCache[i].ref === pageWorker)\n      return i;\n  return -1;\n}\n\nexports.Page = apiUtils.publicConstructor(Page);\n/**\n * Creates a background page by adding a <xul:iframe> into the hiddenWindow\n *\n * @params options\n *         If any of the following options are invalid, an error is thrown:\n *         @prop onReady\n *               A function to be called whenever a DOMContentLoaded event\n *               hits the <xul:iframe>. It can be used to know when this\n *               page-worker instance is ready or when the webpage inside\n *               it changed.\n */\nfunction Page(options) {\n\n  options = apiUtils.validateOptions(options, {\n    onReady: {\n      is: [\"undefined\", \"function\", \"array\"],\n      ok: function(v) {\n        if (v && v.constructor && v.constructor.name == \"Array\") {\n        // make sure every item is a function\n        for each (let item in v) {\n            if (typeof(item) !== \"function\") {\n              return false;\n            }\n          }\n        }\n        return true;\n      },\n      msg: \"The onReady option must be a function or an array of functions.\"\n    },\n    content: {\n      is: [\"undefined\", \"string\"],\n      msg: \"The content option must be an string with HTML or an URL.\"\n    },\n    allow: { }\n  });\n\n  require(\"collection\").addCollectionProperty(this, \"onReady\");\n  \n  if (options.onReady) {\n    this.onReady = options.onReady;\n  }\n\n  options.allow = options.allow || {};\n  options.content = options.content || \"\";\n\n  let self = this;\n\n  function configureAllowScript(newValue) {\n    let cacheEntry = findInCache(self);\n    // If start-up hasn't finished yet, browser or browser.docShell might be null.\n    // The value, however, won't be lost, since the most updated value will be picked\n    // during start-up.\n    let browser = (cacheEntry != -1) ? pageWorkerCache[cacheEntry].browser() : null;\n    if (browser && browser.docShell) {\n      browser.docShell.allowJavascript = !!newValue;\n    }\n  }\n\n  /* Public API: page.allow */\n  this.__defineGetter__(\"allow\", function() {\n    return {\n      get script() {\n        return options.allow.script || false;\n      },\n      set script(newValue) {\n        options.allow.script = !!newValue;\n        configureAllowScript(newValue);\n      }\n    }\n  });\n  this.__defineSetter__(\"allow\", function(newValue) {\n    self.allow.script = !!newValue.script;\n  });\n\n  /* Public API: page.content */\n  this.__defineGetter__(\"content\", function() {\n    return options.content || \"\";\n  });\n  this.__defineSetter__(\"content\", function(newVal) {\n    if (typeof(newVal) !== \"string\") {\n      throw \"The content attribute must be an string.\";\n    }\n    options.content = newVal;\n    let content = newVal;\n    try {\n      require(\"url\").URL(content);\n    } catch(e) {\n      content = \"data:text/html,\" + content;\n    }\n    let cacheEntry = findInCache(self);\n    if (cacheEntry != -1) {\n      pageWorkerCache[cacheEntry].ref.window.location.href = content;\n    }\n  });\n\n\n  if (!hostFrame) {\n    hostFrame = hiddenWindow.document.createElement(\"iframe\");\n\n    // ugly ugly hack. This is the most lightweight chrome:// file I could find on the tree\n    // This hack should be removed by proper platform support on bug 565388 \n    hostFrame.setAttribute(\"src\", \"chrome://global/content/mozilla.xhtml\");\n    hostFrame.addEventListener(\"DOMContentLoaded\", setHostFrameReady, false);\n\n    hiddenWindow.document.body.appendChild(hostFrame);\n  }\n\n}\n\nexports.add = function JP_SDK_Page_Worker_add(pageWorker) {\n\n  if (!(pageWorker instanceof Page)) {\n    throw new Error(\"The object to be added must be a Page Worker instance.\");\n  }\n\n  if (findInCache(pageWorker) != -1) {\n    // this instance was already added\n    return pageWorker;\n  }\n\n  let [browser, unloadFunction] = startPageWorker(pageWorker);\n\n  let cacheEntry = {\n    ref: pageWorker,\n    browser: browser,\n    unload: unloadFunction\n  };\n\n  pageWorkerCache.push(cacheEntry);\n\n  require(\"unload\").ensure(cacheEntry);\n\n  return pageWorker;\n}\n\nexports.remove = function JP_SDK_Page_Worker_remove(pageWorker) {\n\n  if (!(pageWorker instanceof Page)) {\n    throw new Error(\"The object to be removed must be a Page Worker instance.\");\n  }\n\n  let cacheEntry = findInCache(pageWorker);\n\n  if (cacheEntry != -1) {\n    pageWorkerCache[cacheEntry].unload();\n  }\n\n}\n\n\nfunction startPageWorker(self) {\n\n  /* Private members */\n  let browser = null;\n\n  /* Private helper function */\n  function onReadyListener(event) {\n    if (event.target == browser.contentDocument && self.onReady) {\n      for each (callback in self.onReady.__iterator__())\n        errors.catchAndLog(callback).call(self);\n    }\n  }\n\n  /* Private constructor */\n  function createPageWorkerElement() {\n    hostFrame.removeEventListener(\"DOMContentLoaded\", createPageWorkerElement, false);\n\n    browser = hostDocument.createElementNS(XUL_NS, \"iframe\");\n    browser.addEventListener(\"DOMContentLoaded\", onReadyListener, false);\n\n    let content = self.content || \"about:blank\";\n\n    try {\n      require(\"url\").URL(content);\n    } catch(e) {\n      content = \"data:text/html,\" + content;\n    }\n\n    browser.setAttribute(\"type\", \"content\");\n    browser.setAttribute(\"src\", content);\n\n    hostDocument.documentElement.appendChild(browser);\n\n    browser.docShell.allowJavascript = (self.allow && self.allow.script);\n\n    /* Public API: page.window */\n    self.__defineGetter__(\"window\", function () browser.contentWindow);\n\n    /* Public API: page.document */\n    self.__defineGetter__(\"document\", function () browser.contentDocument);\n\n  }\n\n  /* Begin element construction or schedule it for later */\n  if (isHostFrameReady) {\n    createPageWorkerElement();\n  } else {\n    hostFrame.addEventListener(\"DOMContentLoaded\", createPageWorkerElement, false);\n  }\n\n   /*\n   * Returns the browser reference and the unload function that finalizes this\n   *  Page Worker by clearing listeners and elements from this instance.\n   */\n  return [function() browser, function JP_SDK_Page_Worker_unload() {\n    try {\n      browser.removeEventListener(\"DOMContentLoaded\", onReadyListener, false);\n      hostDocument.documentElement.removeChild(browser);\n    } catch (e) { }\n    delete self.document;\n    delete self.window;\n    browser = null;\n    let entryPos = findInCache(self);\n    if (entryPos != -1)\n      pageWorkerCache.splice(entryPos, 1);\n  }];\n\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "page-worker"
        }
    }, 
    {
        "pk": 25, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\nfunction stringify(arg) {\n  try {\n    return String(arg);\n  }\n  catch(ex) {\n    return \"<toString() error>\";\n  }\n}\n\nfunction stringifyArgs(args) {\n  return Array.map(args, stringify).join(\" \");\n}\n\nfunction message(print, level, args) {\n  print(level + \": \" + stringifyArgs(args) + \"\\n\");\n}\n\nvar Console = exports.PlainTextConsole = function PlainTextConsole(print) {\n  if (!print)\n    print = dump;\n  if (print === dump) {\n    // If we're just using dump(), auto-enable preferences so\n    // that the developer actually sees the console output.\n    var prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                .getService(Ci.nsIPrefBranch);\n    prefs.setBoolPref(\"browser.dom.window.dump.enabled\", true);\n  }\n  this.print = print;\n};\n\nConsole.prototype = {\n  log: function log() {\n    message(this.print, \"info\", arguments);\n  },\n\n  info: function info() {\n    message(this.print, \"info\", arguments);\n  },\n\n  warn: function warn() {\n    message(this.print, \"warning\", arguments);\n  },\n\n  error: function error() {\n    message(this.print, \"error\", arguments);\n  },\n\n  debug: function debug() {\n    message(this.print, \"debug\", arguments);\n  },\n\n  exception: function exception(e) {\n    var fullString = (\"An exception occurred.\\n\" +\n                      require(\"traceback\").format(e) + \"\\n\" + e);\n    this.error(fullString);\n  },\n\n  trace: function trace() {\n    var traceback = require(\"traceback\");\n    var stack = traceback.get();\n    stack.splice(-1, 1);\n    message(this.print, \"info\", [traceback.format(stack)]);\n  }\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "plain-text-console"
        }
    }, 
    {
        "pk": 2, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Preferences.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org>\n *   Daniel Aquino <mr.danielaquino@gmail.com>\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// The minimum and maximum integers that can be set as preferences.\n// The range of valid values is narrower than the range of valid JS values\n// because the native preferences code treats integers as NSPR PRInt32s,\n// which are 32-bit signed integers on all platforms.\nconst MAX_INT = Math.pow(2, 31) - 1;\nconst MIN_INT = -MAX_INT;\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\n\nvar prefSvc = Cc[\"@mozilla.org/preferences-service;1\"].\n              getService(Ci.nsIPrefService).getBranch(null);\n\nvar get = exports.get = function get(name, defaultValue) {\n  switch (prefSvc.getPrefType(name)) {\n  case Ci.nsIPrefBranch.PREF_STRING:\n    return prefSvc.getComplexValue(name, Ci.nsISupportsString).data;\n\n  case Ci.nsIPrefBranch.PREF_INT:\n    return prefSvc.getIntPref(name);\n\n  case Ci.nsIPrefBranch.PREF_BOOL:\n    return prefSvc.getBoolPref(name);\n\n  case Ci.nsIPrefBranch.PREF_INVALID:\n    return defaultValue;\n\n  default:\n    // This should never happen.\n    throw new Error(\"Error getting pref \" + name +\n                    \"; its value's type is \" +\n                    prefSvc.getPrefType(name) +\n                    \", which I don't know \" +\n                    \"how to handle.\");\n  }\n};\n\nvar set = exports.set = function set(name, value) {\n  var prefType;\n  if (typeof value != \"undefined\" && value != null)\n    prefType = value.constructor.name;\n\n  switch (prefType) {\n  case \"String\":\n    {\n      var string = Cc[\"@mozilla.org/supports-string;1\"].\n                   createInstance(Ci.nsISupportsString);\n      string.data = value;\n      prefSvc.setComplexValue(name, Ci.nsISupportsString, string);\n    }\n    break;\n\n  case \"Number\":\n    // We throw if the number is outside the range, since the result\n    // will never be what the consumer wanted to store, but we only warn\n    // if the number is non-integer, since the consumer might not mind\n    // the loss of precision.\n    if (value > MAX_INT || value < MIN_INT)\n      throw new Error(\"you cannot set the \" + name +\n                      \" pref to the number \" + value +\n                      \", as number pref values must be in the signed \" +\n                      \"32-bit integer range -(2^31-1) to 2^31-1.  \" +\n                      \"To store numbers outside that range, store \" +\n                      \"them as strings.\");\n    if (value % 1 != 0)\n      throw new Error(\"cannot store non-integer number: \" + value);\n    prefSvc.setIntPref(name, value);\n    break;\n\n  case \"Boolean\":\n    prefSvc.setBoolPref(name, value);\n    break;\n\n  default:\n    throw new Error(\"can't set pref \" + name + \" to value '\" + value +\n                    \"'; it isn't a String, Number, or Boolean\");\n  }\n};\n\nvar has = exports.has = function has(name) {\n  return (prefSvc.getPrefType(name) != Ci.nsIPrefBranch.PREF_INVALID);\n};\n\nvar isSet = exports.isSet = function isSet(name) {\n  return (has(name) && prefSvc.prefHasUserValue(name));\n};\n\nvar reset = exports.reset = function reset(name) {\n  try {\n    prefSvc.clearUserPref(name);\n  } catch (e if e.result == Cr.NS_ERROR_UNEXPECTED) {\n    // The pref service throws NS_ERROR_UNEXPECTED when the caller tries\n    // to reset a pref that doesn't exist or is already set to its default\n    // value.  This interface fails silently in those cases, so callers\n    // can unconditionally reset a pref without having to check if it needs\n    // resetting first or trap exceptions after the fact.  It passes through\n    // other exceptions, however, so callers know about them, since we don't\n    // know what other exceptions might be thrown and what they might mean.\n  }\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "preferences-service"
        }
    }, 
    {
        "pk": 30, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *  Paul O\u2019Shannessy <paul@oshannessy.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst collection = require(\"collection\");\nconst observers = require(\"observer-service\");\nconst errors = require(\"errors\");\n\nlet pbService;\n// Currently, only Firefox implements the private browsing service.\nif (require(\"xul-app\").is(\"Firefox\")) {\n  pbService = Cc[\"@mozilla.org/privatebrowsing;1\"].\n              getService(Ci.nsIPrivateBrowsingService);\n}\n\n// make pb.active work\nexports.__defineGetter__(\"active\", function () {\n  return pbService ? pbService.privateBrowsingEnabled : false;\n});\n\nexports.__defineSetter__(\"active\", function (val) {\n  if (pbService) {\n    pbService.privateBrowsingEnabled = val;\n  }\n});\n\n// add our collection properties\ncollection.addCollectionProperty(exports, \"onBeforeStart\");\ncollection.addCollectionProperty(exports, \"onStart\");\ncollection.addCollectionProperty(exports, \"onAfterStart\");\ncollection.addCollectionProperty(exports, \"onBeforeStop\");\ncollection.addCollectionProperty(exports, \"onStop\");\ncollection.addCollectionProperty(exports, \"onAfterStop\");\n\n// implement functions to serve as delegators for various observer topics\nfunction onBeforeTransition(subject, data) {\n  subject.QueryInterface(Ci.nsISupportsPRBool);\n  // If subject is already true (by way of another observer), exit early.\n  if (subject.data)\n    return;\n\n  let callbacks = data == \"enter\" ? exports.onBeforeStart :\n                  data == \"exit\"  ? exports.onBeforeStop  : [];\n\n  for (let callback in callbacks) {\n    let cancelled = false;\n    // Since we're calling a user-defined callback, we need to catchAndLog it.\n    errors.catchAndLog(function () {\n      callback.call(exports, function () cancelled = true);\n    })();\n\n    // If cancel() was called, then we want to make sure the PB transition is\n    // cancelled and also stop executing any other callbacks we have.\n    if (cancelled) {\n      subject.data = true;\n      break;\n    }\n  }\n}\n\n// We don't need to do anything with cancel here.\nfunction onTransition(subject, data) {\n  let callbacks = data == \"enter\" ? exports.onStart :\n                  data == \"exit\"  ? exports.onStop  : [];\n  for (let callback in callbacks) {\n    errors.catchAndLog(function () {\n      callback.call(exports);\n    })();\n  }\n}\n\nfunction onAfterTransition(subject, data) {\n  // \"private-browsing-transition-complete\" isn't sent with \"enter\"/\"exit\", so\n  // determine which it was based on if PB is active.\n  let callbacks = exports.active ? exports.onAfterStart : exports.onAfterStop;\n  for (let callback in callbacks) {\n    errors.catchAndLog(function () {\n      callback.call(exports);\n    })();\n  }\n}\n\n// We only need to add observers if pbService exists.\nif (pbService) {\n  observers.add(\"private-browsing-cancel-vote\", onBeforeTransition);\n  observers.add(\"private-browsing\", onTransition);\n  observers.add(\"private-browsing-transition-complete\", onAfterTransition);\n}\n\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "private-browsing"
        }
    }, 
    {
        "pk": 27, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Paul O\u2019Shannessy <paul@oshannessy.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst xpcom = require(\"xpcom\");\nconst xhr = require(\"xhr\");\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\n\n// Instead of creating a new validator for each request, just make one and reuse it.\nconst validator = new OptionsValidator({\n  url: {\n    //XXXzpao should probably verify that url is a valid url as well\n    is:  [\"string\"]\n  },\n  onComplete: {\n    is:  [\"function\"],\n  },\n  headers: {\n    map: function (v) v || {},\n    is:  [\"object\"],\n  },\n  content: {\n    map: function (v) v || null,\n    is:  [\"string\", \"object\", \"null\"],\n  },\n  contentType: {\n    map: function (v) v || \"application/x-www-form-urlencoded\",\n    is:  [\"string\"]\n  }\n});\n\nconst REUSE_ERROR = \"This request object has been used already. You must \" +\n                    \"create a new one to make a new request.\"\n\nexports.Request = apiUtils.publicConstructor(Request);\n\nfunction Request(options) {\n  const self = this;\n  // request will hold the actual XHR object\n  let request;\n  let response;\n\n  options = validator.validateOptions(options);\n\n  // function to prep the request since it's the same between GET and POST\n  function makeRequest(mode) {\n    // If this request has already been used, then we can't reuse it. Throw an error.\n    if (request) {\n      throw new Error(REUSE_ERROR);\n    }\n\n    request = new xhr.XMLHttpRequest();\n\n    let url = options.url;\n    // Build the data to be set. For GET requests, we want to append that to\n    // the URL before opening the request.\n    let data = makeQueryString(options.content);\n    if (mode == \"GET\" && data) {\n      // If the URL already has ? in it, then we want to just use &\n      url = url + (/\\?/.test(url) ? \"&\" : \"?\") + data;\n    }\n\n    // open the request\n    request.open(mode, url);\n\n    // request header must be set after open, but before send\n    request.setRequestHeader(\"Content-Type\", options.contentType);\n\n    // set other headers\n    for (let k in options.headers) {\n      request.setRequestHeader(k, options.headers[k]);\n    }\n\n    // handle the readystate, create the response, and call the callback\n    request.onreadystatechange = function () {\n      if (request.readyState == 4) {\n        response = new Response(request);\n        errors.catchAndLog(function () {\n          options.onComplete.call(self);\n        })();\n      }\n    }\n\n    // actually send the request. we only want to send data on POST requests\n    request.send(mode == \"POST\" ? data : null);\n  }\n\n  // Map these setters/getters to the options\n  [\"url\", \"headers\", \"onComplete\", \"content\", \"contentType\"].forEach(function (k) {\n    this.__defineGetter__(k, function () options[k]);\n    this.__defineSetter__(k, function (v) {\n      // This will automatically rethrow errors from apiUtils.validateOptions.\n      return options[k] = validator.validateSingleOption(k, v);\n    });\n  }, this);\n\n  // response should be available as a getter\n  this.__defineGetter__(\"response\", function () response);\n\n  this.get = function () {\n    makeRequest(\"GET\");\n    return this;\n  };\n\n  this.post = function () {\n    makeRequest(\"POST\");\n    return this;\n  };\n\n}\n\n// Converts an object of unordered key-vals to a string that can be passed\n// as part of a request\nfunction makeQueryString(content) {\n  // Explicitly return null if we have null, and empty string, or empty object.\n  if (!content) {\n    return null;\n  }\n\n  // If content is already a string, just return it as is.\n  if (typeof(content) == \"string\") {\n    return content;\n  }\n\n  // At this point we have a k:v object. Iterate over it and encode each value.\n  // Arrays and nested objects will get encoded as needed. For example...\n  //\n  //   { foo: [1, 2, { omg: \"bbq\", \"all your base!\": \"are belong to us\" }], bar: \"baz\" }\n  //\n  // will be encoded as\n  //\n  //   foo[0]=1&foo[1]=2&foo[2][omg]=bbq&foo[2][all+your+base!]=are+belong+to+us&bar=baz\n  //\n  // Keys (including \"[\" and \"]\") and values will be encoded with\n  // fixedEncodeURIComponent before returning.\n  //\n  // Execution was inspired by jQuery, but some details have changed and numeric\n  // array keys are included (whereas they are not in jQuery).\n\n  let encodedContent = [];\n  function add(key, val) {\n    encodedContent.push(fixedEncodeURIComponent(key) + \"=\" +\n                        fixedEncodeURIComponent(val));\n  }\n\n  function make(key, val) {\n    if (typeof(val) == \"object\") {\n      for ([k, v] in Iterator(val)) {\n        make(key + \"[\" + k + \"]\", v);\n      }\n    }\n    else {\n      add(key, val)\n    }\n  }\n  for ([k, v] in Iterator(content)) {\n    make(k, v);\n  }\n  return encodedContent.join(\"&\");\n\n  //XXXzpao In theory, we can just use a FormData object on 1.9.3, but I had\n  //        trouble getting that working. It would also be nice to stay\n  //        backwards-compat as long as possible. Keeping this in for now...\n  // let formData = Cc[\"@mozilla.org/files/formdata;1\"].\n  //                createInstance(Ci.nsIDOMFormData);\n  // for ([k, v] in Iterator(content)) {\n  //   formData.append(k, v);\n  // }\n  // return formData;\n}\n\n\n// encodes a string safely for application/x-www-form-urlencoded\n// adheres to RFC 3986\n// see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Functions/encodeURIComponent\nfunction fixedEncodeURIComponent (str) {\n  return encodeURIComponent(str).replace(/%20/g, \"+\").replace(/!/g, \"%21\").\n                                 replace(/'/g, \"%27\").replace(/\\(/g, \"%28\").\n                                 replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\n\nfunction Response(request) {\n  // Define the straight mappings of our value to original request value\n  xpcom.utils.defineLazyGetter(this, \"text\", function () request.responseText);\n  xpcom.utils.defineLazyGetter(this, \"xml\", function () request.responseXML);\n  xpcom.utils.defineLazyGetter(this, \"status\", function () request.status);\n  xpcom.utils.defineLazyGetter(this, \"statusText\", function () request.statusText);\n\n  // this.json should be the JS object, so we need to attempt to parse it.\n  xpcom.utils.defineLazyGetter(this, \"json\", function () {\n    let _json = null;\n    try {\n      _json = JSON.parse(this.text);\n    }\n    catch (e) {}\n    return _json;\n  });\n\n  // this.headers also should be a JS object, so we need to split up the raw\n  // headers string provided by the request.\n  xpcom.utils.defineLazyGetter(this, \"headers\", function () {\n    let _headers = {};\n    let lastKey;\n    // Since getAllResponseHeaders() will return null if there are no headers,\n    // defend against it by defaulting to \"\"\n    let rawHeaders = request.getAllResponseHeaders() || \"\";\n    rawHeaders.split(\"\\n\").forEach(function (h) {\n      // According to the HTTP spec, the header string is terminated by an empty\n      // line, so we can just skip it.\n      if (!h.length) {\n        return;\n      }\n\n      let index = h.indexOf(\":\");\n      // The spec allows for leading spaces, so instead of assuming a single\n      // leading space, just trim the values.\n      let key = h.substring(0, index).trim(),\n          val = h.substring(index + 1).trim();\n\n      // For empty keys, that means that the header value spanned multiple lines.\n      // In that case we should append the value to the value of lastKey with a\n      // new line. We'll assume lastKey will be set because there should never\n      // be an empty key on the first pass.\n      if (key) {\n        _headers[key] = val;\n        lastKey = key;\n      }\n      else {\n        _headers[lastKey] += \"\\n\" + val;\n      }\n    });\n    return _headers;\n  })\n}\n\n// apiUtils.validateOptions doesn't give the ability to easily validate single\n// options, so this is a wrapper that provides that ability.\nfunction OptionsValidator(rules) {\n  this.rules = rules;\n\n  this.validateOptions = function (options) {\n    return apiUtils.validateOptions(options, this.rules);\n  }\n\n  this.validateSingleOption = function (field, value) {\n    // We need to create a single rule object from our listed rules. To avoid\n    // JavaScript String warnings, check for the field & default to an empty object.\n    let singleRule = {};\n    if (field in this.rules) {\n      singleRule[field] = this.rules[field];\n    }\n    let singleOption = {};\n    singleOption[field] = value;\n    // This should throw if it's invalid, which will bubble up & out.\n    return apiUtils.validateOptions(singleOption, singleRule)[field];\n  }\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "request"
        }
    }, 
    {
        "pk": 23, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n(function(global) {\n   const Cc = Components.classes;\n   const Ci = Components.interfaces;\n   const Cu = Components.utils;\n   const Cr = Components.results;\n\n   var exports = {};\n\n   var ios = Cc['@mozilla.org/network/io-service;1']\n             .getService(Ci.nsIIOService);\n\n   var systemPrincipal = Cc[\"@mozilla.org/systemprincipal;1\"]\n                         .createInstance(Ci.nsIPrincipal);\n\n   function resolvePrincipal(principal, defaultPrincipal) {\n     if (principal === undefined)\n       return defaultPrincipal;\n     if (principal == \"system\")\n       return systemPrincipal;\n     return principal;\n   }\n\n   // The base URI to we use when we're given relative URLs, if any.\n   var baseURI = null;\n   if (global.window)\n     baseURI = ios.newURI(global.location.href, null, null);\n   exports.baseURI = baseURI;\n\n   // The \"parent\" chrome URI to use if we're loading code that\n   // needs chrome privileges but may not have a filename that\n   // matches any of SpiderMonkey's defined system filename prefixes.\n   // The latter is needed so that wrappers can be automatically\n   // made for the code. For more information on this, see\n   // bug 418356:\n   //\n   // https://bugzilla.mozilla.org/show_bug.cgi?id=418356\n   var parentChromeURIString;\n   if (baseURI)\n     // We're being loaded from a chrome-privileged document, so\n     // use its URL as the parent string.\n     parentChromeURIString = baseURI.spec;\n   else\n     // We're being loaded from a chrome-privileged JS module or\n     // SecurableModule, so use its filename (which may itself\n     // contain a reference to a parent).\n     parentChromeURIString = Components.stack.filename;\n\n   function maybeParentifyFilename(filename) {\n     var doParentifyFilename = true;\n     try {\n       // TODO: Ideally we should just make\n       // nsIChromeRegistry.wrappersEnabled() available from script\n       // and use it here. Until that's in the platform, though,\n       // we'll play it safe and parentify the filename unless\n       // we're absolutely certain things will be ok if we don't.\n       var filenameURI = ios.newURI(options.filename,\n                                    null,\n                                    baseURI);\n       if (filenameURI.scheme == 'chrome' &&\n           filenameURI.path.indexOf('/content/') == 0)\n         // Content packages will always have wrappers made for them;\n         // if automatic wrappers have been disabled for the\n         // chrome package via a chrome manifest flag, then\n         // this still works too, to the extent that the\n         // content package is insecure anyways.\n         doParentifyFilename = false;\n     } catch (e) {}\n     if (doParentifyFilename)\n       return parentChromeURIString + \" -> \" + filename;\n     return filename;\n   }\n\n   function getRootDir(urlStr) {\n     // TODO: This feels hacky, and like there will be edge cases.\n     return urlStr.slice(0, urlStr.lastIndexOf(\"/\") + 1);\n   }\n\n   exports.SandboxFactory = function SandboxFactory(defaultPrincipal) {\n     // Unless specified otherwise, use a principal with limited\n     // privileges.\n     this._defaultPrincipal = resolvePrincipal(defaultPrincipal,\n                                               \"http://www.mozilla.org\");\n   },\n\n   exports.SandboxFactory.prototype = {\n     createSandbox: function createSandbox(options) {\n       var principal = resolvePrincipal(options.principal,\n                                        this._defaultPrincipal);\n\n       return {\n         _sandbox: new Cu.Sandbox(principal),\n         _principal: principal,\n         get globalScope() {\n           return this._sandbox;\n         },\n         defineProperty: function defineProperty(name, value) {\n           this._sandbox[name] = value;\n         },\n         getProperty: function getProperty(name) {\n           return this._sandbox[name];\n         },\n         evaluate: function evaluate(options) {\n           if (typeof(options) == 'string')\n             options = {contents: options};\n           options = {__proto__: options};\n           if (typeof(options.contents) != 'string')\n             throw new Error('Expected string for options.contents');\n           if (options.lineNo === undefined)\n             options.lineNo = 1;\n           if (options.jsVersion === undefined)\n             options.jsVersion = \"1.8\";\n           if (typeof(options.filename) != 'string')\n             options.filename = '<string>';\n\n           if (this._principal == systemPrincipal)\n             options.filename = maybeParentifyFilename(options.filename);\n\n           return Cu.evalInSandbox(options.contents,\n                                   this._sandbox,\n                                   options.jsVersion,\n                                   options.filename,\n                                   options.lineNo);\n         }\n       };\n     }\n   };\n\n   exports.Loader = function Loader(options) {\n     options = {__proto__: options};\n     if (options.fs === undefined) {\n       var rootPaths = options.rootPath || options.rootPaths;\n       if (rootPaths) {\n         if (rootPaths.constructor.name != \"Array\")\n           rootPaths = [rootPaths];\n         var fses = [new exports.LocalFileSystem(path)\n                     for each (path in rootPaths)];\n         options.fs = new exports.CompositeFileSystem(fses);\n       } else\n         options.fs = new exports.LocalFileSystem();\n     }\n     if (options.sandboxFactory === undefined)\n       options.sandboxFactory = new exports.SandboxFactory(\n         options.defaultPrincipal\n       );\n     if (options.modules === undefined)\n       options.modules = {};\n     if (options.globals === undefined)\n       options.globals = {};\n\n     this.fs = options.fs;\n     this.sandboxFactory = options.sandboxFactory;\n     this.sandboxes = {};\n     this.modules = options.modules;\n     this.globals = options.globals;\n   };\n\n   exports.Loader.prototype = {\n     _makeRequire: function _makeRequire(rootDir) {\n       var self = this;\n\n       return function require(module) {\n         if (module == \"chrome\") {\n           var chrome = { Cc: Components.classes,\n                          Ci: Components.interfaces,\n                          Cu: Components.utils,\n                          Cr: Components.results,\n                          Cm: Components.manager,\n                          components: Components\n                        };\n           return chrome;\n         }\n\n         var path = self.fs.resolveModule(rootDir, module);\n         if (!path)\n           throw new Error('Module \"' + module + '\" not found');\n         if (!(path in self.modules)) {\n           var options = self.fs.getFile(path);\n           if (options.filename === undefined)\n             options.filename = path;\n\n           var exports = {};\n           var sandbox = self.sandboxFactory.createSandbox(options);\n           self.sandboxes[path] = sandbox;\n           for (name in self.globals)\n             sandbox.defineProperty(name, self.globals[name]);\n           sandbox.defineProperty('require', self._makeRequire(path));\n           sandbox.evaluate(\"var exports = {};\");\n           self.modules[path] = sandbox.getProperty(\"exports\");\n           sandbox.evaluate(options);\n         }\n         return self.modules[path];\n       };\n     },\n\n     findSandboxForModule: function findSandboxForModule(module) {\n       var path = this.fs.resolveModule(null, module);\n       if (!path)\n         throw new Error('Module \"' + module + '\" not found');\n       if (!(path in this.sandboxes))\n         this.require(module);\n       if (!(path in this.sandboxes))\n         throw new Error('Internal error: path not in sandboxes: ' +\n                         path);\n       return this.sandboxes[path];\n     },\n\n     require: function require(module) {\n       return (this._makeRequire(null))(module);\n     },\n\n     runScript: function runScript(options, extraOutput) {\n       if (typeof(options) == 'string')\n         options = {contents: options};\n       options = {__proto__: options};\n       var sandbox = this.sandboxFactory.createSandbox(options);\n       if (extraOutput)\n         extraOutput.sandbox = sandbox;\n       for (name in this.globals)\n         sandbox.defineProperty(name, this.globals[name]);\n       sandbox.defineProperty('require', this._makeRequire(null));\n       return sandbox.evaluate(options);\n     }\n   };\n\n   exports.CompositeFileSystem = function CompositeFileSystem(fses) {\n     this.fses = fses;\n     this._pathMap = {};\n   };\n\n   exports.CompositeFileSystem.prototype = {\n     resolveModule: function resolveModule(base, path) {\n       for (var i = 0; i < this.fses.length; i++) {\n         var fs = this.fses[i];\n         var absPath = fs.resolveModule(base, path);\n         if (absPath) {\n           this._pathMap[absPath] = fs;\n           return absPath;\n         }\n       }\n       return null;\n     },\n     getFile: function getFile(path) {\n       return this._pathMap[path].getFile(path);\n     }\n   };\n\n   exports.LocalFileSystem = function LocalFileSystem(root) {\n     if (root === undefined) {\n       if (!baseURI)\n         throw new Error(\"Need a root path for module filesystem\");\n       root = baseURI;\n     }\n     if (typeof(root) == 'string')\n       root = ios.newURI(root, null, baseURI);\n     if (root instanceof Ci.nsIFile)\n       root = ios.newFileURI(root);\n     if (!(root instanceof Ci.nsIURI))\n       throw new Error('Expected nsIFile, nsIURI, or string for root');\n\n     this.root = root.spec;\n     this._rootURI = root;\n     this._rootURIDir = getRootDir(root.spec);\n   };\n\n   exports.LocalFileSystem.prototype = {\n     resolveModule: function resolveModule(base, path) {\n       path = path + \".js\";\n\n       var baseURI;\n       if (!base || path.charAt(0) != '.')\n         baseURI = this._rootURI;\n       else\n         baseURI = ios.newURI(base, null, null);\n       var newURI = ios.newURI(path, null, baseURI);\n       if (newURI.spec.indexOf(this._rootURIDir) == 0) {\n         var channel = ios.newChannelFromURI(newURI);\n         try {\n           channel.open().close();\n         } catch (e if e.result == Cr.NS_ERROR_FILE_NOT_FOUND) {\n           return null;\n         }\n         return newURI.spec;\n       }\n       return null;\n     },\n     getFile: function getFile(path) {\n       var channel = ios.newChannel(path, null, null);\n       var iStream = channel.open();\n       var ciStream = Cc[\"@mozilla.org/intl/converter-input-stream;1\"].\n                      createInstance(Ci.nsIConverterInputStream);\n       var bufLen = 0x8000;\n       ciStream.init(iStream, \"UTF-8\", bufLen,\n                     Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n       var chunk = {};\n       var data = \"\";\n       while (ciStream.readString(bufLen, chunk) > 0)\n         data += chunk.value;\n       ciStream.close();\n       iStream.close();\n       return {contents: data};\n     }\n   };\n\n   if (global.window) {\n     // We're being loaded in a chrome window, or a web page with\n     // UniversalXPConnect privileges.\n     global.SecurableModule = exports;\n   } else if (global.exports) {\n     // We're being loaded in a SecurableModule.\n     for (name in exports) {\n       global.exports[name] = exports[name];\n     }\n   } else {\n     // We're being loaded in a JS module.\n     global.EXPORTED_SYMBOLS = [];\n     for (name in exports) {\n       global.EXPORTED_SYMBOLS.push(name);\n       global[name] = exports[name];\n     }\n   }\n })(this);\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "securable-module"
        }
    }, 
    {
        "pk": 6, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Eric H. Jung <eric.jung@yahoo.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The selection module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nlet {Ci} = require(\"chrome\");\n\n// The selection type HTML\nconst HTML = 0x01;\n\n// The selection type TEXT\nconst TEXT = 0x02;\n\n// The selection type DOM (internal use only)\nconst DOM  = 0x03;\n\n/**\n * Creates an object from which a selection can be set, get, etc. Each\n * object has an associated with a range number. Range numbers are the\n * 0-indexed counter of selection ranges as explained at\n * https://developer.mozilla.org/en/DOM/Selection.\n *\n * @param rangeNumber\n *        The zero-based range index into the selection\n */\nfunction Selection(rangeNumber) {\n\n  // In order to hide the private rangeNumber argument from API consumers while\n  // still enabling Selection getters/setters to access it, the getters/setters\n  // are defined as lexical closures in the Selector constructor.\n\n  this.__defineGetter__(\"text\", function () getSelection(TEXT, rangeNumber));\n  this.__defineSetter__(\"text\", function (str) setSelection(str, rangeNumber));\n\n  this.__defineGetter__(\"html\", function () getSelection(HTML, rangeNumber));\n  this.__defineSetter__(\"html\", function (str) setSelection(str, rangeNumber));\n\n  this.__defineGetter__(\"contiguous\", function () {\n    let sel = getSelection(DOM, rangeNumber);\n    // It isn't enough to check that rangeCount is zero. If one or more ranges\n    // are selected and then unselected, rangeCount is set to one, not zero.\n    // Therefore, if rangeCount is one, we also check if the selection is\n    // collapsed.\n    if (sel.rangeCount == 0)\n      return null;\n    if (sel.rangeCount == 1) {\n      let range = safeGetRange(sel, 0);\n      return range && range.collapsed ? null : true;\n    }\n    return false;\n  });\n}\n\nrequire(\"xpcom\").utils.defineLazyServiceGetter(this, \"windowMediator\",\n  \"@mozilla.org/appshell/window-mediator;1\", \"nsIWindowMediator\");\n\n/**\n * Returns the most recent content window\n */\nfunction context() {\n  // Overlay names should probably go into the xul-app module instead of here\n  return windowMediator.getMostRecentWindow(\"navigator:browser\").document.\n    commandDispatcher.focusedWindow;\n}\n\n/**\n * Returns the current selection from most recent content window. Depending on\n * the specified |type|, the value returned can be a string of text, stringified\n * HTML, or a DOM selection object as described at\n * https://developer.mozilla.org/en/DOM/Selection.\n *\n * @param type\n *        Specifies the return type of the selection. Valid values are the one\n *        of the constants HTML, TEXT, or DOM.\n *\n * @param rangeNumber\n *        Specifies the zero-based range index of the returned selection.\n */\nfunction getSelection(type, rangeNumber) {\n  let window, selection;\n  try {\n    window = context();\n    selection = window.getSelection();\n  }\n  catch (e) {\n    return null;\n  }\n\n  // Get the selected content as the specified type\n  if (type == DOM)\n    return selection;\n  else if (type == TEXT) {\n    let range = safeGetRange(selection, rangeNumber);\n    return range ? range.toString() : null;\n  }\n  else if (type == HTML) {\n    let range = safeGetRange(selection, rangeNumber);\n    // Another way, but this includes the xmlns attribute for all elements in\n    // Gecko 1.9.2+ :\n    // return Cc[\"@mozilla.org/xmlextras/xmlserializer;1\"].\n    //   createInstance(Ci.nsIDOMSerializer).serializeToSTring(range.\n    //     cloneContents());\n    if (!range)\n      return null;\n    let node = window.document.createElement(\"span\");\n    node.appendChild(range.cloneContents());\n    return node.innerHTML;\n  }\n  throw new Error(\"Type \" + type + \" is unrecognized.\");\n}\n\n/**\n * Returns the specified range in a selection without throwing an exception.\n *\n * @param selection\n *        A selection object as described at\n *         https://developer.mozilla.org/en/DOM/Selection\n *\n * @param rangeNumber\n *        Specifies the zero-based range index of the returned selection.\n */\nfunction safeGetRange(selection, rangeNumber) {\n  try {\n    let range = selection.getRangeAt(rangeNumber);\n    if (!range || range.toString() == \"\")\n      return null;\n    return range;\n  }\n  catch (e) {\n    return null;\n  }\n}\n\n/**\n * Sets the current selection of the most recent content document by changing\n * the existing selected text/HTML range to the specified value.\n *\n * @param val\n *        The value for the new selection\n *\n * @param rangeNumber\n *        The zero-based range index of the selection to be set\n *\n */\nfunction setSelection(val, rangeNumber) {\n    // Make sure we have a window context & that there is a current selection.\n    // Selection cannot be set unless there is an existing selection.\n    let window, range;\n    try {\n      window = context();\n      range = window.getSelection().getRangeAt(rangeNumber);\n    }\n    catch (e) {\n      // Rethrow with a more developer-friendly message than the caught\n      // exception.\n      throw new Error(\"It isn't possible to change the selection, as there isn't currently a selection\");\n    }\n    // Get rid of the current selection and insert our own\n    range.deleteContents();\n    let node = window.document.createElement(\"span\");\n    range.surroundContents(node);\n\n    // Some relevant JEP-111 requirements:\n\n    // Setting the text property replaces the selection with the value to\n    // which the property is set and sets the html property to the same value\n    // to which the text property is being set.\n\n    // Setting the html property replaces the selection with the value to\n    // which the property is set and sets the text property to the text version\n    // of the HTML value.\n\n    // This sets both the HTML and text properties.\n    node.innerHTML = val;\n}\n\nfunction onLoad(event) {\n  SelectionListenerManager.onLoad(event);\n}\n\nfunction onUnload(event) {\n  SelectionListenerManager.onUnload(event);\n}\n\nlet SelectionListenerManager = {\n  QueryInterface: require(\"xpcom\").utils.generateQI([Ci.nsISelectionListener]),\n\n  // The collection of listeners wanting to be notified of selection changes\n  listeners: [],\n\n  /**\n   * This is the nsISelectionListener implementation. This function is called\n   * by Gecko when a selection is changed interactively.\n   *\n   * We only pay attention to the SELECTALL, KEYPRESS, and MOUSEUP selection\n   * reasons. All reasons are listed here:\n   *\n   * http://mxr.mozilla.org/mozilla1.9.2/source/content/base/public/\n   *   nsISelectionListener.idl\n   *\n   * The other reasons (NO_REASON, DRAG_REASON, MOUSEDOWN_REASON) aren't\n   * applicable to us.\n   */\n  notifySelectionChanged: function notifySelectionChanged(document, selection,\n                                                          reason) {\n    if (![\"SELECTALL\", \"KEYPRESS\", \"MOUSEUP\"].some(function(type) reason &\n      Ci.nsISelectionListener[type + \"_REASON\"]) || selection.toString() == \"\")\n        return;\n\n    // Notify each listener immediately but don't block on them.\n    this.listeners.forEach(function(listener) {\n      require(\"timer\").setTimeout(function() {\n        // Catch exceptions so that other listeners, if any, are still called.\n        require(\"errors\").catchAndLog(function() listener.call(exports))();\n      }, 0);\n    });\n  },\n\n  /**\n   * Part of the Tracker implementation. This function is called by the\n   * tabs module when a browser is being tracked. Often, that means a new tab\n   * has been opened, but it can also mean an addon has been installed while\n   * tabs are already opened. In that case, this function is called for those\n   * already-opened tabs.\n   *\n   * @param browser\n   *        The browser being tracked\n   */\n  onTrack: function onTrack(browser) {\n    browser.addEventListener(\"load\", onLoad, true);\n    browser.addEventListener(\"unload\", onUnload, true);\n  },\n\n  onLoad: function onLoad(event) {\n    // Nothing to do without a useful window\n    let window = event.target.defaultView;\n    if (!window)\n      return;\n\n    // Wrap the add selection call with some number of setTimeout 0 because some\n    // reason it's possible to add a selection listener \"too early\". 2 sometimes\n    // works for gmail, and more consistently with 3, so make it 5 to be safe.\n    let count = 0;\n    let self = this;\n    function wrap(count, func) {\n      if (count-- > 0)\n        require(\"timer\").setTimeout(wrap, 0);\n      else\n        self.addSelectionListener(window);\n    }\n    wrap();\n  },\n\n  addSelectionListener: function addSelectionListener(window) {\n    if (window.jetpack_core_selection_listener)\n      return;\n    let selection = window.getSelection();\n    if (selection instanceof Ci.nsISelectionPrivate)\n      selection.addSelectionListener(this);\n    window.jetpack_core_selection_listener = true;\n  },\n\n  onUnload: function onUnload(event) {\n    // Nothing to do without a useful window\n    let window = event.target.defaultView;\n    if (!window)\n      return;\n    this.removeSelectionListener(window);\n  },\n\n  removeSelectionListener: function removeSelectionListener(window) {\n    if (!window.jetpack_core_selection_listener)\n      return;\n    let selection = window.getSelection();\n    if (selection instanceof Ci.nsISelectionPrivate)\n      selection.removeSelectionListener(this);\n    window.jetpack_core_selection_listener = false;\n  },\n\n  /**\n   * Part of the TabTracker implementation. This function is called by the\n   * tabs module when a browser is being untracked. Usually, that means a tab\n   * has been closed.\n   *\n   * @param browser\n   *        The browser being untracked\n   */\n  onUntrack: function onUntrack(browser) {\n    browser.removeEventListener(\"load\", onLoad, true);\n    browser.removeEventListener(\"unload\", onUnload, true);\n  }\n};\n\n/**\n * Install |SelectionListenerManager| as tab tracker in order to watch\n * tab opening/closing\n */\nrequire(\"tab-browser\").Tracker(SelectionListenerManager);\n\n/**\n * Exports an iterator so that discontiguous selections can be iterated.\n */\nexports.__iterator__ = function __iterator__() {\n  for (let i = 0, sel = getSelection(DOM); i < sel.rangeCount; i++)\n    yield new Selection(i);\n};\n\n/**\n * Exports the |onSelect| collection property, using\n * |SelectionListenerManager.listeners| as the backing array.\n */\nrequire(\"collection\").addCollectionProperty(exports, \"onSelect\",\n  SelectionListenerManager.listeners);\n\n// Export the Selection singleton. Its rangeNumber is always zero.\nSelection.call(exports, 0);\n\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "selection"
        }
    }, 
    {
        "pk": 16, 
        "model": "jetpack.module", 
        "fields": {
            "code": "\nlet file = require(\"file\");\nlet url = require(\"url\");\nlet traceback = require(\"traceback\");\n\nlet packageData = packaging.options.packageData;\nlet resourcePackages = packaging.options.resourcePackages;\nlet id = packaging.jetpackID;\nexports.id = id;\n\n// what URI was our Nth parent stack frame loaded from? We use this to\n// determine \"who\" has called our load() or url() methods. This is an\n// unpleasant hack that needs to be replaced: the real question to ask is\n// \"who\" did the require(\"self\") call. The \"self\" module should not be a\n// singleton: each invocation of require() could get a separate one. I\n// *think* the right level of granularity is that each package gets a\n// separate instance: all packages in an XPI bundle will share the same\n// ID, but each package will have a separate resource/data directory. So\n// package1.moduleA and package1.moduleB will both get the same data when\n// they do require(\"self\").data.load(\"foo.txt\"), but package2.moduleC\n// will get something different for the same code.\n\n// The biggest problem with using stack introspection at the time of\n// load()/url() is confusion: the module is allowed to pass their\n// require(\"self\").data object to someone else, with the expectation that\n// the recipient is going to get the same data they would have gotten.\n// The second biggest problem is confused deputy.\n\nfunction caller(levels) {\n    let callerInfo = traceback.get().slice(-2-levels)[0];\n    let info = url.URL(callerInfo.filename);\n    let pkgName = resourcePackages[info.host];\n    // pkgName is \"my-package\", suitable for lookup in options[\"packageData\"]\n    return pkgName;\n}\n\nfunction getURL(name, level) {\n    let pkgName = caller(level+1);\n    // packageData[] = \"resource://jetpack-JID-PKGNAME-data/\"\n    if (pkgName in packageData)\n        return url.URL(name, packageData[pkgName]).toString();\n    throw new Error(\"No data for package \" + pkgName);\n}\n\nexports.data = {\n    load: function load(name) {\n        let data_url = getURL(name, 1);\n        let fn = url.toFilename(data_url);\n        let data = file.read(fn);\n        return data;\n    },\n    url: function url(name) { return getURL(name, 1); }\n}\n\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "self"
        }
    }, 
    {
        "pk": 21, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst collection = require(\"collection\");\nconst file = require(\"file\");\nconst prefs = require(\"preferences-service\");\nconst jpSelf = require(\"self\");\nconst timer = require(\"timer\");\nconst unload = require(\"unload\");\n\nconst WRITE_PERIOD_PREF = \"jetpack.jetpack-core.simple-storage.writePeriod\";\nconst WRITE_PERIOD_DEFAULT = 300000; // 5 minutes\n\nconst QUOTA_PREF = \"jetpack.jetpack-core.simple-storage.quota\";\nconst QUOTA_DEFAULT = 5242880; // 5 MiB\n\n\n// simpleStorage.storage\nexports.__defineGetter__(\"storage\", function () manager.root);\nexports.__defineSetter__(\"storage\", function (val) manager.root = val);\n\n// simpleStorage.quotaUsage\nexports.__defineGetter__(\"quotaUsage\", function () manager.quotaUsage);\n\n// simpleStorage.onOverQuota\ncollection.addCollectionProperty(exports, \"onOverQuota\");\n\n\n// A generic JSON store backed by a file on disk.  This should be isolated\n// enough to move to its own module if need be...\nfunction JsonStore(options) {\n  this.filename = options.filename;\n  this.quota = options.quota;\n  this.writePeriod = options.writePeriod;\n  this.onOverQuota = options.onOverQuota || new collection.Collection();\n  this.onWrite = options.onWrite || new collection.Collection();\n  this.observersThisArg = options.observersThisArg;\n\n  unload.ensure(this);\n\n  const self = this;\n  this.writeTimer = timer.setInterval(function JsonStore_periodicWrite() {\n    self.write();\n  }, this.writePeriod);\n}\n\nJsonStore.prototype = {\n\n  // The store's root.\n  get root() {\n    return this._root === undefined ? {} : this._root;\n  },\n\n  // Performs some type checking.\n  set root(val) {\n    let types = [\"array\", \"boolean\", \"null\", \"number\", \"object\", \"string\"];\n    if (types.indexOf(typeof(val)) < 0) {\n      throw new Error(\"storage must be one of the following types: \" +\n                      types.join(\", \"));\n    }\n    this._root = val;\n    return val;\n  },\n\n  // Percentage of quota used, as a number [0, Inf).  > 1 implies over quota.\n  // Undefined if there is no quota.\n  get quotaUsage() {\n    return this.quota > 0 ?\n           JSON.stringify(this.root).length / this.quota :\n           undefined;\n  },\n\n  // Removes the backing file and all empty subdirectories.\n  purge: function JsonStore_purge() {\n    try {\n      // This'll throw if the file doesn't exist.\n      file.remove(this.filename);\n      let parentPath = this.filename;\n      while (true) {\n        parentPath = file.dirname(parentPath);\n        // This'll throw if the dir isn't empty.\n        file.rmdir(parentPath);\n      }\n    }\n    catch (err) {}\n  },\n\n  // Initializes the root by reading the backing file.\n  read: function JsonStore_read() {\n    try {\n      let str = file.read(this.filename);\n\n      // Ideally we'd log the parse error with console.error(), but logged\n      // errors cause tests to fail.  Supporting \"known\" errors in the test\n      // harness appears to be non-trivial.  Maybe later.\n      this.root = JSON.parse(str);\n    }\n    catch (err) {\n      this.root = {};\n    }\n  },\n\n  // If the store is under quota, writes the root to the backing file.\n  // Otherwise quota observers are notified and nothing is written.\n  write: function JsonStore_write() {\n    if (this.quotaUsage > 1) {\n      let arr = this._copyAndWrapObservers(this.onOverQuota);\n      this._notifyObserversArray(arr);\n    }\n    else\n      this._write();\n  },\n\n  // Cleans up on unload.  If unloading because of uninstall, the store is\n  // purged; otherwise it's written.\n  unload: function JsonStore_unload(reason) {\n    timer.clearInterval(this.writeTimer);\n\n    if (reason === \"uninstall\")\n      this.purge();\n    else\n      this._write();\n\n    // Clear the collections so they don't keep references to client callbacks.\n    this.onOverQuota = [];\n    this.onWrite = [];\n  },\n\n  // True if the root is an empty object.\n  get _isEmpty() {\n    if (this.root && typeof(this.root) === \"object\") {\n      let empty = true;\n      for (let key in this.root) {\n        empty = false;\n        break;\n      }\n      return empty;\n    }\n    return false;\n  },\n\n  // Returns the given observers collection as an array, with each function\n  // wrapped in a try-catch-log function.  This has the important side effect of\n  // allowing the collection to be subsequently freed.\n  _copyAndWrapObservers: function JsonStore__copyAndWrapObservers(observers) {\n    let arr = [];\n    for (let obs in observers)\n      arr.push(require(\"errors\").catchAndLog(obs));\n    return arr;\n  },\n\n  // Calls all observer functions in the given array.\n  _notifyObserversArray: function JsonStore__notifyObserversArray(obsArray) {\n    while (obsArray.length)\n      obsArray.shift().call(this.observersThisArg);\n  },\n\n  // Writes the root to the backing file, notifying write observers when\n  // complete.  If the store is over quota or if it's empty and the store has\n  // never been written, nothing is written and write observers aren't notified.\n  _write: function JsonStore__write() {\n    // If the store is empty and the file doesn't yet exist, don't write.\n    if (this._isEmpty && !file.exists(this.filename))\n      return;\n\n    // If the store is over quota, don't write.  The current under-quota state\n    // should persist.\n    if (this.quotaUsage > 1)\n      return;\n\n    // Before we leave this function, copy observers into an array, because\n    // they're removed on unload.\n    let obsArray = this._copyAndWrapObservers(this.onWrite);\n\n    // Finally, write.\n    const self = this;\n    let stream = file.open(this.filename, \"w\");\n    try {\n      stream.writeAsync(JSON.stringify(this.root), function writeAsync(err) {\n        if (err)\n          console.error(\"Error writing simple storage file: \" + self.filename);\n        else\n          self._notifyObserversArray(obsArray);\n      });\n    }\n    catch (err) {\n      // writeAsync closes the stream after it's done, so only close on error.\n      stream.close();\n    }\n  }\n};\n\n\n// This manages a JsonStore singleton and tailors its use to simple storage.\n// The root of the JsonStore is lazy-loaded:  The backing file is only read the\n// first time the root's gotten.\nlet manager = {\n\n  // The filename of the store, based on the profile dir and extension ID.\n  get filename() {\n    let storeFile = Cc[\"@mozilla.org/file/directory_service;1\"].\n                    getService(Ci.nsIProperties).\n                    get(\"ProfD\", Ci.nsIFile);\n    storeFile.append(\"jetpack\");\n    storeFile.append(jpSelf.id);\n    storeFile.append(\"simple-storage\");\n    file.mkpath(storeFile.path);\n    storeFile.append(\"store.json\");\n    return storeFile.path;\n  },\n\n  get quotaUsage() {\n    return this.jsonStore.quotaUsage;\n  },\n\n  get root() {\n    if (!this.rootInited) {\n      this.jsonStore.read();\n      this.rootInited = true;\n    }\n    return this.jsonStore.root;\n  },\n\n  set root(val) {\n    let rv = this.jsonStore.root = val;\n    this.rootInited = true;\n    return rv;\n  },\n\n  // Must be called before use.\n  init: function manager_init() {\n    let fname = this.filename;\n    this.jsonStore = new JsonStore({\n      filename: fname,\n      writePeriod: prefs.get(WRITE_PERIOD_PREF, WRITE_PERIOD_DEFAULT),\n      quota: prefs.get(QUOTA_PREF, QUOTA_DEFAULT),\n      onOverQuota: exports.onOverQuota,\n      observersThisArg: exports\n    });\n  }\n};\n\nmanager.init();\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "simple-storage"
        }
    }, 
    {
        "pk": 33, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst errors = require(\"errors\");\nconst windowUtils = require(\"window-utils\");\nconst apiUtils = require(\"api-utils\");\n\n// TODO: The hard-coding of app-specific info here isn't very nice;\n// ideally such app-specific info should be more decoupled, and the\n// module should be extensible, allowing for support of new apps at\n// runtime, perhaps by inspecting supported packages (e.g. via\n// dynamically-named modules or package-defined extension points).\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The tab-browser module currently supports only Firefox.  In the future \",\n    \"it will support other applications. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\n// Utility function to open a new browser window.\nfunction openBrowserWindow(callback, url) {\n  let wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"]\n           .getService(Ci.nsIWindowMediator);\n  let win = wm.getMostRecentWindow(\"navigator:browser\");\n  let window = win.openDialog(\"chrome://browser/content/browser.xul\",\n                              \"_blank\", \"chrome,all,dialog=no\", url); \n  if (callback) {\n    function onLoad(event) {\n      if (event.target && event.target.defaultView == window) {\n        window.removeEventListener(\"load\", onLoad, true);\n        try {\n          require(\"timer\").setTimeout(function () {\n            callback(event);\n          }, 10);\n        } catch (e) { console.exception(e); }\n      }\n    }\n\n    window.addEventListener(\"load\", onLoad, true);\n  }\n\n  return window;\n}\n\n// Open a URL in a new tab\nexports.addTab = function addTab(url, options) {\n  if (!options)\n    options = {};\n  options.url = url;\n\n  options = apiUtils.validateOptions(options, {\n    // TODO: take URL object instead of string (bug 564524)\n    url: {\n      is: [\"string\"],\n      ok: function (v) !!v,\n      msg: \"The url parameter must have be a non-empty string.\"\n    },\n    inNewWindow: {\n      is: [\"undefined\", \"null\", \"boolean\"]\n    },\n    // TODO: test this\n    openInBackground: {\n      is: [\"undefined\", \"null\", \"boolean\"]\n    },\n    onLoad: {\n      is: [\"undefined\", \"null\", \"function\"]\n    }\n  });\n\n  var wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"]\n           .getService(Ci.nsIWindowMediator);\n  var win = wm.getMostRecentWindow(\"navigator:browser\");\n  if (!win || options.inNewWindow) {\n    openBrowserWindow(function(e) {\n      require(\"errors\").catchAndLog(function(e) options.onLoad(e))(e);\n    }, options.url);\n  } else {\n    let tab = win.gBrowser.addTab(options.url);\n    if (!options.openInBackground)\n      win.gBrowser.selectedTab = tab;\n    if (options.onLoad) {\n      let tabBrowser = win.gBrowser.getBrowserForTab(tab);\n      tabBrowser.addEventListener(\"load\", function(e) {\n        // remove event handler from addTab - don't want notified\n        // for subsequent loads in same tab.\n        tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n        require(\"errors\").catchAndLog(function(e) options.onLoad(e))(e);\n      }, true);\n    }\n  }\n}\n\n// Iterate over a window's tabbrowsers\nfunction tabBrowserIterator(window) {\n  var browsers = window.document.querySelectorAll(\"tabbrowser\");\n  for (var i = 0; i < browsers.length; i++)\n    yield browsers[i];\n}\n\n// Iterate over a tabbrowser's tabs\nfunction tabIterator(tabbrowser) {\n  var tabs = tabbrowser.tabContainer;\n  for (var i = 0; i < tabs.children.length; i++) {\n    yield tabs.children[i];\n  }\n}\n\n// Tracker for all tabbrowsers across all windows\nfunction Tracker(delegate) {\n  this._delegate = delegate;\n  this._browsers = [];\n  this._windowTracker = new windowUtils.WindowTracker(this);\n\n  require(\"unload\").ensure(this);\n}\nTracker.prototype = {\n  __iterator__: function __iterator__() {\n    for (var i = 0; i < this._browsers.length; i++)\n      yield this._browsers[i];\n  },\n  get: function get(index) {\n    return this._browsers[index];\n  },\n  onTrack: function onTrack(window) {\n    for (browser in tabBrowserIterator(window))\n      this._browsers.push(browser);\n    if (this._delegate)\n      for (browser in tabBrowserIterator(window))\n        this._delegate.onTrack(browser);\n  },\n  onUntrack: function onUntrack(window) {\n    for (browser in tabBrowserIterator(window)) {\n      let index = this._browsers.indexOf(browser);\n      if (index != -1)\n        this._browsers.splice(index, 1);\n      else\n        console.error(\"internal error: browser tab not found\");\n    }\n    if (this._delegate)\n      for (browser in tabBrowserIterator(window))\n        this._delegate.onUntrack(browser);\n  },\n  get length() {\n    return this._browsers.length;\n  },\n  unload: function unload() {\n    this._windowTracker.unload();\n  }\n};\nexports.Tracker = apiUtils.publicConstructor(Tracker);\n\n// Tracker for all tabs across all windows\nfunction TabTracker(delegate) {\n  this._delegate = delegate;\n  this._tabs = [];\n  this._tracker = new Tracker(this);\n  require(\"unload\").ensure(this);\n}\nTabTracker.prototype = {\n  _TAB_EVENTS: [\"TabOpen\", \"TabClose\"],\n  _safeTrackTab: function safeTrackTab(tab) {\n    this._tabs.push(tab);\n    try {\n      this._delegate.onTrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeUntrackTab: function safeUntrackTab(tab) {\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    this._tabs.splice(index, 1);\n    try {\n      this._delegate.onUntrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  handleEvent: function handleEvent(event) {\n    switch (event.type) {\n    case \"TabOpen\":\n      this._safeTrackTab(event.target);\n      break;\n    case \"TabClose\":\n      this._safeUntrackTab(event.target);\n      break;\n    default:\n      throw new Error(\"internal error: unknown event type: \" +\n                      event.type);\n    }\n  },\n  onTrack: function onTrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeTrackTab(tab);\n    var self = this;\n    this._TAB_EVENTS.forEach(\n      function(eventName) {\n        tabbrowser.tabContainer.addEventListener(eventName, self, true);\n      });\n  },\n  onUntrack: function onUntrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeUntrackTab(tab);\n    var self = this;\n    this._TAB_EVENTS.forEach(\n      function(eventName) {\n        tabbrowser.tabContainer.removeEventListener(eventName, self, true);\n      });\n  },\n  unload: function unload() {\n    this._tracker.unload();\n  }\n};\nexports.TabTracker = apiUtils.publicConstructor(TabTracker);\n\nerrors.catchAndLogProps(TabTracker.prototype, [\"handleEvent\"]);\n\nexports.whenContentLoaded = function whenContentLoaded(callback) {\n  var cb = require(\"errors\").catchAndLog(function eventHandler(event) {\n    if (event.target && event.target.defaultView)\n      callback(event.target.defaultView);\n  });\n\n  var tracker = new Tracker({\n    onTrack: function(tabBrowser) {\n      tabBrowser.addEventListener(\"DOMContentLoaded\", cb, false);\n    },\n    onUntrack: function(tabBrowser) {\n      tabBrowser.removeEventListener(\"DOMContentLoaded\", cb, false);\n    }\n  });\n\n  return tracker;\n};\n\nexports.__defineGetter__(\"activeTab\", function() {\n  const wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"].\n             getService(Ci.nsIWindowMediator);\n  let mainWindow = wm.getMostRecentWindow(\"navigator:browser\");\n  return mainWindow.gBrowser.selectedTab;\n});\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "tab-browser"
        }
    }, 
    {
        "pk": 13, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Dietrich Ayala <dietrich@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The tabs module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\n\n\nconst {Cc,Ci,Cu} = require(\"chrome\");\nvar NetUtil = {};\nCu.import(\"resource://gre/modules/NetUtil.jsm\", NetUtil);\nNetUtil = NetUtil.NetUtil;\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\nconst collection = require(\"collection\");\nconst tabBrowser = require(\"tab-browser\");\n\n// Supported tab events\nconst events = [\n  \"onActivate\",\n  \"onDeactivate\",\n  \"onOpen\",\n  \"onClose\",\n  \"onReady\",\n  \"onLoad\",\n  \"onPaint\"\n];\n\n/**\n * Tab\n *\n * Safe object representing a tab.\n */\nlet tabConstructor = apiUtils.publicConstructor(function(element) {\n  if (!element)\n    throw new Error(\"no tab element.\");\n  let win = element.ownerDocument.defaultView;\n  if (!win)\n    throw new Error(\"element has no window.\");\n  let browser = win.gBrowser.getBrowserForTab(element);\n\n  this.__defineGetter__(\"title\", function() browser.contentDocument.title);\n  this.__defineGetter__(\"location\", function() browser.contentDocument.location);\n  this.__defineSetter__(\"location\", function(val) browser.contentDocument.location = val);\n  this.__defineGetter__(\"contentWindow\", function() browser.contentWindow);\n  this.__defineGetter__(\"contentDocument\", function() browser.contentDocument);\n  this.__defineGetter__(\"favicon\", function() {\n    let pageURI = NetUtil.newURI(browser.contentDocument.location);\n    let fs = Cc[\"@mozilla.org/browser/favicon-service;1\"].\n             getService(Ci.nsIFaviconService);\n    let faviconURL;\n    try {\n      let faviconURI = fs.getFaviconForPage(pageURI);\n      faviconURL = fs.getFaviconDataAsDataURL(faviconURI);\n    } catch(ex) {\n      let data = getChromeURLContents(\"chrome://mozapps/skin/places/defaultFavicon.png\");\n      let encoded = exports.activeTab.contentWindow.btoa(data);\n      faviconURL = \"data:image/png;base64,\" + encoded;\n    }\n    return faviconURL;\n  });\n  this.__defineGetter__(\"style\", function() null); // TODO\n  this.__defineGetter__(\"index\", function() win.gBrowser.getBrowserIndexForDocument(browser.contentDocument));\n  this.__defineGetter__(\"thumbnail\", function() getThumbnailCanvasForTab(element, browser.contentWindow));\n\n  this.close = function() win.gBrowser.removeTab(element);\n  this.move = function(index) {\n    win.gBrowser.moveTabTo(element, index);\n  };\n\n  // Set up the event handlers\n  let tab = this;\n  events.filter(function(e) e != \"onOpen\").forEach(function(e) {\n    // create a collection for each event\n    collection.addCollectionProperty(tab, e);\n    // make tabs setter for each event, for adding via property assignment\n    tab.__defineSetter__(e, function(val) tab[e].add(val));\n  });\n\n  // listen for events, filtered on this tab\n  eventsTabDelegate.addTabDelegate(this);\n});\n\n// Utility to get a thumbnail canvas from a tab object\nfunction getThumbnailCanvasForTab(tabEl, window) {\n  var thumbnail = window.document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n  thumbnail.mozOpaque = true;\n  var window = tabEl.linkedBrowser.contentWindow;\n  thumbnail.width = Math.ceil(window.screen.availWidth / 5.75);\n  var aspectRatio = 0.5625; // 16:9\n  thumbnail.height = Math.round(thumbnail.width * aspectRatio);\n  var ctx = thumbnail.getContext(\"2d\");\n  var snippetWidth = window.innerWidth * .6;\n  var scale = thumbnail.width / snippetWidth;\n  ctx.scale(scale, scale);\n  ctx.drawWindow(window, window.scrollX, window.scrollY, snippetWidth, snippetWidth * aspectRatio, \"rgb(255,255,255)\");\n  return thumbnail;\n}\n\n// Utility to return the contents of the target of a chrome URL\nfunction getChromeURLContents(chromeURL) {\n  let io = Cc[\"@mozilla.org/network/io-service;1\"].\n           getService(Ci.nsIIOService);\n  let channel = io.newChannel(chromeURL, null, null);\n  let input = channel.open();\n  let stream = Cc[\"@mozilla.org/binaryinputstream;1\"].\n               createInstance(Ci.nsIBinaryInputStream); \n  stream.setInputStream(input);\n  let str = stream.readBytes(input.available());\n  stream.close();\n  input.close();\n  return str;\n}\n\n/**\n * tabs.activeTab\n */\nexports.__defineGetter__(\"activeTab\", function() {\n  return tabConstructor(tabBrowser.activeTab);\n});\nexports.__defineSetter__(\"activeTab\", function(tab) {\n  // iterate over open windows\n  let windowIterator = require(\"window-utils\").windowIterator;\n  for (let win in windowIterator()) {\n    if (win.gBrowser) {\n      // find the tab element at tab.index\n      let index = win.gBrowser.getBrowserIndexForDocument(tab.contentDocument);\n      if (index > -1) {\n        // set as active tab\n        let tabElement = win.gBrowser.tabContainer.getItemAtIndex(index);\n        win.gBrowser.selectedTab = tabElement;\n        // focus the window\n        win.focus();\n        break;\n      }\n    }\n  }\n});\n\n/**\n * tabs.open - open a URL in a new tab\n */\nfunction open(options) {\n  if (typeof options === \"string\")\n    options = { url: options };\n\n  options = apiUtils.validateOptions(options, {\n    url: {\n      is: [\"string\"]\n    },\n    inNewWindow: {\n      is: [\"undefined\", \"boolean\"]\n    },\n    inBackground: {\n      is: [\"undefined\", \"boolean\"]\n    },\n    onOpen: {\n      is: [\"undefined\", \"function\"]\n    }\n  });\n\n  // TODO: remove me. maybe implement window-utils.activeWindow?\n  const wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"].\n             getService(Ci.nsIWindowMediator);\n  let win = wm.getMostRecentWindow(\"navigator:browser\");\n\n  if (!win || options.inNewWindow)\n    openURLInNewWindow(options);\n  else\n    openURLInNewTab(options, win);\n}\nexports.open = open;\n\nfunction openURLInNewWindow(options) {\n  let addTabOptions = {\n    inNewWindow: true\n  };\n  if (options.onOpen) {\n    addTabOptions.onLoad = function(e) {\n      let win = e.target.defaultView;\n      let tabEl = win.gBrowser.tabContainer.childNodes[0];\n      let tabBrowser = win.gBrowser.getBrowserForTab(tabEl);\n      tabBrowser.addEventListener(\"load\", function(e) {\n        tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n        let tab = tabConstructor(tabEl);\n        require(\"errors\").catchAndLog(function(e) options.onOpen(e))(tab);\n      }, true);\n    };\n  }\n  tabBrowser.addTab(options.url.toString(), addTabOptions);\n}\n\nfunction openURLInNewTab(options, window) {\n  window.focus();\n  let tabEl = window.gBrowser.addTab(options.url.toString());\n  if (!options.inBackground)\n    window.gBrowser.selectedTab = tabEl;\n  if (options.onOpen) {\n    let tabBrowser = window.gBrowser.getBrowserForTab(tabEl);\n    tabBrowser.addEventListener(\"load\", function(e) {\n      // remove event handler from addTab - don't want to be notified\n      // for subsequent loads in same tab.\n      tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n      let tab = tabConstructor(tabEl);\n      require(\"timer\").setTimeout(function() {\n        require(\"errors\").catchAndLog(function(tab) options.onOpen(tab))(tab);\n      }, 10);\n    }, true);\n  }\n}\n\n// Set up the event handlers\nevents.forEach(function(eventHandler) {\n  // create a collection for each event\n  collection.addCollectionProperty(exports, eventHandler);\n  // make tabs setter for each event, for adding via property assignment\n  exports.__defineSetter__(eventHandler, function(val) exports[eventHandler].add(val));\n});\n\n// Helper to iterate over a tabbrowser's tabs\nfunction tabIterator(tabbrowser) {\n  var tabs = tabbrowser.tabContainer;\n  for (var i = 0; i < tabs.children.length; i++) {\n    yield tabs.children[i];\n  }\n}\n\n// Tracker for all tabs across all windows\n// This is tab-browser.TabTracker, but with\n// support for additional events added.\nfunction TabTracker(delegate) {\n  this._delegate = delegate;\n  this._tabs = [];\n  this._tracker = new tabBrowser.Tracker(this);\n  require(\"unload\").ensure(this);\n}\nTabTracker.prototype = {\n  _TAB_EVENTS: [\"TabOpen\", \"TabClose\", \"TabSelect\", \"DOMContentLoaded\",\n                \"load\", \"MozAfterPaint\"],\n  _safeTrackTab: function safeTrackTab(tab) {\n    tab.addEventListener(\"load\", this, false);\n    tab.linkedBrowser.addEventListener(\"MozAfterPaint\", this, false);\n    this._tabs.push(tab);\n    try {\n      this._delegate.onTrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeUntrackTab: function safeUntrackTab(tab) {\n    tab.removeEventListener(\"load\", this, false);\n    tab.linkedBrowser.removeEventListener(\"MozAfterPaint\", this, false);\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      throw new Error(\"internal error: tab not found\");\n    this._tabs.splice(index, 1);\n    try {\n      this._delegate.onUntrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeSelectTab: function safeSelectTab(tab) {\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onSelect)\n        this._delegate.onSelect(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeDOMContentLoaded: function safeDOMContentLoaded(event) {\n    let tabBrowser = event.currentTarget;\n    let tabBrowserIndex = tabBrowser.getBrowserIndexForDocument(event.target);\n    // TODO: I'm seeing this when loading data url images\n    if (tabBrowserIndex == -1)\n      return;\n    let tab = tabBrowser.tabContainer.getItemAtIndex(tabBrowserIndex);\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onReady)\n        this._delegate.onReady(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeLoad: function safeLoad(event) {\n    let tab = event.target;\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onLoad)\n        this._delegate.onLoad(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeMozAfterPaint: function safeMozAfterPaint(event) {\n    let win = event.currentTarget.ownerDocument.defaultView;\n    let tabIndex = win.gBrowser.getBrowserIndexForDocument(event.target.document);\n    if (tabIndex == -1)\n      return;\n    let tab = win.gBrowser.tabContainer.getItemAtIndex(tabIndex);\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onPaint)\n        this._delegate.onPaint(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  handleEvent: function handleEvent(event) {\n    switch (event.type) {\n    case \"TabOpen\":\n      this._safeTrackTab(event.target);\n      break;\n    case \"TabClose\":\n      this._safeUntrackTab(event.target);\n      break;\n    case \"TabSelect\":\n      this._safeSelectTab(event.target);\n      break;\n    case \"DOMContentLoaded\":\n      this._safeDOMContentLoaded(event);\n      break;\n    case \"load\":\n      this._safeLoad(event);\n      break;\n    case \"MozAfterPaint\":\n      this._safeMozAfterPaint(event);\n      break;\n    default:\n      throw new Error(\"internal error: unknown event type: \" +\n                      event.type);\n    }\n  },\n  onTrack: function onTrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeTrackTab(tab);\n    tabbrowser.tabContainer.addEventListener(\"TabOpen\", this, false);\n    tabbrowser.tabContainer.addEventListener(\"TabClose\", this, false);\n    tabbrowser.tabContainer.addEventListener(\"TabSelect\", this, false);\n    tabbrowser.ownerDocument.defaultView.gBrowser.addEventListener(\"DOMContentLoaded\", this, false);\n  },\n  onUntrack: function onUntrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeUntrackTab(tab);\n    tabbrowser.tabContainer.removeEventListener(\"TabOpen\", this, false);\n    tabbrowser.tabContainer.removeEventListener(\"TabClose\", this, false);\n    tabbrowser.tabContainer.removeEventListener(\"TabSelect\", this, false);\n    tabbrowser.ownerDocument.defaultView.gBrowser.removeEventListener(\"DOMContentLoaded\", this, false);\n  },\n  unload: function unload() {\n    this._tracker.unload();\n  }\n};\n\n// Tracker that listens for tab events, and proxies\n// them to registered event listeners.\nlet eventsTabDelegate = {\n  selectedTab: null,\n  tabs: [],\n  addTabDelegate: function TETT_addTabDelegate(tabObj) {\n    this.tabs.push(tabObj);\n  },\n  getElementForTab: function(tabObj) {\n    // iterate over open windows\n    let windowIterator = require(\"window-utils\").windowIterator;\n    for (let win in windowIterator()) {\n      if (win.gBrowser) {\n        // find the tab element at tab.index\n        let index = win.gBrowser.getBrowserIndexForDocument(tabObj.contentDocument);\n        if (index > -1)\n          return win.gBrowser.tabContainer.getItemAtIndex(index);\n      }\n    }\n    return null;\n  },\n  pushTabEvent: function TETT_pushTabEvent(event, tab) {\n    for (let callback in exports[event]) {\n      require(\"errors\").catchAndLog(function(tab) {\n        callback(new tabConstructor(tab));\n      })(tab);\n    }\n\n    if (event != \"onOpen\") {\n      this.tabs.forEach(function(tabObj) {\n        if (tabObj[event].length) {\n          let tabEl = this.getElementForTab(tabObj);\n          if (tabEl == tab) {\n            for (let callback in tabObj[event])\n              require(\"errors\").catchAndLog(function() callback())();\n          }\n        }\n        // if being closed, remove the tab object from the cache\n        // of tabs to notify about events.\n        if (event == \"onClose\")\n          this.tabs.splice(this.tabs.indexOf(tabObj), 1);\n      }, this);\n    }\n  },\n  unload: function() {\n    this.selectTab = null;\n    this.tabs.splice(0);\n  }\n};\nrequire(\"unload\").ensure(eventsTabDelegate);\n\nlet eventsTabTracker = new TabTracker({\n  onTrack: function TETT_onTrack(tab) {\n    eventsTabDelegate.pushTabEvent(\"onOpen\", tab);\n  },\n  onUntrack: function TETT_onUntrack(tab) {\n    eventsTabDelegate.pushTabEvent(\"onClose\", tab);\n  },\n  onSelect: function TETT_onSelect(tab) {\n    if (eventsTabDelegate.selectedTab)\n      eventsTabDelegate.pushTabEvent(\"onDeactivate\", tab);\n\n    eventsTabDelegate.selectedTab = new tabConstructor(tab);\n\n    eventsTabDelegate.pushTabEvent(\"onActivate\", tab);\n  },\n  onReady: function TETT_onReady(tab) {\n    eventsTabDelegate.pushTabEvent(\"onReady\", tab);\n  },\n  onLoad: function TETT_onLoad(tab) {\n    eventsTabDelegate.pushTabEvent(\"onLoad\", tab);\n  },\n  onPaint: function TETT_onPaint(tab) {\n    eventsTabDelegate.pushTabEvent(\"onPaint\", tab);\n  }\n});\nrequire(\"unload\").ensure(eventsTabTracker);\n\n// Iterator for all tabs\nexports.__iterator__ = function tabsIterator() {\n  for (let i = 0; i < eventsTabTracker._tabs.length; i++)\n    yield tabConstructor(eventsTabTracker._tabs[i]);\n}\n\n// Cleanup when unloaded\nfunction unload() {\n  // Unregister tabs event listeners\n  events.forEach(function(e) exports[e] = []);\n}\nrequire(\"unload\").ensure(this);\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "tabs"
        }
    }, 
    {
        "pk": 1, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cu,components} = require(\"chrome\");\nvar NetUtil = {};\nCu.import(\"resource://gre/modules/NetUtil.jsm\", NetUtil);\nNetUtil = NetUtil.NetUtil;\n\n// NetUtil.asyncCopy() uses this buffer length, and since we call it, for best\n// performance we use it, too.\nconst BUFFER_BYTE_LEN = 0x8000;\nconst PR_UINT32_MAX = 0xffffffff;\nconst DEFAULT_CHARSET = \"UTF-8\";\n\nexports.TextReader = TextReader;\nexports.TextWriter = TextWriter;\n\n/**\n * An input stream that reads text from a backing stream using a given text\n * encoding.\n *\n * @param inputStream\n *        The stream is backed by this nsIInputStream.  It must already be\n *        opened.\n * @param charset\n *        Text in inputStream is expected to be in this character encoding.  If\n *        not given, \"UTF-8\" is assumed.  See nsICharsetConverterManager.idl for\n *        documentation on how to determine other valid values for this.\n */\nfunction TextReader(inputStream, charset) {\n  const self = this;\n  charset = checkCharset(charset);\n\n  let stream = Cc[\"@mozilla.org/intl/converter-input-stream;1\"].\n               createInstance(Ci.nsIConverterInputStream);\n  stream.init(inputStream, charset, BUFFER_BYTE_LEN,\n              Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n  let manager = new StreamManager(this, stream);\n\n  /**\n   * Reads a string from the stream.  If the stream is closed, an exception is\n   * thrown.\n   *\n   * @param  numChars\n   *         The number of characters to read.  If not given, the remainder of\n   *         the stream is read.\n   * @return The string read.  If the stream is already at EOS, returns the\n   *         empty string.\n   */\n  this.read = function TextReader_read(numChars) {\n    manager.ensureOpened();\n\n    let readAll = false;\n    if (typeof(numChars) === \"number\")\n      numChars = Math.max(numChars, 0);\n    else\n      readAll = true;\n\n    let str = \"\";\n    let totalRead = 0;\n    let chunkRead = 1;\n\n    // Read in numChars or until EOS, whichever comes first.  Note that the\n    // units here are characters, not bytes.\n    while (true) {\n      let chunk = {};\n      let toRead = readAll ?\n                   PR_UINT32_MAX :\n                   Math.min(numChars - totalRead, PR_UINT32_MAX);\n      if (toRead <= 0 || chunkRead <= 0)\n        break;\n\n      // The converter stream reads in at most BUFFER_BYTE_LEN bytes in a call\n      // to readString, enough to fill its byte buffer.  chunkRead will be the\n      // number of characters encoded by the bytes in that buffer.\n      chunkRead = stream.readString(toRead, chunk);\n      str += chunk.value;\n      totalRead += chunkRead;\n    }\n\n    return str;\n  };\n}\n\n/**\n * A buffered output stream that writes text to a backing stream using a given\n * text encoding.\n *\n * @param outputStream\n *        The stream is backed by this nsIOutputStream.  It must already be\n *        opened.\n * @param charset\n *        Text will be written to outputStream using this character encoding.\n *        If not given, \"UTF-8\" is assumed.  See nsICharsetConverterManager.idl\n *        for documentation on how to determine other valid values for this.\n */\nfunction TextWriter(outputStream, charset) {\n  const self = this;\n  charset = checkCharset(charset);\n\n  let stream = outputStream;\n\n  // Buffer outputStream if it's not already.\n  let ioUtils = Cc[\"@mozilla.org/io-util;1\"].getService(Ci.nsIIOUtil);\n  if (!ioUtils.outputStreamIsBuffered(outputStream)) {\n    stream = Cc[\"@mozilla.org/network/buffered-output-stream;1\"].\n             createInstance(Ci.nsIBufferedOutputStream);\n    stream.init(outputStream, BUFFER_BYTE_LEN);\n  }\n\n  // I'd like to use nsIConverterOutputStream.  But NetUtil.asyncCopy(), which\n  // we use below in writeAsync(), naturally expects its sink to be an instance\n  // of nsIOutputStream, which nsIConverterOutputStream's only implementation is\n  // not.  So we use uconv and manually convert all strings before writing to\n  // outputStream.\n  let uconv = Cc[\"@mozilla.org/intl/scriptableunicodeconverter\"].\n              createInstance(Ci.nsIScriptableUnicodeConverter);\n  uconv.charset = charset;\n\n  let manager = new StreamManager(this, stream);\n\n  /**\n   * Flushes the backing stream's buffer.\n   */\n  this.flush = function TextWriter_flush() {\n    manager.ensureOpened();\n    stream.flush();\n  };\n\n  /**\n   * Writes a string to the stream.  If the stream is closed, an exception is\n   * thrown.\n   *\n   * @param str\n   *        The string to write.\n   */\n  this.write = function TextWriter_write(str) {\n    manager.ensureOpened();\n    let istream = uconv.convertToInputStream(str);\n    let len = istream.available();\n    while (len > 0) {\n      stream.writeFrom(istream, len);\n      len = istream.available();\n    }\n    istream.close();\n  };\n\n  /**\n   * Writes a string on a background thread.  After the write completes, the\n   * backing stream's buffer is flushed, and both the stream and the backing\n   * stream are closed, also on the background thread.  If the stream is already\n   * closed, an exception is thrown immediately.\n   *\n   * @param str\n   *        The string to write.\n   * @param callback\n   *        An optional function.  If given, it's called as callback(error) when\n   *        the write completes.  error is an Error object or undefined if there\n   *        was no error.  Inside callback, |this| is the stream object.\n   */\n  this.writeAsync = function TextWriter_writeAsync(str, callback) {\n    manager.ensureOpened();\n    let istream = uconv.convertToInputStream(str);\n    NetUtil.asyncCopy(istream, stream, function (result) {\n        let err = components.isSuccessCode(result) ? undefined :\n        new Error(\"An error occured while writing to the stream: \" + result);\n      if (err)\n        console.error(err);\n\n      // asyncCopy() closes its output (and input) stream.\n      manager.opened = false;\n\n      if (typeof(callback) === \"function\") {\n        try {\n          callback.call(self, err);\n        }\n        catch (exc) {\n          console.exception(exc);\n        }\n      }\n    });\n  };\n}\n\n// This manages the lifetime of stream, a TextReader or TextWriter.  It defines\n// closed and close() on stream and registers an unload listener that closes\n// rawStream if it's still opened.  It also provides ensureOpened(), which\n// throws an exception if the stream is closed.\nfunction StreamManager(stream, rawStream) {\n  const self = this;\n  this.rawStream = rawStream;\n  this.opened = true;\n\n  /**\n   * True iff the stream is closed.\n   */\n  stream.__defineGetter__(\"closed\", function stream_closed() {\n    return !self.opened;\n  });\n\n  /**\n   * Closes both the stream and its backing stream.  If the stream is already\n   * closed, an exception is thrown.  For TextWriters, this first flushes the\n   * backing stream's buffer.\n   */\n  stream.close = function stream_close() {\n    self.ensureOpened();\n    self.unload();\n  };\n\n  require(\"unload\").ensure(this);\n}\n\nStreamManager.prototype = {\n  ensureOpened: function StreamManager_ensureOpened() {\n    if (!this.opened)\n      throw new Error(\"The stream is closed and cannot be used.\");\n  },\n  unload: function StreamManager_unload() {\n    // TextWriter.writeAsync() causes rawStream to close and therefore sets\n    // opened to false, so check that we're still opened.\n    if (this.opened) {\n      // Calling close() on both an nsIUnicharInputStream and\n      // nsIBufferedOutputStream closes their backing streams.  It also forces\n      // nsIOutputStreams to flush first.\n      this.rawStream.close();\n      this.opened = false;\n    }\n  }\n};\n\nfunction checkCharset(charset) {\n  return typeof(charset) === \"string\" ? charset : DEFAULT_CHARSET;\n}\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "text-streams"
        }
    }, 
    {
        "pk": 8, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nvar xpcom = require(\"xpcom\");\n\nvar timerClass = Cc[\"@mozilla.org/timer;1\"];\nvar nextID = 1;\nvar timers = {};\n\nfunction TimerCallback(callback, timerID, repeating) {\n  memory.track(this);\n  this._callback = callback;\n  this._timerID = timerID;\n  this._repeating = repeating;\n  this.QueryInterface = xpcom.utils.generateQI([Ci.nsITimerCallback]);\n};\n\nTimerCallback.prototype = {\n  notify : function notify(timer) {\n    try {\n      if (!this._repeating)\n        delete timers[this._timerID];\n      this._callback.apply(null, []);\n    } catch (e) {\n      console.exception(e);\n    }\n  }\n};\n\nvar setTimeout = exports.setTimeout = function setTimeout(callback, delay) {\n  return makeTimer(callback, delay, false);\n};\n\nvar clearTimeout = exports.clearTimeout = function clearTimeout(timerID) {\n  cancelTimer(timerID);\n};\n\nvar setInterval = exports.setInterval = function setInterval(callback, delay) {\n  return makeTimer(callback, delay, true);\n};\n\nvar clearInterval = exports.clearInterval = function clearInterval(timerID) {\n  cancelTimer(timerID);\n};\n\nfunction makeTimer(callback, delay, repeating) {\n  var timer = timerClass.createInstance(Ci.nsITimer);\n\n  memory.track(timer, \"nsITimer\");\n\n  var timerID = nextID++;\n  timers[timerID] = timer;\n\n  timer.initWithCallback(new TimerCallback(callback, timerID, repeating),\n                         delay,\n                         repeating ? timer.TYPE_REPEATING_SLACK :\n                                     timer.TYPE_ONE_SHOT);\n  return timerID;\n}\n\nfunction cancelTimer(timerID) {\n  var timer = timers[timerID];\n  if (timer) {\n    timer.cancel();\n    delete timers[timerID];\n  }\n}\n\nrequire(\"unload\").when(\n  function cancelAllPendingTimers() {\n    var timerIDs = [timerID for (timerID in timers)];\n    timerIDs.forEach(function(timerID) { cancelTimer(timerID); });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "timer"
        }
    }, 
    {
        "pk": 11, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,components} = require(\"chrome\");\n\n// Undo the auto-parentification of URLs done in bug 418356.\nfunction deParentifyURL(url) {\n  return url ? url.split(\" -> \").slice(-1)[0] : url;\n}\n\n// TODO: We might want to move this function to url or some similar\n// module.\nfunction getLocalFile(path) {\n  var ios = Cc['@mozilla.org/network/io-service;1']\n            .getService(Ci.nsIIOService);\n  var channel = ios.newChannel(path, null, null);\n  var iStream = channel.open();\n  var siStream = Cc['@mozilla.org/scriptableinputstream;1']\n                 .createInstance(Ci.nsIScriptableInputStream);\n  siStream.init(iStream);\n  var data = new String();\n  data += siStream.read(-1);\n  siStream.close();\n  iStream.close();\n  return data;\n}\n\nfunction safeGetFileLine(path, line) {\n  try {\n    var scheme = require(\"url\").URL(path).scheme;\n    // TODO: There should be an easier, more accurate way to figure out\n    // what's the case here.\n    if (!(scheme == \"http\" || scheme == \"https\"))\n      return getLocalFile(path).split(\"\\n\")[line - 1];\n  } catch (e) {}\n  return null;\n}\n\nfunction errorStackToJSON(stack) {\n  var lines = stack.split(\"\\n\");\n\n  var frames = [];\n  lines.forEach(\n    function(line) {\n      if (!line)\n        return;\n      var atIndex = line.indexOf(\"@\");\n      var colonIndex = line.lastIndexOf(\":\");\n      var filename = deParentifyURL(line.slice(atIndex + 1, colonIndex));\n      var lineNo = parseInt(line.slice(colonIndex + 1));\n      var funcSig = line.slice(0, atIndex);\n      var funcName = funcSig.slice(0, funcSig.indexOf(\"(\"));\n      frames.unshift({filename: filename,\n                      funcName: funcName,\n                      lineNo: lineNo});\n    });\n\n  return frames;\n};\n\nfunction nsIStackFramesToJSON(frame) {\n  var stack = [];\n\n  while (frame) {\n    var filename = deParentifyURL(frame.filename);\n    stack.splice(0, 0, {filename: filename,\n                        lineNo: frame.lineNumber,\n                        funcName: frame.name});\n    frame = frame.caller;\n  }\n\n  return stack;\n};\n\nvar fromException = exports.fromException = function fromException(e) {\n  if (e instanceof Ci.nsIException)\n    return nsIStackFramesToJSON(e.location);\n  if (e.stack && e.stack.length)\n    return errorStackToJSON(e.stack);\n  if (e.fileName && typeof(e.lineNumber == \"number\"))\n    return [{filename: deParentifyURL(e.fileName),\n             lineNo: e.lineNumber,\n             funcName: null}];\n  return [];\n};\n\nvar get = exports.get = function get() {\n  return nsIStackFramesToJSON(components.stack.caller);\n};\n\nvar format = exports.format = function format(tbOrException) {\n  if (tbOrException === undefined) {\n    tbOrException = get();\n    tbOrException.splice(-1, 1);\n  }\n\n  var tb;\n  if (typeof(tbOrException) == \"object\" &&\n      tbOrException.constructor.name == \"Array\")\n    tb = tbOrException;\n  else\n    tb = fromException(tbOrException);\n\n  var lines = [\"Traceback (most recent call last):\"];\n\n  tb.forEach(\n    function(frame) {\n      if (!(frame.filename || frame.lineNo || frame.funcName))\n\treturn;\n      lines.push('  File \"' + frame.filename + '\", line ' +\n                 frame.lineNo + ', in ' + frame.funcName);\n      var sourceLine = safeGetFileLine(frame.filename, frame.lineNo);\n      if (sourceLine)\n        lines.push('    ' + sourceLine.trim());\n    });\n\n  return lines.join(\"\\n\");\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "traceback"
        }
    }, 
    {
        "pk": 9, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nvar timer = require(\"timer\");\nvar file = require(\"file\");\n\nexports.findAndRunTests = function findAndRunTests(options) {\n  var finder = new TestFinder(options.dirs, options.filter);\n  var runner = new TestRunner();\n  runner.startMany({tests: finder.findTests(),\n                    onDone: options.onDone});\n};\n\nvar TestFinder = exports.TestFinder = function TestFinder(dirs, filter) {\n  memory.track(this);\n  this.dirs = dirs;\n  this.filter = filter;\n};\n\nTestFinder.prototype = {\n  _makeTest: function _makeTest(suite, name, test) {\n    function runTest(runner) {\n      console.info(\"executing '\" + suite + \".\" + name + \"'\");\n      test(runner);\n    }\n    return runTest;\n  },\n\n  findTests: function findTests() {\n    var self = this;\n    var tests = [];\n    var filterRegex = this.filter ? new RegExp(this.filter) : null;\n\n    this.dirs.forEach(\n      function(dir) {\n        var suites = [name.slice(0, -3)\n                      for each (name in file.list(dir))\n                      if (/^test-.*\\.js$/.test(name) &&\n                          (!filterRegex || filterRegex.test(name)))];\n\n        suites.forEach(\n          function(suite) {\n            var module = require(suite);\n            for (name in module)\n                tests.push({\n                  testFunction: self._makeTest(suite, name, module[name]),\n                  name: suite + \".\" + name\n                });\n          });\n      });\n    return tests;\n  }\n};\n\nfunction FakeModuleFs(modules) {\n  this.resolveModule = function resolveModule(base, path) {\n      if (path in modules)\n        return path;\n      return null;\n  };\n\n  this.getFile = function getFile(path) {\n    throw new Error(\"FakeModuleFs.getFile() should never be called on '\" +\n                    path + \"'\");\n  };\n}\n\nvar TestRunner = exports.TestRunner = function TestRunner(options) {\n  memory.track(this);\n  this.passed = 0;\n  this.failed = 0;\n  this.testRunSummary = [];\n};\n\nTestRunner.prototype = {\n  DEFAULT_PAUSE_TIMEOUT: 10000,\n\n  _logTestFailed: function _logTestFailed(why) {\n    this.test.errors[why]++;\n    if (!this.testFailureLogged) {\n      console.error(\"TEST FAILED: \" + this.test.name + \" (\" + why + \")\");\n      this.testFailureLogged = true;\n    }\n  },\n\n  makeSandboxedLoader: function makeSandboxedLoader(options) {\n    if (!options)\n      options = {console: console};\n\n    var Cuddlefish = require(\"cuddlefish\");\n\n    if (\"moduleOverrides\" in options) {\n      var securableModule = require(\"securable-module\");\n      var fses = [new FakeModuleFs(options.moduleOverrides),\n                  Cuddlefish.parentLoader.fs];\n      options.fs = new securableModule.CompositeFileSystem(fses);\n      options.modules = options.moduleOverrides;\n      delete options.moduleOverrides;\n    } else\n      options.fs = Cuddlefish.parentLoader.fs;\n\n    return new Cuddlefish.Loader(options);\n  },\n\n  pass: function pass(message) {\n    console.info(\"pass:\", message);\n    this.passed++;\n    this.test.passed++;\n  },\n\n  fail: function fail(message) {\n    this._logTestFailed(\"failure\");\n    console.error(\"fail:\", message);\n    console.trace();\n    this.failed++;\n    this.test.failed++;\n  },\n\n  exception: function exception(e) {\n    this._logTestFailed(\"exception\");\n    console.exception(e);\n    this.failed++;\n    this.test.failed++;\n  },\n\n  assertMatches: function assertMatches(string, regexp, message) {\n    if (regexp.test(string)) {\n      if (!message)\n        message = uneval(string) + \" matches \" + uneval(regexp);\n      this.pass(message);\n    } else {\n      var no = uneval(string) + \" doesn't match \" + uneval(regexp);\n      if (!message)\n        message = no;\n      else\n        message = message + \" (\" + no + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertRaises: function assertRaises(func, predicate, message) {\n    try {\n      func();\n      if (message)\n        this.fail(message + \" (no exception thrown)\");\n      else\n        this.fail(\"function failed to throw exception\");\n    } catch (e) {\n      var errorMessage;\n      if (typeof(e) == \"string\")\n        errorMessage = e;\n      else\n        errorMessage = e.message;\n      if (typeof(predicate) == \"object\")\n        this.assertMatches(errorMessage, predicate, message);\n      else\n        this.assertEqual(errorMessage, predicate, message);\n    }\n  },\n\n  assert: function assert(a, message) {\n    if (!a) {\n      if (!message)\n        message = \"assertion failed, value is \" + a;\n      this.fail(message);\n    } else\n      this.pass(message || \"assertion successful\");\n  },\n\n  assertNotEqual: function assertNotEqual(a, b, message) {\n    if (a != b) {\n      if (!message)\n        message = \"a != b != \" + uneval(a);\n      this.pass(message);\n    } else {\n      var equality = uneval(a) + \" == \" + uneval(b);\n      if (!message)\n        message = equality;\n      else\n        message += \" (\" + equality + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertEqual: function assertEqual(a, b, message) {\n    if (a == b) {\n      if (!message)\n        message = \"a == b == \" + uneval(a);\n      this.pass(message);\n    } else {\n      var inequality = uneval(a) + \" != \" + uneval(b);\n      if (!message)\n        message = inequality;\n      else\n        message += \" (\" + inequality + \")\";\n      this.fail(message);\n    }\n  },\n\n  done: function done() {\n    if (!this.isDone) {\n      this.isDone = true;\n      if (this.waitTimeout !== null) {\n        timer.clearTimeout(this.waitTimeout);\n        this.waitTimeout = null;\n      }\n      if (this.test.passed == 0 && this.test.failed == 0) {\n        this._logTestFailed(\"empty test\");\n        this.failed++;\n        this.test.failed++;\n      }\n      \n      this.testRunSummary.push({\n        name: this.test.name,\n        passed: this.test.passed,\n        failed: this.test.failed,\n        errors: [error for (error in this.test.errors)].join(\", \")\n      });\n      \n      if (this.onDone !== null) {\n        var onDone = this.onDone;\n        var self = this;\n        this.onDone = null;\n        timer.setTimeout(function() { onDone(self); }, 0);\n      }\n    }\n  },\n\n  waitUntilDone: function waitUntilDone(ms) {\n    if (ms === undefined)\n      ms = this.DEFAULT_PAUSE_TIMEOUT;\n\n    var self = this;\n\n    function tiredOfWaiting() {\n      self._logTestFailed(\"timed out\");\n      self.failed++;\n      self.test.failed++;\n      self.done();\n    }\n\n    this.waitTimeout = timer.setTimeout(tiredOfWaiting, ms);\n  },\n\n  startMany: function startMany(options) {\n    function runNextTest(self) {\n      var test = options.tests.shift();\n      if (test)\n        self.start({test: test, onDone: runNextTest});\n      else\n        options.onDone(self);\n    }\n    runNextTest(this);\n  },\n\n  start: function start(options) {\n    this.test = options.test;\n    this.test.passed = 0;\n    this.test.failed = 0;\n    this.test.errors = {};\n\n    this.isDone = false;\n    this.onDone = options.onDone;\n    this.waitTimeout = null;\n\n    try {\n      this.test.testFunction(this);\n    } catch (e) {\n      this.exception(e);\n    }\n    if (this.waitTimeout === null)\n      this.done();\n  }\n};\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "unit-test"
        }
    }, 
    {
        "pk": 3, 
        "model": "jetpack.module", 
        "fields": {
            "code": "// Parts of this module were taken from narwhal:\n//\n// http://narwhaljs.org\n\nvar observers = [];\nvar unloaders = [];\n\nvar when = exports.when = function when(observer) {\n  observers.unshift(observer);\n};\n\nvar send = exports.send = function send(reason) {\n  observers.forEach(function (observer) {\n    observer(reason);\n  });\n};\n\nvar addMethod = exports.addMethod = function addMethod(obj, unloader) {\n  var called = false;\n\n  function unloadWrapper(reason) {\n    if (!called) {\n      called = true;\n      var index = unloaders.indexOf(unloadWrapper);\n      if (index == -1)\n        throw new Error(\"internal error: unloader not found\");\n      unloaders.splice(index, 1);\n      unloader.apply(obj, [reason]);\n    }\n  };\n\n  unloaders.push(unloadWrapper);\n  obj.unload = unloadWrapper;\n};\n\nvar ensure = exports.ensure = function ensure(obj) {\n  if (!(\"unload\" in obj))\n    throw new Error(\"object has no 'unload' property\");\n\n  addMethod(obj, obj.unload);\n};\n\nwhen(\n  function(reason) {\n    unloaders.slice().forEach(\n      function(unloadWrapper) {\n        unloadWrapper(reason);\n      });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "unload"
        }
    }, 
    {
        "pk": 19, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\n\nvar ios = Cc['@mozilla.org/network/io-service;1']\n          .getService(Ci.nsIIOService);\n\nvar resProt = ios.getProtocolHandler(\"resource\")\n              .QueryInterface(Ci.nsIResProtocolHandler);\n\nfunction newURI(uriStr, base) {\n  try {\n    let baseURI = base ? ios.newURI(base, null, null) : null;\n    return ios.newURI(uriStr, null, baseURI);\n  }\n  catch (e if e.result == Cr.NS_ERROR_MALFORMED_URI) {\n    throw new Error(\"malformed URI: \" + uriStr);\n  }\n  catch (e if (e.result == Cr.NS_ERROR_FAILURE ||\n               e.result == Cr.NS_ERROR_ILLEGAL_VALUE)) {\n    throw new Error(\"invalid URI: \" + uriStr);\n  }\n}\n\nfunction resolveResourceURI(uri) {\n  var resolved;\n  try {\n    resolved = resProt.resolveURI(uri);\n  } catch (e if e.result == Cr.NS_ERROR_NOT_AVAILABLE) {\n    throw new Error(\"resource does not exist: \" + uri.spec);\n  };\n  return resolved;\n}\n\nlet fromFilename = exports.fromFilename = function fromFilename(path) {\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  return ios.newFileURI(file).spec;\n};\n\nlet toFilename = exports.toFilename = function toFilename(url) {\n  var uri = newURI(url);\n  if (uri.scheme == \"resource\")\n    uri = newURI(resolveResourceURI(uri));\n  if (uri.scheme == \"chrome\") {\n    var channel = ios.newChannelFromURI(uri);\n    try {\n      channel = channel.QueryInterface(Ci.nsIFileChannel);\n      return channel.file.path;\n    } catch (e if e.result == Cr.NS_NOINTERFACE) {\n      throw new Error(\"chrome url isn't on filesystem: \" + url);\n    }\n  }\n  if (uri.scheme == \"file\") {\n    var file = uri.QueryInterface(Ci.nsIFileURL).file;\n    return file.path;\n  }\n  throw new Error(\"cannot map to filename: \" + url);\n};\n\nfunction URL(url, base) {\n  var uri = newURI(url, base);\n\n  var userPass = null;\n  try {\n    userPass = uri.userPass ? uri.userPass : null;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  var host = null;\n  try {\n    host = uri.host;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  var port = null;\n  try {\n    port = uri.port == -1 ? null : uri.port;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  this.__defineGetter__(\"scheme\", function() uri.scheme);\n  this.__defineGetter__(\"userPass\", function() userPass);\n  this.__defineGetter__(\"host\", function() host);\n  this.__defineGetter__(\"port\", function() port);\n  this.__defineGetter__(\"path\", function() uri.path);\n  this.toString = function URL_toString() uri.spec;\n};\nexports.URL = require(\"api-utils\").publicConstructor(URL);\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "url"
        }
    }, 
    {
        "pk": 17, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Dietrich Ayala <dietrich@mozilla.com> (Original Author)\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\n// Widget content types\nconst CONTENT_TYPE_URI    = 1;\nconst CONTENT_TYPE_HTML   = 2;\nconst CONTENT_TYPE_IMAGE  = 3;\n\n// Supported events\nconst EVENTS = {\n  onClick: \"click\",\n  onLoad: \"load\",\n  onMouseover: \"mouseover\",\n  onMouseout: \"mouseout\",\n  onReady: \"DOMContentLoaded\"};\n\n// Preference for UI visibility state\nconst PREF_ADDON_BAR_HIDDEN = \"jetpack.jetpack-core.widget.barIsHidden\";\nconst PREF_DEFAULT_ADDON_BAR_HIDDEN = false;\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The widget module currently supports only Firefox.  In the future \",\n    \"it will support other applications. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nconst apiutils = require(\"api-utils\");\nconst collection = require(\"collection\");\nconst errors = require(\"errors\");\nconst prefs = require(\"preferences-service\");\n\n// Expose public APIs for creating/adding/removing widgets\nexports.Widget = apiutils.publicConstructor(Widget);\nexports.add = function(item) browserManager.addItem(item);\nexports.remove = function(item) browserManager.removeItem(item);\n\n// The widget object.\nfunction Widget(options) {\n  options = apiutils.validateOptions(options, {\n    label: {\n      is: [\"string\"],\n      ok: function (v) v.length > 0,\n      msg: \"The widget must have a non-empty label property.\"\n    },\n    image: {\n      is: [\"null\", \"undefined\", \"string\"],\n    },\n    content: {\n      is: [\"null\", \"undefined\", \"string\"],\n    },\n    width:  {\n      is: [\"null\", \"undefined\", \"number\"],\n    },\n    onClick: {\n      is: [\"function\", \"array\", \"null\", \"undefined\"],\n    },\n    onMouseover: {\n      is: [\"function\", \"array\", \"null\", \"undefined\"],\n    },\n    onMouseout: {\n      is: [\"function\", \"array\", \"null\", \"undefined\"],\n    },\n    onLoad: {\n      is: [\"function\", \"array\", \"null\", \"undefined\"],\n    },\n    onReady: {\n      is: [\"function\", \"array\", \"null\", \"undefined\"],\n    }\n  });\n\n  if (!(options.image || options.content))\n    throw new Error(\"No image or content property found. Widgets must have one or the other.\");\n\n  let self = this;\n\n  this.__defineGetter__(\"label\", function() options.label);\n\n  this.__defineGetter__(\"width\", function() options.width || 24);\n  this.__defineSetter__(\"width\", function(width) {\n    options.width = width;\n    browserManager.updateItem(self, \"width\", width);\n  });\n\n  if (options.image) {\n    this.__defineGetter__(\"image\", function() options.image);\n    this.__defineSetter__(\"image\", function(image) {\n      options.image = image;\n      browserManager.updateItem(self, \"image\", image);\n    });\n  }\n\n  if (options.content) {\n    this.__defineGetter__(\"content\", function() options.content);\n    this.__defineSetter__(\"content\", function(content) {\n      options.content = content;\n      browserManager.updateItem(self, \"content\", content);\n    });\n  }\n\n  for (let method in EVENTS) {\n    // create collection for the event as a widget property\n    collection.addCollectionProperty(this, method);\n    // add event handlers\n    if (options[method])\n      this[method].add(options[method]);\n  }\n\n  this.toString = function Widget_toString() {\n    return '[object Widget \"' + options.label + '\"]';\n  };\n}\n\n// Keeps track of all browser windows.\n// Exposes methods for adding/removing/updating widgets\n// across all open windows (and future ones).\nlet browserManager = {\n  items: [],\n  windows: [],\n\n  // Registers the manager to listen for window openings and closings.  Note\n  // that calling this method can cause onTrack to be called immediately if\n  // there are open windows.\n  init: function () {\n    let windowTracker = new (require(\"window-utils\").WindowTracker)(this);\n    require(\"unload\").ensure(windowTracker);\n  },\n\n  // Registers a window with the manager.  This is a WindowTracker callback.\n  onTrack: function browserManager_onTrack(window) {\n    if (this._isBrowserWindow(window)) {\n      let win = new BrowserWindow(window);\n      win.addItems(this.items);\n      this.windows.push(win);\n    }\n  },\n\n  // Unregisters a window from the manager.  It's told to undo all \n  // modifications.  This is a WindowTracker callback.  Note that when\n  // WindowTracker is unloaded, it calls onUntrack for every currently opened\n  // window.  The browserManager therefore doesn't need to specially handle\n  // unload itself, since unloading the browserManager means untracking all\n  // currently opened windows.\n  onUntrack: function browserManager_onUntrack(window) {\n    if (this._isBrowserWindow(window)) {\n      for (let i = 0; i < this.windows.length; i++) {\n        if (this.windows[i].window == window) {\n          let win = this.windows.splice(i, 1)[0];\n          win.destroy();\n          return;\n        }\n      }\n    }\n  },\n\n  // Registers an item with the manager. It's added to the add-on bar of\n  // all currently registered windows, and when new windows are registered it\n  // will be added to them, too.\n  addItem: function browserManager_addItem(item) {\n    let idx = this.items.indexOf(item);\n    if (idx > -1)\n      throw new Error(\"The widget \" + item + \" has already been added.\");\n    this.items.push(item);\n    this.windows.forEach(function (w) w.addItems([item]));\n  },\n\n  // Updates the content of an item registered with the manager,\n  // propagating the change to all windows.\n  updateItem: function browserManager_updateItem(item, property, value) {\n    let idx = this.items.indexOf(item);\n    if (idx == -1)\n      throw new Error(\"The widget \" + item + \" cannot be updated because it is not currently registered.\");\n    this.windows.forEach(function (w) w.updateItem(item, property, value));\n  },\n\n  // Unregisters an item from the manager.  It's removed from the addon-bar\n  // of all windows that are currently registered.\n  removeItem: function browserManager_removeItem(item) {\n    let idx = this.items.indexOf(item);\n    if (idx == -1) {\n      throw new Error(\"The widget \" + item + \" has not been added \" +\n                      \"and therefore cannot be removed.\");\n    }\n    this.items.splice(idx, 1);\n    this.windows.forEach(function (w) w.removeItems([item]));\n  },\n\n  _isBrowserWindow: function browserManager__isBrowserWindow(win) {\n    let winType = win.document.documentElement.getAttribute(\"windowtype\");\n    return winType === \"navigator:browser\";\n  }\n};\n\n// Keeps track of a single browser window.  Responsible for providing a\n// description of the window's current context and determining whether an item\n// matches the current context.\n//\n// This is where the core of how a widget's content is added to a window lives.\n//\n// TODO: If other apps besides Firefox want to support the add-on bar in\n// whatever way is appropriate for them, plugging in a substitute for this class\n// should be the way to do it.  Make it easy for them.  See bug 560716.\nfunction BrowserWindow(window) {\n  this.window = window;\n  this.doc = window.document;\n  this._init();\n}\n\nBrowserWindow.prototype = {\n\n  _init: function BW__init() {\n    // Array of objects:\n    // {\n    //   widget: widget object,\n    //   node: dom node,\n    //   eventListeners: hash of event listeners\n    // }\n    this._items = [];\n\n    // Add keypress listener\n    this.window.addEventListener(\"keypress\", this, false);\n\n    // Hook up pref observer for UI visibility state.\n    const prefsvc = Cc[\"@mozilla.org/preferences-service;1\"].\n                    getService(Ci.nsIPrefBranch2);\n    prefsvc.addObserver(PREF_ADDON_BAR_HIDDEN, this, false);\n  },\n\n  // nsIObserver\n  observe: function BW_observe(s, t, d) {\n    let val = prefs.get(PREF_ADDON_BAR_HIDDEN, PREF_DEFAULT_ADDON_BAR_HIDDEN);\n    this.container.hidden = !!val;\n  },\n\n  // nsIDOMEventListener\n  handleEvent: function BW_handleEvent(aEvent) {\n    switch (aEvent.type) {\n      case \"keypress\":\n        this._onKeyPress(aEvent);\n        break;\n    }\n  },\n\n  _onKeyPress: function BW__onKeyPress(aEvent) {\n    let accelKey = /^Mac/.test(this.window.navigator.platform) ?\n                   aEvent.metaKey : aEvent.ctrlKey;\n    let nonAccelKey = /^Mac/.test(this.window.navigator.platform) ?\n                            aEvent.ctrlKey : aEvent.metaKey;\n    if (aEvent.which == aEvent.DOM_VK_U && aEvent.shiftKey &&\n        accelKey && !nonAccelKey && !aEvent.altKey)\n      this._onToggleUI();\n  },\n\n  get container() {\n    if (!this._container) {\n      // Bug 574688 replaces the status bar with the add-on bar. This code\n      // might be removed when that bug is resolved. It might stay, if we \n      // want to support versions of Firefox that don't have the add-on bar.\n      let container = this.doc.getElementById(\"addon-bar\");\n      if (!container) {\n\n        let toolbox = this.doc.createElement(\"toolbox\");\n\n        // Share browser's palette.\n        let browserToolbox = this.doc.getElementById(\"navigator-toolbox\");\n        toolbox.palette = browserToolbox.palette;\n\n        container = this.doc.createElement(\"toolbar\");\n        container.setAttribute(\"id\", \"addon-bar\");\n        container.setAttribute(\"customizable\", \"true\");\n        // TODO: needs localization\n        container.setAttribute(\"toolbarname\", \"Add-ons Toolbar\");\n\n        container.style.height = \"100px\";\n        container.style.padding = \"0px\";\n        container.style.margin = \"0px\";\n\n        // TODO: make part of toolbar infrastructure, so is controlled\n        // via the View menu instead of pref. (bug 579506)\n        container.hidden = require(\"preferences-service\").\n                           get(PREF_ADDON_BAR_HIDDEN,\n                               PREF_DEFAULT_ADDON_BAR_HIDDEN);\n\n        toolbox.appendChild(container);\n\n        let statusbar = this.doc.getElementById(\"status-bar\");\n        statusbar.parentNode.insertBefore(toolbox, statusbar);\n      }\n\n      this._container = container;\n    }\n    return this._container;\n  },\n\n  // Remove container\n  _removeContainer: function BW__removeContainer() {\n    if (this._container) {\n      let toolbar = this._container;\n      let toolbox = toolbar.parentNode;\n      toolbox.removeChild(toolbar);\n      toolbox.parentNode.removeChild(toolbox);\n      this._container = null;\n    }\n  },\n\n  // Update the visibility state for the addon bar.\n  _onToggleUI: function BW__onToggleUI() {\n    this.container.hidden = !this.container.hidden;\n    prefs.set(PREF_ADDON_BAR_HIDDEN, this.container.hidden);\n  },\n\n  // Adds an array of items to the window.\n  addItems: function BW_addItems(items) {\n    items.forEach(this._addItemToWindow, this);\n  },\n\n  // Update a property of a widget.\n  updateItem: function BW_updateItem(updatedItem, property, value) {\n    let item = this._items.filter(function(item) item.widget == updatedItem).shift();\n    if (item) {\n      switch(property) {\n        case \"image\":\n        case \"content\":\n          this.setContent(item);\n          break;\n        case \"width\":\n          item.node.style.minWidth = value + \"px\";\n          item.node.querySelector(\"iframe\").style.width = value + \"px\";\n          break;\n      }\n    }\n  },\n\n  // Add a widget to this window.\n  _addItemToWindow: function BW__addItemToWindow(widget) {\n    // XUL element container for widget\n    let node = this.doc.createElement(\"toolbaritem\");\n    let guid = require(\"xpcom\").makeUuid().toString();\n    let id = \"widget: \" + guid;\n    node.setAttribute(\"id\", id);\n    node.setAttribute(\"label\", widget.label);\n    node.setAttribute(\"tooltiptext\", widget.description);\n\n    // TODO move into a stylesheet\n    node.setAttribute(\"style\", [\n        \"min-height: 24px; max-height: 24px;\",\n        \"overflow: hidden; margin: 5px; padding: 0px;\",\n        \"border: 1px solid #71798F; -moz-box-shadow: 1px 1px 3px #71798F;\",\n        \"-moz-border-radius: 3px;\"\n    ].join(\"\"));\n\n    node.style.minWidth = widget.width + \"px\";\n\n    // Add to the customization palette\n    let toolbox = this.doc.getElementById(\"navigator-toolbox\");\n    let palette = toolbox.palette;\n    palette.appendChild(node);\n\n    // Add the item to the toolbar\n    this.container.insertItem(id, null, null, false);\n\n    let item = {widget: widget, node: node};\n\n    this._fillItem(item);\n\n    this._items.push(item);\n  },\n\n  // Initial population of a widget's content.\n  _fillItem: function BS__fillItem(item) {\n    // Create element\n    var iframe = this.doc.createElement(\"iframe\");\n    iframe.setAttribute(\"type\", \"content\");\n    iframe.setAttribute(\"transparent\", \"transparent\");\n    iframe.style.overflow = \"hidden\";\n    iframe.style.height = \"24px\";\n    iframe.style.width = item.widget.width + \"px\";\n    iframe.setAttribute(\"flex\", \"1\");\n    iframe.style.border = \"none\";\n    iframe.style.padding = \"0px\";\n    \n    // Do this early, because things like contentWindow are null\n    // until the node is attached to a document.\n    item.node.appendChild(iframe);\n\n    // add event handlers\n    this.addEventHandlers(item);\n\n    // set content\n    this.setContent(item);\n  },\n\n  // Get widget content type.\n  // TODO: fully replace with explicit URL/IMG objects once bug 564524 is fixed.\n  getContentType: function BW_getContentType(widget) {\n    let type = widget.image ? CONTENT_TYPE_IMAGE :\n                              CONTENT_TYPE_HTML;\n    if (widget.content) {\n      try {\n        require(\"url\").URL(widget.content);\n        type = CONTENT_TYPE_URI;\n      } catch(e) {}\n    }\n\n    return type;\n  },\n\n  // Set widget content.\n  setContent: function BW_setContent(item) {\n    let type = this.getContentType(item.widget);\n    let iframe = item.node.firstElementChild;\n    switch (type) {\n      case CONTENT_TYPE_HTML:\n        iframe.setAttribute(\"src\", \"data:text/html,\" + encodeURI(item.widget.content));\n        break;\n      case CONTENT_TYPE_URI:\n        iframe.setAttribute(\"src\", item.widget.content);\n        break;\n      case CONTENT_TYPE_IMAGE:\n        let imageURL = item.widget.image;\n        iframe.setAttribute(\"src\", \"data:text/html,<html><body><img src='\" +\n                                   encodeURI(imageURL) + \"'></body></html>\");\n        break;\n      default:\n        throw new Error(\"The widget's type cannot be determined.\");\n    }\n  },\n\n  // Set up all supported events for a widget.\n  addEventHandlers: function BW_addEventHandlers(item) {\n    let contentType = this.getContentType(item.widget);\n\n    // Given an event type (eg: load) return the\n    // handler name (eg: onLoad).\n    function getHandlerForType(type) {\n      for (let handler in EVENTS) {\n        if (EVENTS[handler] == type)\n          return handler;\n      }\n      return null;\n    }\n\n    // Detect if document consists of a single image.\n    function isImageDoc(doc) {\n      return doc.body.childNodes.length == 1 &&\n             doc.body.firstElementChild &&\n             doc.body.firstElementChild.tagName == \"IMG\";\n    }\n\n    // Make modifications required for nice default presentation.\n    function modifyStyle(doc) {\n      // TODO: special-casing of images will be replaced, probably by an\n      // image-specific extension of the URI object.\n      if (contentType == CONTENT_TYPE_IMAGE || isImageDoc(doc)) {\n        // Force image content to size.\n        // Add-on authors must size their images correctly.\n        doc.body.firstElementChild.style.width = item.widget.width + \"px\";\n        doc.body.firstElementChild.style.height = \"24px\";\n      }\n\n      // Allow all content to fill the box by default.\n      doc.body.style.margin = \"0\";\n    }\n\n    let listener = function(e) {\n      // Ignore event firings that target the iframe\n      if (e.target == item.node.firstElementChild)\n        return;\n\n      // Ignore about:blank loads\n      if (e.type == \"load\" && e.target.location == \"about:blank\")\n        return;\n\n      // Content-specific document modifications\n      if (e.type == \"load\")\n        modifyStyle(e.target);\n\n      // Proxy event to the widget's listeners\n      let handler = getHandlerForType(e.type);\n      for (let callback in item.widget[handler])\n        require(\"errors\").catchAndLog(function(e) callback.apply(item.widget, [e]))(e);\n    };\n\n    item.eventListeners = {};\n    for (let [method, type] in Iterator(EVENTS)) {\n      let iframe = item.node.firstElementChild;\n      iframe.addEventListener(type, listener, true, true);\n\n      // Store listeners for later removal\n      item.eventListeners[method] = listener;\n    }\n  },\n\n  // Removes an array of items from the window.\n  removeItems: function BW_removeItems(removedItems) {\n    removedItems.forEach(function(removedItem) {\n      let entry = this._items.filter(function(entry) entry.widget == removedItem).shift();\n      if (entry) {\n        // remove event listeners\n        for (let [method, listener] in Iterator(entry.eventListeners))\n          entry.node.firstElementChild.removeEventListener(EVENTS[method], listener, true);\n        // remove dom node\n        this.container.removeChild(entry.node);\n        // remove entry\n        this._items.splice(this._items.indexOf(entry), 1);\n      }\n    }, this);\n\n    // remove the add-on bar if no more items\n    if (this._items.length == 0)\n      this._removeContainer();\n  },\n\n  // Undoes all modifications to the window. The BrowserWindow\n  // should not be used afterward.\n  destroy: function BW_destroy() {\n    // Remove all items from the panel\n    let len = this._items.length;\n    for (let i = 0; i < len; i++)\n      this.removeItems([this._items[0].widget]);\n\n    const prefsvc = Cc[\"@mozilla.org/preferences-service;1\"].\n                    getService(Ci.nsIPrefBranch2);\n    prefsvc.removeObserver(PREF_ADDON_BAR_HIDDEN, this);\n\n    this.window.removeEventListener(\"keypress\", this, false);\n  }\n};\n\n// Init the browserManager only after setting prototypes and such above, because\n// it will cause browserManager.onTrack to be called immediately if there are\n// open windows.\nbrowserManager.init();\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "widget"
        }
    }, 
    {
        "pk": 5, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\nvar errors = require(\"errors\");\n\nvar gWindowWatcher = Cc[\"@mozilla.org/embedcomp/window-watcher;1\"]\n                     .getService(Ci.nsIWindowWatcher);\n\n/**\n * An iterator for XUL windows currently in the application.\n * \n * @return A generator that yields XUL windows exposing the\n *         nsIDOMWindow interface.\n */\nvar windowIterator = exports.windowIterator = function windowIterator() {\n  let winEnum = gWindowWatcher.getWindowEnumerator();\n  while (winEnum.hasMoreElements())\n    yield winEnum.getNext().QueryInterface(Ci.nsIDOMWindow);\n};\n\nvar WindowTracker = exports.WindowTracker = function WindowTracker(delegate) {\n  this.delegate = delegate;\n  this._loadingWindows = [];\n  for (window in windowIterator())\n    this._regWindow(window);\n  gWindowWatcher.registerNotification(this);\n  require(\"unload\").ensure(this);\n};\n\nWindowTracker.prototype = {\n  _regLoadingWindow: function _regLoadingWindow(window) {\n    this._loadingWindows.push(window);\n    window.addEventListener(\"load\", this, true);\n  },\n\n  _unregLoadingWindow: function _unregLoadingWindow(window) {\n    var index = this._loadingWindows.indexOf(window);\n\n    if (index != -1) {\n      this._loadingWindows.splice(index, 1);\n      window.removeEventListener(\"load\", this, true);\n    }\n  },\n\n  _regWindow: function _regWindow(window) {\n    if (window.document.readyState == \"complete\") {\n      this._unregLoadingWindow(window);\n      this.delegate.onTrack(window);\n    } else\n      this._regLoadingWindow(window);\n  },\n\n  _unregWindow: function _unregWindow(window) {\n    if (window.document.readyState == \"complete\")\n      this.delegate.onUntrack(window);\n    else\n      this._unregLoadingWindow(window);\n  },\n\n  unload: function unload() {\n    gWindowWatcher.unregisterNotification(this);\n    for (window in windowIterator())\n      this._unregWindow(window);\n  },\n\n  handleEvent: function handleEvent(event) {\n    if (event.type == \"load\" && event.target) {\n      var window = event.target.defaultView;\n      if (window)\n        this._regWindow(window);\n    }\n  },\n\n  observe: function observe(subject, topic, data) {\n    var window = subject.QueryInterface(Ci.nsIDOMWindow);\n    if (topic == \"domwindowopened\")\n      this._regWindow(window);\n    else\n      this._unregWindow(window);\n  }\n};\n\nerrors.catchAndLogProps(WindowTracker.prototype, [\"handleEvent\", \"observe\"]);\n\nvar gDocsToClose = [];\n\nfunction onDocUnload(event) {\n  var index = gDocsToClose.indexOf(event.target);\n  if (index == -1)\n    throw new Error(\"internal error: unloading document not found\");\n  var document = gDocsToClose.splice(index, 1)[0];\n  // Just in case, let's remove the event listener too.\n  document.defaultView.removeEventListener(\"unload\", onDocUnload, false);\n}\n\nonDocUnload = require(\"errors\").catchAndLog(onDocUnload);\n\nexports.closeOnUnload = function closeOnUnload(window) {\n  window.addEventListener(\"unload\", onDocUnload, false);\n  gDocsToClose.push(window.document);\n};\n\nrequire(\"unload\").when(\n  function() {\n    gDocsToClose.slice().forEach(\n      function(doc) { doc.defaultView.close(); });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "window-utils"
        }
    }, 
    {
        "pk": 12, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\n// ## Implementation Notes ##\n// \n// Making `XMLHttpRequest` objects available to Jetpack code involves a\n// few key principles universal to all LLJAPI module implementations:\n//\n// * **Unloadability**. A Jetpack-based extension using this module can be \n//   asked to unload itself at any time, e.g. because the user decides to\n//   uninstall or disable the extension. This means we need to keep track of\n//   all in-progress reqests and abort them on unload.\n//\n// * **Developer-Ergonomic Tracebacks**. Whenever an exception is raised\n//   by a Jetpack-based extension, we want it to be logged in a\n//   place that is specific to that extension--so that a developer\n//   can distinguish it from an error on a web page or in another\n//   extension, for instance. We also want it to be logged with a\n//   full stack traceback, which the Mozilla platform doesn't usually\n//   do.\n//\n//   Because of this, we don't actually want to give the Mozilla\n//   platform's \"real\" XHR implementation to clients, but instead provide\n//   a simple wrapper that trivially delegates to the implementation in\n//   all cases except where callbacks are involved: whenever Mozilla\n//   platform code calls into the extension, such as during the XHR's\n//   `onreadystatechange` callback, we want to wrap the client's callback\n//   in a try-catch clause that traps any exceptions raised by the\n//   callback and logs them via console.exception() instead of allowing\n//   them to propagate back into Mozilla platform code.\n\n// This is a private list of all active requests, so we know what to\n// abort if we're asked to unload.\nvar requests = [];\n\n// Events on XHRs that we should listen for, so we know when to remove\n// a request from our private list.\nconst TERMINATE_EVENTS = [\"load\", \"error\", \"abort\"];\n\n// Read-only properties of XMLHttpRequest objects that we want to\n// directly delegate to.\nconst READ_ONLY_PROPS = [\"readyState\", \"responseText\", \"responseXML\",\n                         \"status\", \"statusText\"];\n\n// Methods of XMLHttpRequest that we want to directly delegate to.\nconst DELEGATED_METHODS = [\"abort\", \"getAllResponseHeaders\",\n                           \"getResponseHeader\", \"overrideMimeType\",\n                           \"send\", \"sendAsBinary\", \"setRequestHeader\",\n                           \"open\"];\n\nvar getRequestCount = exports.getRequestCount = function getRequestCount() {\n  return requests.length;\n};\n\nvar XMLHttpRequest = exports.XMLHttpRequest = function XMLHttpRequest() {\n  var req = Cc[\"@mozilla.org/xmlextras/xmlhttprequest;1\"]\n            .createInstance(Ci.nsIXMLHttpRequest);\n  // For the sake of simplicity, don't tie this request to any UI.\n  req.mozBackgroundRequest = true;\n\n  memory.track(req, \"XMLHttpRequest\");\n\n  this._req = req;\n  this._orsc = null;\n\n  requests.push(this);\n\n  var self = this;\n\n  this._boundCleanup = function _boundCleanup() {\n    self._cleanup();\n  };\n\n  TERMINATE_EVENTS.forEach(\n    function(name) {\n      self._req.addEventListener(name, self._boundCleanup, false);\n    });\n};\n\nXMLHttpRequest.prototype = {\n  _cleanup: function _cleanup() {\n    this.onreadystatechange = null;\n    var index = requests.indexOf(this);\n    if (index != -1) {\n      var self = this;\n      TERMINATE_EVENTS.forEach(\n        function(name) {\n          self._req.removeEventListener(name, self._boundCleanup, false);\n        });\n      requests.splice(index, 1);\n    }\n  },\n  _unload: function _unload() {\n    this._req.abort();\n    this._cleanup();\n  },\n  addEventListener: function addEventListener() {\n    throw new Error(\"not implemented\");\n  },\n  removeEventListener: function removeEventListener() {\n    throw new Error(\"not implemented\");\n  },\n  set upload() {\n    throw new Error(\"not implemented\");\n  },\n  get onreadystatechange() {\n    return this._orsc;\n  },\n  set onreadystatechange(cb) {\n    this._orsc = cb;\n    if (cb) {\n      var self = this;\n      this._req.onreadystatechange = function() {\n        try {\n          self._orsc.apply(self, arguments);\n        } catch (e) {\n          console.exception(e);\n        }\n      };\n    } else\n      this._req.onreadystatechange = null;\n  }\n};\n\nREAD_ONLY_PROPS.forEach(\n   function(name) {\n     XMLHttpRequest.prototype.__defineGetter__(\n       name,\n       function() {\n         return this._req[name];\n       });\n   });\n\nDELEGATED_METHODS.forEach(\n  function(name) {\n    XMLHttpRequest.prototype[name] = function() {\n      return this._req[name].apply(this._req, arguments);\n    };\n  });\n\nrequire(\"unload\").when(\n  function() {\n    requests.slice().forEach(function(request) { request._unload(); });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "xhr"
        }
    }, 
    {
        "pk": 28, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cm,Cr,Cu} = require(\"chrome\");\n\nvar jsm = {};\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\", jsm);\nvar utils = exports.utils = jsm.XPCOMUtils;\n\nCm.QueryInterface(Ci.nsIComponentRegistrar);\n\nvar factories = [];\n\nfunction Factory(options) {\n  memory.track(this);\n\n  this.wrappedJSObject = this;\n  this.create = options.create;\n  this.uuid = options.uuid;\n  this.name = options.name;\n  this.contractID = options.contractID;\n\n  Cm.registerFactory(this.uuid,\n                     this.name,\n                     this.contractID,\n                     this);\n\n  var self = this;\n\n  factories.push(this);\n}\n\nFactory.prototype = {\n  createInstance: function(outer, iid) {\n    try {\n      if (outer)\n        throw Cr.NS_ERROR_NO_AGGREGATION;\n      return (new this.create()).QueryInterface(iid);\n    } catch (e) {\n      console.exception(e);\n      if (e instanceof Ci.nsIException)\n        throw e;\n      else\n        throw Cr.NS_ERROR_FAILURE;\n    }\n  },\n  unregister: function() {\n    var index = factories.indexOf(this);\n    if (index == -1)\n      throw new Error(\"factory already unregistered\");\n\n    var self = this;\n\n    factories.splice(index, 1);\n    Cm.unregisterFactory(this.uuid, this);\n  },\n  QueryInterface: utils.generateQI([Ci.nsIFactory])\n};\n\nvar makeUuid = exports.makeUuid = function makeUuid() {\n  var uuidGenerator = Cc[\"@mozilla.org/uuid-generator;1\"]\n                      .getService(Ci.nsIUUIDGenerator);\n  var uuid = uuidGenerator.generateUUID();\n  return uuid;\n};\n\nvar autoRegister = exports.autoRegister = function autoRegister(path) {\n  // TODO: This assumes that the url points to a directory\n  // that contains subdirectories corresponding to OS/ABI and then\n  // further subdirectories corresponding to Gecko platform version.\n  // we should probably either behave intelligently here or allow\n  // the caller to pass-in more options if e.g. there aren't\n  // Gecko-specific binaries for a component (which will be the case\n  // if only frozen interfaces are used).\n\n  var appInfo = Cc[\"@mozilla.org/xre/app-info;1\"]\n                .getService(Ci.nsIXULAppInfo);\n  var runtime = Cc[\"@mozilla.org/xre/app-info;1\"]\n                .getService(Ci.nsIXULRuntime);\n\n  var osDirName = runtime.OS + \"_\" + runtime.XPCOMABI;\n  var platformVersion = appInfo.platformVersion.substring(0, 5);\n\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  file.append(osDirName);\n  file.append(platformVersion);\n\n  if (!(file.exists() && file.isDirectory()))\n    throw new Error(\"component not available for OS/ABI \" +\n                    osDirName + \" and platform \" + platformVersion);\n\n  Cm.QueryInterface(Ci.nsIComponentRegistrar);\n  Cm.autoRegister(file);\n};\n\nvar register = exports.register = function register(options) {\n  options = {__proto__: options};\n  if (!options.uuid)\n    options.uuid = makeUuid();\n  return new Factory(options);\n};\n\nvar getClass = exports.getClass = function getClass(contractID, iid) {\n  if (!iid)\n    iid = Ci.nsISupports;\n  return Cm.getClassObjectByContractID(contractID, iid);\n};\n\n/**\n * Returns an Error instance that is a more descriptive version of the raw XPCOM\n * errOrResult.  opts is used by some exceptions to include helpful info in\n * their messages such as a filename, and as such its properties depend on the\n * type of exception being thrown.  opts need not be defined for errors that\n * don't use it.  See below for a list of supported options.\n *\n * If there is no friendly version of errOrResult, then if it's an nsIException,\n * an Error whose message is errOrResult's message is returned; if it's a\n * result, an Error with a simple numeric message is returned; and if it's an\n * Error, it itself is returned.\n *\n * @param  errOrResult\n *         An nsIException, Error, or one of the Components.results.\n * @param  opts\n *         An optional options object.  The following properies are supported:\n *         @prop filename\n *               The name of the file being accessed when the exception was\n *               thrown, if any.\n * @return An Error instance.\n */\nvar friendlyError = exports.friendlyError =\n  function friendlyError(errOrResult, opts) {\n    opts = opts || {};\n    var result = errOrResult instanceof Ci.nsIException ?\n                 errOrResult.result :\n                 errOrResult;\n\n    // Common options to be used below.\n    var filename = opts.filename || \"(filename unknown)\";\n\n    // If you add an error message, update testFriendlyError in test-xpcom.js.\n    // If the message includes options, also update this method's comment.\n    switch (result) {\n    case Cr.NS_BASE_STREAM_CLOSED:\n      return new Error(\"The stream is closed and cannot be read or written.\");\n    case Cr.NS_ERROR_FILE_IS_DIRECTORY:\n      return new Error(\"The stream was opened on a directory, which cannot \" +\n                       \"be read or written: \" + filename);\n    case Cr.NS_ERROR_FILE_NOT_FOUND:\n      return new Error(\"path does not exist: \" + filename);\n    }\n\n    // errOrResult should be an nsIException, ...\n    if (errOrResult instanceof Ci.nsIException)\n      return new Error(\"XPCOM error: \" + errOrResult.message);\n\n    // ... one of Components.results, a number, ...\n    if (typeof(errOrResult) === \"number\") {\n\n      // Look up the result's name to make the message a little nicer.\n      for (let [name, val] in Iterator(Cr)) {\n        if (val === errOrResult) {\n          return new Error(\"XPCOM error \" + name +\n                           \" (0x\" + errOrResult.toString(16) + \")\");\n        }\n      }\n    }\n\n    // ... or an Error.\n    if (errOrResult.constructor.name === \"Error\")\n      return errOrResult;\n\n    // We've been called wrong if we get here.\n    return new Error(\"Unknown error: \" + errOrResult);\n  };\n\nrequire(\"unload\").when(\n  function() {\n    var copy = factories.slice();\n    copy.reverse();\n    copy.forEach(function(factory) { factory.unregister(); });\n  });\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "xpcom"
        }
    }, 
    {
        "pk": 20, 
        "model": "jetpack.module", 
        "fields": {
            "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc, Ci} = require(\"chrome\");\n\nvar appInfo = Cc[\"@mozilla.org/xre/app-info;1\"]\n              .getService(Ci.nsIXULAppInfo);\n\nvar ID = exports.ID = appInfo.ID;\nvar name = exports.name = appInfo.name;\nvar version = exports.version = appInfo.version;\nvar platformVersion = exports.platformVersion = appInfo.platformVersion;\n\n// The following mapping of application names to GUIDs was taken from:\n// \n//   https://addons.mozilla.org/en-US/firefox/pages/appversions\n//\n// Using the GUID instead of the app's name is preferable because sometimes\n// re-branded versions of a product have different names: for instance,\n// Firefox, Minefield, Iceweasel, and Shiretoko all have the same\n// GUID.\n\nvar ids = exports.ids = {\n  Firefox: \"{ec8030f7-c20a-464f-9b0e-13a3a9e97384}\",\n  Mozilla: \"{86c18b42-e466-45a9-ae7a-9b95ba6f5640}\",\n  Sunbird: \"{718e30fb-e89b-41dd-9da7-e25a45638b28}\",\n  SeaMonkey: \"{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}\",\n  Fennec: \"{a23983c0-fd0e-11dc-95ff-0800200c9a66}\",\n  Thunderbird: \"{3550f703-e582-4d05-9a08-453d09bdfdc6}\"\n};\n\nvar is = exports.is = function is(name) {\n  if (!(name in ids))\n    throw new Error(\"Unkown Mozilla Application: \" + name);\n  return ID == ids[name];\n};\n\nvar isOneOf = exports.isOneOf = function isOneOf(names) {\n  for (var i = 0; i < names.length; i++)\n    if (is(names[i]))\n      return true;\n  return false;\n};\n\n/**\n * Use this to check whether the given version (e.g. xulApp.platformVersion)\n * is in the given range. Versions must be in version comparator-compatible\n * format. See MDC for details:\n * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIVersionComparator\n */\nvar versionInRange = exports.versionInRange =\nfunction versionInRange(version, lowInclusive, highExclusive) {\n  var vc = Cc[\"@mozilla.org/xpcom/version-comparator;1\"]\n           .getService(Ci.nsIVersionComparator);\n  return (vc.compare(version, lowInclusive) >= 0) &&\n         (vc.compare(version, highExclusive) < 0);\n}\n\n", 
            "revisions": [
                1
            ], 
            "author": 1, 
            "filename": "xul-app"
        }
    }, 
    {
        "pk": 1, 
        "model": "jetpack.sdk", 
        "fields": {
            "version": "0.6", 
            "core_lib": 1, 
            "dir": "jetpack-sdk"
        }
    }, 
    {
        "pk": 1, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_logentry", 
            "name": "Can add log entry", 
            "content_type": 1
        }
    }, 
    {
        "pk": 2, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_logentry", 
            "name": "Can change log entry", 
            "content_type": 1
        }
    }, 
    {
        "pk": 3, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_logentry", 
            "name": "Can delete log entry", 
            "content_type": 1
        }
    }, 
    {
        "pk": 7, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_group", 
            "name": "Can add group", 
            "content_type": 3
        }
    }, 
    {
        "pk": 8, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_group", 
            "name": "Can change group", 
            "content_type": 3
        }
    }, 
    {
        "pk": 9, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_group", 
            "name": "Can delete group", 
            "content_type": 3
        }
    }, 
    {
        "pk": 13, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_message", 
            "name": "Can add message", 
            "content_type": 5
        }
    }, 
    {
        "pk": 14, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_message", 
            "name": "Can change message", 
            "content_type": 5
        }
    }, 
    {
        "pk": 15, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_message", 
            "name": "Can delete message", 
            "content_type": 5
        }
    }, 
    {
        "pk": 4, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_permission", 
            "name": "Can add permission", 
            "content_type": 2
        }
    }, 
    {
        "pk": 5, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_permission", 
            "name": "Can change permission", 
            "content_type": 2
        }
    }, 
    {
        "pk": 6, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_permission", 
            "name": "Can delete permission", 
            "content_type": 2
        }
    }, 
    {
        "pk": 10, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_user", 
            "name": "Can add user", 
            "content_type": 4
        }
    }, 
    {
        "pk": 11, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_user", 
            "name": "Can change user", 
            "content_type": 4
        }
    }, 
    {
        "pk": 12, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_user", 
            "name": "Can delete user", 
            "content_type": 4
        }
    }, 
    {
        "pk": 16, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_contenttype", 
            "name": "Can add content type", 
            "content_type": 6
        }
    }, 
    {
        "pk": 17, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_contenttype", 
            "name": "Can change content type", 
            "content_type": 6
        }
    }, 
    {
        "pk": 18, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_contenttype", 
            "name": "Can delete content type", 
            "content_type": 6
        }
    }, 
    {
        "pk": 40, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_attachment", 
            "name": "Can add attachment", 
            "content_type": 14
        }
    }, 
    {
        "pk": 41, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_attachment", 
            "name": "Can change attachment", 
            "content_type": 14
        }
    }, 
    {
        "pk": 42, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_attachment", 
            "name": "Can delete attachment", 
            "content_type": 14
        }
    }, 
    {
        "pk": 37, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_module", 
            "name": "Can add module", 
            "content_type": 13
        }
    }, 
    {
        "pk": 38, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_module", 
            "name": "Can change module", 
            "content_type": 13
        }
    }, 
    {
        "pk": 39, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_module", 
            "name": "Can delete module", 
            "content_type": 13
        }
    }, 
    {
        "pk": 31, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_package", 
            "name": "Can add package", 
            "content_type": 11
        }
    }, 
    {
        "pk": 32, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_package", 
            "name": "Can change package", 
            "content_type": 11
        }
    }, 
    {
        "pk": 33, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_package", 
            "name": "Can delete package", 
            "content_type": 11
        }
    }, 
    {
        "pk": 34, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_packagerevision", 
            "name": "Can add package revision", 
            "content_type": 12
        }
    }, 
    {
        "pk": 35, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_packagerevision", 
            "name": "Can change package revision", 
            "content_type": 12
        }
    }, 
    {
        "pk": 36, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_packagerevision", 
            "name": "Can delete package revision", 
            "content_type": 12
        }
    }, 
    {
        "pk": 43, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_sdk", 
            "name": "Can add sdk", 
            "content_type": 15
        }
    }, 
    {
        "pk": 44, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_sdk", 
            "name": "Can change sdk", 
            "content_type": 15
        }
    }, 
    {
        "pk": 45, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_sdk", 
            "name": "Can delete sdk", 
            "content_type": 15
        }
    }, 
    {
        "pk": 25, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_limit", 
            "name": "Can add limit", 
            "content_type": 9
        }
    }, 
    {
        "pk": 26, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_limit", 
            "name": "Can change limit", 
            "content_type": 9
        }
    }, 
    {
        "pk": 27, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_limit", 
            "name": "Can delete limit", 
            "content_type": 9
        }
    }, 
    {
        "pk": 28, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_profile", 
            "name": "Can add profile", 
            "content_type": 10
        }
    }, 
    {
        "pk": 29, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_profile", 
            "name": "Can change profile", 
            "content_type": 10
        }
    }, 
    {
        "pk": 30, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_profile", 
            "name": "Can delete profile", 
            "content_type": 10
        }
    }, 
    {
        "pk": 19, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_session", 
            "name": "Can add session", 
            "content_type": 7
        }
    }, 
    {
        "pk": 20, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_session", 
            "name": "Can change session", 
            "content_type": 7
        }
    }, 
    {
        "pk": 21, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_session", 
            "name": "Can delete session", 
            "content_type": 7
        }
    }, 
    {
        "pk": 22, 
        "model": "auth.permission", 
        "fields": {
            "codename": "add_site", 
            "name": "Can add site", 
            "content_type": 8
        }
    }, 
    {
        "pk": 23, 
        "model": "auth.permission", 
        "fields": {
            "codename": "change_site", 
            "name": "Can change site", 
            "content_type": 8
        }
    }, 
    {
        "pk": 24, 
        "model": "auth.permission", 
        "fields": {
            "codename": "delete_site", 
            "name": "Can delete site", 
            "content_type": 8
        }
    } 
]
