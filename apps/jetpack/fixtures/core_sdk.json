[
    {
        "pk": 1,
        "model": "person.profile",
        "fields": {
            "nickname": null,
            "location": null,
            "user": 1,
            "photo": null,
            "homepage": null,
            "occupation": null
        }
    },
    {
    "pk": 8, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 7, 
      "name": "addon-kit", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 2, 
      "created_at": "2011-06-14 07:20:31", 
      "author": 1, 
      "full_name": "Addon Kit", 
      "module_main": "main", 
      "revision_number": 4, 
      "commit_message": "version changed, module (page-worker.js) added, module (hotkeys.js) added, module (private-browsing.js) added, module (page-mod.js) added, module (timers.js) added, module (tabs.js) added, module (selection.js) added, module (notifications.js) added, module (context-menu.js) added, module (request.js) added, module (panel.js) added, module (passwords.js) added, module (widget.js) added, module (windows.js) added, module (simple-storage.js) added, module (clipboard.js) added, attachment (test.html) added, attachment (test-page-worker.html) added, attachment (moz_favicon.ico) added, attachment (test-page-worker.js) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 7, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 6, 
      "name": "addon-kit", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 2, 
      "created_at": "2011-06-14 07:20:31", 
      "author": 1, 
      "full_name": "Addon Kit", 
      "module_main": "main", 
      "revision_number": 3, 
      "commit_message": "version changed, module (page-worker.js) added, module (hotkeys.js) added, module (private-browsing.js) added, module (page-mod.js) added, module (timers.js) added, module (tabs.js) added, module (selection.js) added, module (notifications.js) added, module (context-menu.js) added, module (request.js) added, module (panel.js) added, module (passwords.js) added, module (widget.js) added, module (windows.js) added, module (simple-storage.js) added, module (clipboard.js) added, attachment (test.html) added, attachment (test-page-worker.html) added, attachment (moz_favicon.ico) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 3, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 2, 
      "name": "api-utils", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 1, 
      "created_at": "2011-06-14 07:20:30", 
      "author": 1, 
      "full_name": "API Utils", 
      "module_main": "main", 
      "revision_number": 2, 
      "commit_message": "version changed, module (errors.js) added, module (test/assert.js) added, module (self-e10s-adapter.js) added, module (traits.js) added, module (collection.js) added, module (unload.js) added, module (unit-test-finder.js) added, module (app-strings.js) added, module (dom/events.js) added, module (dom/events/keys.js) added, module (window-utils.js) added, module (find-tests.js) added, module (securable-module.js) added, module (traceback.js) added, module (cuddlefish.js) added, module (events.js) added, module (api-utils.js) added, module (tab-browser.js) added, module (xpcom.js) added, module (list.js) added, module (utils/data.js) added, module (utils/thumbnail.js) added, module (utils/function.js) added, module (utils/registry.js) added, module (unit-test.js) added, module (xhr.js) added, module (content/loader.js) added, module (content/worker.js) added, module (content/symbiont.js) added, module (content/content-proxy.js) added, module (shims.js) added, module (e10s.js) added, module (text-streams.js) added, module (xul-app.js) added, module (cortex.js) added, module (url.js) added, module (runtime.js) added, module (observer-service.js) added, module (passwords/utils.js) added, module (byte-streams.js) added, module (memory.js) added, module (keyboard/hotkeys.js) added, module (keyboard/utils.js) added, module (keyboard/observer.js) added, module (file.js) added, module (windows/tabs.js) added, module (windows/dom.js) added, module (windows/observer.js) added, module (windows/loader.js) added, module (tabs/utils.js) added, module (tabs/events.js) added, module (tabs/tab.js) added, module (tabs/observer.js) added, module (content.js) added, module (events/assembler.js) added, module (preferences-service.js) added, module (timer.js) added, module (test.js) added, module (find-tests-e10s-adapter.js) added, module (array.js) added, module (type.js) added, module (traits/core.js) added, module (plain-text-console.js) added, module (timer-e10s-adapter.js) added, module (url-e10s-adapter.js) added, module (self-maker.js) added, module (light-traits.js) added, module (hidden-frame.js) added, module (match-pattern.js) added, attachment (test-content-symbiont.js) added, attachment (bootstrap-remote-process.js) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 6, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 5, 
      "name": "addon-kit", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 2, 
      "created_at": "2011-06-14 07:20:31", 
      "author": 1, 
      "full_name": "Addon Kit", 
      "module_main": "main", 
      "revision_number": 2, 
      "commit_message": "version changed, module (page-worker.js) added, module (hotkeys.js) added, module (private-browsing.js) added, module (page-mod.js) added, module (timers.js) added, module (tabs.js) added, module (selection.js) added, module (notifications.js) added, module (context-menu.js) added, module (request.js) added, module (panel.js) added, module (passwords.js) added, module (widget.js) added, module (windows.js) added, module (simple-storage.js) added, module (clipboard.js) added, attachment (test.html) added, attachment (test-page-worker.html) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 2, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 1, 
      "name": "api-utils", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 1, 
      "created_at": "2011-06-14 07:20:30", 
      "author": 1, 
      "full_name": "API Utils", 
      "module_main": "main", 
      "revision_number": 1, 
      "commit_message": "version changed, module (errors.js) added, module (test/assert.js) added, module (self-e10s-adapter.js) added, module (traits.js) added, module (collection.js) added, module (unload.js) added, module (unit-test-finder.js) added, module (app-strings.js) added, module (dom/events.js) added, module (dom/events/keys.js) added, module (window-utils.js) added, module (find-tests.js) added, module (securable-module.js) added, module (traceback.js) added, module (cuddlefish.js) added, module (events.js) added, module (api-utils.js) added, module (tab-browser.js) added, module (xpcom.js) added, module (list.js) added, module (utils/data.js) added, module (utils/thumbnail.js) added, module (utils/function.js) added, module (utils/registry.js) added, module (unit-test.js) added, module (xhr.js) added, module (content/loader.js) added, module (content/worker.js) added, module (content/symbiont.js) added, module (content/content-proxy.js) added, module (shims.js) added, module (e10s.js) added, module (text-streams.js) added, module (xul-app.js) added, module (cortex.js) added, module (url.js) added, module (runtime.js) added, module (observer-service.js) added, module (passwords/utils.js) added, module (byte-streams.js) added, module (memory.js) added, module (keyboard/hotkeys.js) added, module (keyboard/utils.js) added, module (keyboard/observer.js) added, module (file.js) added, module (windows/tabs.js) added, module (windows/dom.js) added, module (windows/observer.js) added, module (windows/loader.js) added, module (tabs/utils.js) added, module (tabs/events.js) added, module (tabs/tab.js) added, module (tabs/observer.js) added, module (content.js) added, module (events/assembler.js) added, module (preferences-service.js) added, module (timer.js) added, module (test.js) added, module (find-tests-e10s-adapter.js) added, module (array.js) added, module (type.js) added, module (traits/core.js) added, module (plain-text-console.js) added, module (timer-e10s-adapter.js) added, module (url-e10s-adapter.js) added, module (self-maker.js) added, module (light-traits.js) added, module (hidden-frame.js) added, module (match-pattern.js) added, attachment (test-content-symbiont.js) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 5, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": 4, 
      "name": "addon-kit", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 2, 
      "created_at": "2011-06-14 07:20:31", 
      "author": 1, 
      "full_name": "Addon Kit", 
      "module_main": "main", 
      "revision_number": 1, 
      "commit_message": "version changed, module (page-worker.js) added, module (hotkeys.js) added, module (private-browsing.js) added, module (page-mod.js) added, module (timers.js) added, module (tabs.js) added, module (selection.js) added, module (notifications.js) added, module (context-menu.js) added, module (request.js) added, module (panel.js) added, module (passwords.js) added, module (widget.js) added, module (windows.js) added, module (simple-storage.js) added, module (clipboard.js) added, attachment (test.html) added", 
      "version_name": null, 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 1, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": null, 
      "name": "api-utils", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 1, 
      "created_at": "2011-06-14 07:20:29", 
      "author": 1, 
      "full_name": "API Utils", 
      "module_main": "main", 
      "revision_number": 0, 
      "commit_message": "version changed", 
      "version_name": "1.0", 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 4, 
    "model": "jetpack.packagerevision", 
    "fields": {
      "origin": null, 
      "name": "addon-kit", 
      "contributors": "Atul Varma (http://toolness.com/) <atul@mozilla.com>, Myk Melez (http://melez.com/) <myk@mozilla.org>, Daniel Aquino <mr.danielaquino@gmail.com>", 
      "package": 2, 
      "created_at": "2011-06-14 07:20:30", 
      "author": 1, 
      "full_name": "Addon Kit", 
      "module_main": "main", 
      "revision_number": 0, 
      "commit_message": "version changed", 
      "version_name": "1.0", 
      "message": "", 
      "dependencies": [], 
      "sdk": null
    }
  }, 
  {
    "pk": 2, 
    "model": "jetpack.package", 
    "fields": {
      "public_key": null, 
      "private_key": null, 
      "name": "addon-kit", 
      "license": "", 
      "author": 1, 
      "id_number": "999999", 
      "lib_dir": null, 
      "deleted": false, 
      "jid": null, 
      "program_id": null, 
      "last_update": "2011-06-14 07:20:31", 
      "url": "", 
      "version": 4, 
      "full_name": "Addon Kit", 
      "active": true, 
      "version_name": "1.0", 
      "latest": 8, 
      "type": "l", 
      "created_at": "2011-06-14 07:20:30", 
      "public_permission": 2, 
      "description": "Add-on development made easy."
    }
  }, 
  {
    "pk": 1, 
    "model": "jetpack.package", 
    "fields": {
      "public_key": null, 
      "private_key": null, 
      "name": "api-utils", 
      "license": "", 
      "author": 1, 
      "id_number": "1000000", 
      "lib_dir": null, 
      "deleted": false, 
      "jid": null, 
      "program_id": null, 
      "last_update": "2011-06-14 07:20:30", 
      "url": "", 
      "version": 1, 
      "full_name": "API Utils", 
      "active": true, 
      "version_name": "1.0", 
      "latest": 3, 
      "type": "l", 
      "created_at": "2011-06-14 07:20:29", 
      "public_permission": 2, 
      "description": "Foundational infrastructure and utilities."
    }
  }, 
  {
    "pk": 18, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *   Edward Lee <edilee@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// The possible return values of getTypeOf.\nconst VALID_TYPES = [\n  \"array\",\n  \"boolean\",\n  \"function\",\n  \"null\",\n  \"number\",\n  \"object\",\n  \"string\",\n  \"undefined\",\n];\n\n/**\n * Returns a function C that creates instances of privateCtor.  C may be called\n * with or without the new keyword.  The prototype of each instance returned\n * from C is C.prototype, and C.prototype is an object whose prototype is\n * privateCtor.prototype.  Instances returned from C will therefore be instances\n * of both C and privateCtor.  Additionally, the constructor of each instance\n * returned from C is C.\n *\n * @param  privateCtor\n *         A constructor.\n * @return A function that makes new instances of privateCtor.\n */\nexports.publicConstructor = function publicConstructor(privateCtor) {\n  function PublicCtor() {\n    let obj = { constructor: PublicCtor, __proto__: PublicCtor.prototype };\n    memory.track(obj, privateCtor.name);\n    privateCtor.apply(obj, arguments);\n    return obj;\n  }\n  PublicCtor.prototype = { __proto__: privateCtor.prototype };\n  return PublicCtor;\n};\n\n/**\n * Returns a validated options dictionary given some requirements.  If any of\n * the requirements are not met, an exception is thrown.\n *\n * @param  options\n *         An object, the options dictionary to validate.  It's not modified.\n *         If it's null or otherwise falsey, an empty object is assumed.\n * @param  requirements\n *         An object whose keys are the expected keys in options.  Any key in\n *         options that is not present in requirements is ignored.  Each value\n *         in requirements is itself an object describing the requirements of\n *         its key.  There are four optional keys in this object:\n *           map: A function that's passed the value of the key in options.\n *                map's return value is taken as the key's value in the final\n *                validated options, is, and ok.  If map throws an exception\n *                it's caught and discarded, and the key's value is its value in\n *                options.\n *           is:  An array containing any number of the typeof type names.  If\n *                the key's value is none of these types, it fails validation.\n *                Arrays and null are identified by the special type names\n *                \"array\" and \"null\"; \"object\" will not match either.  No type\n *                coercion is done.\n *           ok:  A function that's passed the key's value.  If it returns\n *                false, the value fails validation.\n *           msg: If the key's value fails validation, an exception is thrown.\n *                This string will be used as its message.  If undefined, a\n *                generic message is used, unless is is defined, in which case\n *                the message will state that the value needs to be one of the\n *                given types.\n * @return An object whose keys are those keys in requirements that are also in\n *         options and whose values are the corresponding return values of map\n *         or the corresponding values in options.  Note that any keys not\n *         shared by both requirements and options are not in the returned\n *         object.\n */\nexports.validateOptions = function validateOptions(options, requirements) {\n  options = options || {};\n  let validatedOptions = {};\n  let mapThrew = false;\n\n  for (let [key, req] in Iterator(requirements)) {\n    let [optsVal, keyInOpts] = (key in options) ?\n                               [options[key], true] :\n                               [undefined, false];\n    if (req.map) {\n      try {\n        optsVal = req.map(optsVal);\n      }\n      catch (err) {\n        mapThrew = true;\n      }\n    }\n    if (req.is) {\n      // Sanity check the caller's type names.\n      req.is.forEach(function (typ) {\n        if (VALID_TYPES.indexOf(typ) < 0) {\n          let msg = 'Internal error: invalid requirement type \"' + typ + '\".';\n          throw new Error(msg);\n        }\n      });\n      if (req.is.indexOf(getTypeOf(optsVal)) < 0)\n        throw requirementError(key, req);\n    }\n    if (req.ok && !req.ok(optsVal))\n      throw requirementError(key, req);\n\n    if (keyInOpts || (req.map && !mapThrew))\n      validatedOptions[key] = optsVal;\n  }\n\n  return validatedOptions;\n};\n\nexports.addIterator = function addIterator(obj, keysValsGenerator) {\n  obj.__iterator__ = function(keysOnly, keysVals) {\n    let keysValsIterator = keysValsGenerator.call(this);\n\n    // \"for (.. in ..)\" gets only keys, \"for each (.. in ..)\" gets values,\n    // and \"for (.. in Iterator(..))\" gets [key, value] pairs.\n    let index = keysOnly ? 0 : 1;\n    while (true)\n      yield keysVals ? keysValsIterator.next() : keysValsIterator.next()[index];\n  };\n};\n\n// Similar to typeof, except arrays and null are identified by \"array\" and\n// \"null\", not \"object\".\nlet getTypeOf = exports.getTypeOf = function getTypeOf(val) {\n  let typ = typeof(val);\n  if (typ === \"object\") {\n    if (!val)\n      return \"null\";\n    if (Array.isArray(val))\n      return \"array\";\n  }\n  return typ;\n}\n\n// Returns a new Error with a nice message.\nfunction requirementError(key, requirement) {\n  let msg = requirement.msg;\n  if (!msg) {\n    msg = 'The option \"' + key + '\" ';\n    msg += requirement.is ?\n           \"must be one of the following types: \" + requirement.is.join(\", \") :\n           \"is invalid.\";\n  }\n  return new Error(msg);\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "api-utils"
    }
  }, 
  {
    "pk": 9, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is String Bundle.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst apiUtils = require(\"api-utils\");\n\n/**\n * A bundle of strings.\n *\n * @param url {String}\n *        the URL of the string bundle\n */\nexports.StringBundle = apiUtils.publicConstructor(function StringBundle(url) {\n\n  let stringBundle = Cc[\"@mozilla.org/intl/stringbundle;1\"].\n                     getService(Ci.nsIStringBundleService).\n                     createBundle(url);\n\n  this.__defineGetter__(\"url\", function () url);\n\n  /**\n   * Get a string from the bundle.\n   *\n   * @param name {String}\n   *        the name of the string to get\n   * @param args {array} [optional]\n   *        an array of arguments that replace occurrences of %S in the string\n   *\n   * @returns {String} the value of the string\n   */\n  this.get = function strings_get(name, args) {\n    try {\n      if (args)\n        return stringBundle.formatStringFromName(name, args, args.length);\n      else\n        return stringBundle.GetStringFromName(name);\n    }\n    catch(ex) {\n      // f.e. \"Component returned failure code: 0x80004005 (NS_ERROR_FAILURE)\n      // [nsIStringBundle.GetStringFromName]\"\n      throw new Error(\"String '\" + name + \"' could not be retrieved from the \" +\n                      \"bundle due to an unknown error (it doesn't exist?).\");\n    }\n  },\n\n  /**\n   * Iterate the strings in the bundle.\n   *\n   */\n  apiUtils.addIterator(\n    this,\n    function keysValsGen() {\n      let enumerator = stringBundle.getSimpleEnumeration();\n      while (enumerator.hasMoreElements()) {\n        let elem = enumerator.getNext().QueryInterface(Ci.nsIPropertyElement);\n        yield [elem.key, elem.value];\n      }\n    }\n  );\n});\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "app-strings"
    }
  }, 
  {
    "pk": 61, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\n/**\n * Returns `true` if given `array` contain given `element` or `false`\n * otherwise.\n * @param {Array} array\n *    Target array.\n * @param {Object|String|Number|Boolean} element\n *    Element being looked up.\n * @returns {Boolean}\n */\nvar has = exports.has = function has(array, element) {\n  // shorter and faster equivalent of `array.indexOf(element) >= 0`\n  return !!~array.indexOf(element);\n};\n\n/**\n * Adds given `element` to the given `array` if it does not contain it yet.\n * `true` is returned if element was added otherwise `false` is returned.\n * @param {Array} array\n *    Target array.\n * @param {Object|String|Number|Boolean} element\n *    Element to be added.\n * @returns {Boolean}\n */\nvar add = exports.add = function add(array, element) {\n  var result;\n  if ((result = !has(array, element)))\n    array.push(element);\n\n  return result;\n};\n\n/**\n * Removes first occurrence of the given `element` from the given `array`. If\n * `array` does not contain given `element` `false` is returned otherwise\n * `true` is returned.\n * @param {Array} array\n *    Target array.\n * @param {Object|String|Number|Boolean} element\n *    Element to be removed.\n * @returns {Boolean}\n */\nexports.remove = function remove(array, element) {\n  var result;\n  if ((result = has(array, element)))\n    array.splice(array.indexOf(element), 1);\n\n  return result;\n};\n\n/**\n * Produces a duplicate-free version of the given `array`.\n * @param {Array} array\n *    Source array.\n * @returns {Array}\n */\nexports.unique = function unique(array) {\n  var value = [];\n  return array.forEach(function(element) {\n    add(value, element);\n  });\n  return value;\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "array"
    }
  }, 
  {
    "pk": 41, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nexports.ByteReader = ByteReader;\nexports.ByteWriter = ByteWriter;\n\nconst {Cc, Ci} = require(\"chrome\");\n\n// This just controls the maximum number of bytes we read in at one time.\nconst BUFFER_BYTE_LEN = 0x8000;\n\nfunction ByteReader(inputStream) {\n  const self = this;\n\n  let stream = Cc[\"@mozilla.org/binaryinputstream;1\"].\n               createInstance(Ci.nsIBinaryInputStream);\n  stream.setInputStream(inputStream);\n\n  let manager = new StreamManager(this, stream);\n\n  this.read = function ByteReader_read(numBytes) {\n    manager.ensureOpened();\n    if (typeof(numBytes) !== \"number\")\n      numBytes = Infinity;\n\n    let data = \"\";\n    let read = 0;\n    try {\n      while (true) {\n        let avail = stream.available();\n        let toRead = Math.min(numBytes - read, avail, BUFFER_BYTE_LEN);\n        if (toRead <= 0)\n          break;\n        data += stream.readBytes(toRead);\n        read += toRead;\n      }\n    }\n    catch (err) {\n      throw new Error(\"Error reading from stream: \" + err);\n    }\n\n    return data;\n  };\n}\n\nfunction ByteWriter(outputStream) {\n  const self = this;\n\n  let stream = Cc[\"@mozilla.org/binaryoutputstream;1\"].\n               createInstance(Ci.nsIBinaryOutputStream);\n  stream.setOutputStream(outputStream);\n\n  let manager = new StreamManager(this, stream);\n\n  this.write = function ByteWriter_write(str) {\n    manager.ensureOpened();\n    try {\n      stream.writeBytes(str, str.length);\n    }\n    catch (err) {\n      throw new Error(\"Error writing to stream: \" + err);\n    }\n  };\n}\n\n\n// This manages the lifetime of stream, a ByteReader or ByteWriter.  It defines\n// closed and close() on stream and registers an unload listener that closes\n// rawStream if it's still opened.  It also provides ensureOpened(), which\n// throws an exception if the stream is closed.\nfunction StreamManager(stream, rawStream) {\n  const self = this;\n  this.rawStream = rawStream;\n  this.opened = true;\n\n  stream.__defineGetter__(\"closed\", function stream_closed() {\n    return !self.opened;\n  });\n\n  stream.close = function stream_close() {\n    self.ensureOpened();\n    self.unload();\n  };\n\n  require(\"unload\").ensure(this);\n}\n\nStreamManager.prototype = {\n  ensureOpened: function StreamManager_ensureOpened() {\n    if (!this.opened)\n      throw new Error(\"The stream is closed and cannot be used.\");\n  },\n  unload: function StreamManager_unload() {\n    this.rawStream.close();\n    this.opened = false;\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "byte-streams"
    }
  }, 
  {
    "pk": 87, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Paul O\u2019Shannessy <paul@oshannessy.com> (Original Author)\n *   Dietrich Ayala <dietrich@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\n \n/*\nWhile these data flavors resemble Internet media types, they do\nno directly map to them.\n*/\nconst kAllowableFlavors = [\n  \"text/unicode\",\n  \"text/html\"\n  /* CURRENTLY UNSUPPORTED FLAVORS\n  \"text/plain\",\n  \"image/png\",\n  \"image/jpg\",\n  \"image/gif\"\n  \"text/x-moz-text-internal\",\n  \"AOLMAIL\",\n  \"application/x-moz-file\",\n  \"text/x-moz-url\",\n  \"text/x-moz-url-data\",\n  \"text/x-moz-url-desc\",\n  \"text/x-moz-url-priv\",\n  \"application/x-moz-nativeimage\",\n  \"application/x-moz-nativehtml\",\n  \"application/x-moz-file-promise-url\",\n  \"application/x-moz-file-promise-dest-filename\",\n  \"application/x-moz-file-promise\",\n  \"application/x-moz-file-promise-dir\"\n  */\n];\n\n/*\nAliases for common flavors. Not all flavors will\nget an alias. New aliases must be approved by a\nJetpack API druid.\n*/\nconst kFlavorMap = [\n  { short: \"text\", long: \"text/unicode\" },\n  { short: \"html\", long: \"text/html\" }\n  // Images are currently unsupported.\n  //{ short: \"image\", long: \"image/png\" },\n];\n\nlet clipboardService = Cc[\"@mozilla.org/widget/clipboard;1\"].\n                       getService(Ci.nsIClipboard);\n\nlet clipboardHelper = Cc[\"@mozilla.org/widget/clipboardhelper;1\"].\n                      getService(Ci.nsIClipboardHelper);\n\n\nexports.set = function(aData, aDataType) {\n  let options = {\n    data: aData,\n    datatype: aDataType || \"text\"\n  };\n  options = apiUtils.validateOptions(options, {\n    data: {\n      is: [\"string\"]\n    },\n    datatype: {\n      is: [\"string\"]\n    }\n  });\n\n  var flavor = fromJetpackFlavor(options.datatype);\n\n  if (!flavor)\n    throw new Error(\"Invalid flavor\");\n\n  // Additional checks for using the simple case\n  if (flavor == \"text/unicode\") {\n    clipboardHelper.copyString(options.data);\n    return true;\n  }\n\n  // Below are the more complex cases where we actually have to work with a\n  // nsITransferable object\n  var xferable = Cc[\"@mozilla.org/widget/transferable;1\"].\n                 createInstance(Ci.nsITransferable);\n  if (!xferable)\n    throw new Error(\"Couldn't set the clipboard due to an internal error \" + \n                    \"(couldn't create a Transferable object).\");\n\n  switch (flavor) {\n    case \"text/html\":\n      var str = Cc[\"@mozilla.org/supports-string;1\"].\n                createInstance(Ci.nsISupportsString);\n      str.data = options.data;\n      xferable.addDataFlavor(flavor);\n      xferable.setTransferData(flavor, str, options.data.length * 2);\n      break;\n    // TODO: images!\n    // TODO: add a text/unicode flavor for HTML text that\n    // returns a plaintextified representation of the HTML.\n    default:\n      throw new Error(\"Unable to handle the flavor \" + flavor + \".\");\n  }\n\n  // TODO: Not sure if this will ever actually throw. -zpao\n  try {\n    clipboardService.setData(\n      xferable,\n      null,\n      clipboardService.kGlobalClipboard\n    );\n  } catch (e) {\n    throw new Error(\"Couldn't set clipboard data due to an internal error: \" + e);\n  }\n  return true;\n};\n\n\nexports.get = function(aDataType) {\n  let options = {\n    datatype: aDataType || \"text\"\n  };\n  options = apiUtils.validateOptions(options, {\n    datatype: {\n      is: [\"string\"]\n    }\n  });\n\n  var xferable = Cc[\"@mozilla.org/widget/transferable;1\"].\n                 createInstance(Ci.nsITransferable);\n  if (!xferable)\n    throw new Error(\"Couldn't set the clipboard due to an internal error \" + \n                    \"(couldn't create a Transferable object).\");\n\n  var flavor = fromJetpackFlavor(options.datatype);\n\n  // Ensure that the user hasn't requested a flavor that we don't support.\n  if (!flavor)\n    throw new Error(\"Getting the clipboard with the flavor '\" + flavor +\n                    \"' is > not supported.\");\n\n  // TODO: Check for matching flavor first? Probably not worth it.\n\n  xferable.addDataFlavor(flavor);\n\n  // Get the data into our transferable.\n  clipboardService.getData(\n    xferable,\n    clipboardService.kGlobalClipboard\n  );\n\n  var data = {};\n  var dataLen = {};\n  try {\n    xferable.getTransferData(flavor, data, dataLen);\n  } catch (e) {\n    // Clipboard doesn't contain data in flavor, return null.\n    return null;\n  }\n\n  // There's no data available, return.\n  if (data.value === null)\n    return null;\n\n  // TODO: Add flavors here as we support more in kAllowableFlavors.\n  switch (flavor) {\n    case \"text/unicode\":\n    case \"text/html\":\n      data = data.value.QueryInterface(Ci.nsISupportsString).data;\n      break;\n    default:\n      data = null;\n  }\n\n  return data;\n};\n\nexports.__defineGetter__(\"currentFlavors\", function() {\n  // Loop over kAllowableFlavors, calling hasDataMatchingFlavors for each.\n  // This doesn't seem like the most efficient way, but we can't get\n  // confirmation for specific flavors any other way. This is supposed to be\n  // an inexpensive call, so performance shouldn't be impacted (much).\n  var currentFlavors = [];\n  for each (var flavor in kAllowableFlavors) {\n    var matches = clipboardService.hasDataMatchingFlavors(\n      [flavor],\n      1,\n      clipboardService.kGlobalClipboard\n    );\n    if (matches)\n      currentFlavors.push(toJetpackFlavor(flavor));\n  }\n  return currentFlavors;\n});\n\n// SUPPORT FUNCTIONS ////////////////////////////////////////////////////////\n\nfunction toJetpackFlavor(aFlavor) {\n  for each (flavorMap in kFlavorMap)\n    if (flavorMap.long == aFlavor)\n      return flavorMap.short;\n  // Return null in the case where we don't match\n  return null;\n}\n\nfunction fromJetpackFlavor(aJetpackFlavor) {\n  // TODO: Handle proper flavors better\n  for each (flavorMap in kFlavorMap)\n    if (flavorMap.short == aJetpackFlavor || flavorMap.long == aJetpackFlavor)\n      return flavorMap.long;\n  // Return null in the case where we don't match.\n  return null;\n}\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "clipboard"
    }
  }, 
  {
    "pk": 6, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nexports.Collection = Collection;\n\n/**\n * Adds a collection property to the given object.  Setting the property to a\n * scalar value empties the collection and adds the value.  Setting it to an\n * array empties the collection and adds all the items in the array.\n *\n * @param obj\n *        The property will be defined on this object.\n * @param propName\n *        The name of the property.\n * @param array\n *        If given, this will be used as the collection's backing array.\n */\nexports.addCollectionProperty = function addCollProperty(obj, propName, array) {\n  array = array || [];\n  let publicIface = new Collection(array);\n\n  obj.__defineSetter__(propName, function (itemOrItems) {\n    array.splice(0, array.length);\n    publicIface.add(itemOrItems);\n  });\n\n  obj.__defineGetter__(propName, function () {\n    return publicIface;\n  });\n};\n\n/**\n * A collection is ordered, like an array, but its items are unique, like a set.\n *\n * @param array\n *        The collection is backed by an array.  If this is given, it will be\n *        used as the backing array.  This way the caller can fully control the\n *        collection.  Otherwise a new empty array will be used, and no one but\n *        the collection will have access to it.\n */\nfunction Collection(array) {\n  array = array || [];\n\n  /**\n   * Provides iteration over the collection.  Items are yielded in the order\n   * they were added.\n   */\n  this.__iterator__ = function Collection___iterator__() {\n    let items = array.slice();\n    for (let i = 0; i < items.length; i++)\n      yield items[i];\n  };\n\n  /**\n   * The number of items in the collection.\n   */\n  this.__defineGetter__(\"length\", function Collection_get_length() {\n    return array.length;\n  });\n\n  /**\n   * Adds a single item or an array of items to the collection.  Any items\n   * already contained in the collection are ignored.\n   *\n   * @param  itemOrItems\n   *         An item or array of items.\n   * @return The collection.\n   */\n  this.add = function Collection_add(itemOrItems) {\n    let items = toArray(itemOrItems);\n    for (let i = 0; i < items.length; i++) {\n      let item = items[i];\n      if (array.indexOf(item) < 0)\n        array.push(item);\n    }\n    return this;\n  };\n\n  /**\n   * Removes a single item or an array of items from the collection.  Any items\n   * not contained in the collection are ignored.\n   *\n   * @param  itemOrItems\n   *         An item or array of items.\n   * @return The collection.\n   */\n  this.remove = function Collection_remove(itemOrItems) {\n    let items = toArray(itemOrItems);\n    for (let i = 0; i < items.length; i++) {\n      let idx = array.indexOf(items[i]);\n      if (idx >= 0)\n        array.splice(idx, 1);\n    }\n    return this;\n  };\n};\n\nfunction toArray(itemOrItems) {\n  let isArr = itemOrItems &&\n              itemOrItems.constructor &&\n              itemOrItems.constructor.name === \"Array\";\n  return isArr ? itemOrItems : [itemOrItems];\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "collection"
    }
  }, 
  {
    "pk": 55, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nexports.Loader = require('content/loader').Loader;\nexports.Symbiont = require('content/symbiont').Symbiont;\nexports.Worker = require('content/worker').Worker;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "content"
    }
  }, 
  {
    "pk": 31, 
    "model": "jetpack.module", 
    "fields": {
      "code": "const { Ci, Cc } = require(\"chrome\");\n\n/*\n * Access key that allows privileged code to unwrap proxy wrappers through \n * valueOf:\n *   let xpcWrapper = proxyWrapper.valueOf(UNWRAP_ACCESS_KEY);\n */\nconst UNWRAP_ACCESS_KEY = {};\nexports.UNWRAP_ACCESS_KEY = UNWRAP_ACCESS_KEY;\n\n /**\n * Returns a closure that wraps arguments before calling the given function,\n * which can be given to native functions that accept a function, such that when\n * the closure is called, the given function is called with wrapped arguments.\n *\n * @param fun {Function}\n *        the function for which to create a closure wrapping its arguments\n * @param obj {Object}\n *        target object from which `fun` comes from\n *        (optional, for debugging purpose)\n * @param name {String}\n *        name of the attribute from which `fun` is binded on `obj`\n *        (optional, for debugging purpose)\n *\n * Example:\n *   function contentScriptListener(event) {}\n *   let wrapper = ContentScriptFunctionWrapper(contentScriptListener);\n *   xray.addEventListener(\"...\", wrapper, false);\n * -> Allow to `event` to be wrapped\n */\nfunction ContentScriptFunctionWrapper(fun, obj, name) {\n  if (\"___proxy\" in fun && typeof fun.___proxy == \"function\")\n    return fun.___proxy;\n  \n  let wrappedFun = function () {\n    let args = [];\n    for (let i = 0, l = arguments.length; i < l; i++)\n      args.push(wrap(arguments[i]));\n    \n    //console.log(\"Called from native :\"+obj+\".\"+name);\n    //console.log(\">args \"+arguments.length);\n    //console.log(fun);\n    \n    // Native code can execute this callback with `this` being the wrapped \n    // function. For example, window.mozRequestAnimationFrame.\n    if (this == wrappedFun)\n      return fun.apply(fun, args);\n    \n    return fun.apply(wrap(this), args);\n  };\n  \n  Object.defineProperty(fun, \"___proxy\", {value : wrappedFun,\n                                          writable : false,\n                                          enumerable : false,\n                                          configurable : true});\n  \n  return wrappedFun;\n}\n\n/**\n * Returns a closure that unwraps arguments before calling the `fun` function,\n * which can be used to build a wrapper for a native function that accepts\n * wrapped arguments, since native function only accept unwrapped arguments.\n *\n * @param fun {Function}\n *        the function to wrap\n * @param originalObject {Object}\n *        target object from which `fun` comes from\n *        (optional, for debugging purpose)\n * @param name {String}\n *        name of the attribute from which `fun` is binded on `originalObject`\n *        (optional, for debugging purpose)\n *\n * Example:\n *   wrapper.appendChild = NativeFunctionWrapper(xray.appendChild, xray);\n *   wrapper.appendChild(anotherWrapper);\n * -> Allow to call xray.appendChild with unwrapped version of anotherWrapper\n */\nfunction NativeFunctionWrapper(fun, originalObject, name) {\n  return function () {\n    let args = [];\n    let obj = this.valueOf ? this.valueOf(UNWRAP_ACCESS_KEY) : this;\n    \n    for (let i = 0, l = arguments.length; i < l; i++)\n      args.push( unwrap(arguments[i], obj, name) );\n    \n    //if (name != \"toString\")\n    //console.log(\">>calling native [\"+(name?name:'#closure#')+\"]: \\n\"+fun.apply+\"\\n\"+obj+\"\\n(\"+args.join(', ')+\")\\nthis :\"+obj+\"from:\"+originalObject+\"\\n\");\n    \n    // Need to use Function.prototype.apply.apply because XMLHttpRequest \n    // is a function (typeof return 'function') and fun.apply is null :/\n    let unwrapResult = Function.prototype.apply.apply(fun, [obj, args]);\n    let result = wrap(unwrapResult, obj, name);\n    \n    //console.log(\"<< \"+rr+\" -> \"+r);\n    \n    return result;\n  };\n}\n\n/*\n * Unwrap a JS value that comes from the content script.\n * Mainly converts proxy wrapper to XPCNativeWrapper.\n */\nfunction unwrap(value, obj, name) {\n  //console.log(\"unwrap : \"+value+\" (\"+name+\")\");\n  if (!value)\n    return value;\n  let type = typeof value;  \n  \n  // In case of proxy, unwrap them recursively \n  // (it should not be recursive, just in case of)\n  if ([\"object\", \"function\"].indexOf(type) !== -1 && \n      \"__isWrappedProxy\" in value) {\n    while(\"__isWrappedProxy\" in value)\n      value = value.valueOf(UNWRAP_ACCESS_KEY);\n    return value;\n  }\n  \n  // In case of functions we need to return a wrapper that converts native \n  // arguments applied to this function into proxies.\n  // Do this only for functions coming from content script.\n  if (type == \"function\")\n    return ContentScriptFunctionWrapper(value, obj, name);\n  \n  if ([\"string\", \"number\", \"boolean\"].indexOf(type) !== -1)\n    return value;\n  //console.log(\"return non-wrapped to native : \"+typeof value+\" -- \"+value);\n  return value;\n}\n\n/*\n * Wrap a JS value coming from the document by building a proxy wrapper.\n */\nfunction wrap(value, obj, name, debug) {\n  if (!value)\n    return value;\n  let type = typeof value;\n  if (type == \"object\") {\n    // In case of: unwrap object before wrapping it\n    // (it should not happen)\n    while(\"__isWrappedProxy\" in value) {\n      console.trace();\n      console.warn(\"This object is already wrapped: \" + value + \n                   \" (accessed from attribute \" + name + \")\");\n      value = value.valueOf(UNWRAP_ACCESS_KEY);\n    }\n    if (XPCNativeWrapper.unwrap(value) !== value)\n      return getProxyForObject(value);\n    // In case of Event, HTMLCollection or NodeList or ???\n    // XPCNativeWrapper.unwrap(value) === value\n    // but it's still a XrayWrapper so let's build a proxy\n    return getProxyForObject(value);\n  }\n  if (type == \"function\") {\n    if (XPCNativeWrapper.unwrap(value) !== value\n        || (typeof value.toString === \"function\" && \n            value.toString().match(/\\[native code\\]/))) {\n      return getProxyForFunction(value, NativeFunctionWrapper(value, obj, name));\n    }\n    return value;\n  }\n  if (type == \"string\")\n    return value;\n  if (type == \"number\")\n    return value;\n  if (type == \"boolean\")\n    return value;\n  //console.log(\"return non-wrapped to wrapped : \"+value);\n  return value;\n}\n\n/* \n * Wrap an object from the document to a proxy wrapper\n */\nfunction getProxyForObject(obj) {\n  if (typeof obj != \"object\") {\n    let msg = \"tried to proxify something other than an object: \" + typeof obj;\n    console.warn(msg);\n    throw msg;\n  }\n  if (\"__isWrappedProxy\" in obj) {\n    return obj;\n  }\n  // Check if there is a proxy cached on this wrapper,\n  // but take care of prototype ___proxy attribute inheritance!\n  if (obj && obj.___proxy && obj.___proxy.valueOf(UNWRAP_ACCESS_KEY) === obj) {\n    return obj.___proxy;\n  }\n  \n  let proxy = Proxy.create(handlerMaker(obj));\n  \n  Object.defineProperty(obj, \"___proxy\", {value : proxy,\n                                          writable : true,\n                                          enumerable : false,\n                                          configurable : true});\n  return proxy;\n}\n\n/* \n * Wrap a function from the document to a proxy wrapper\n */\nfunction getProxyForFunction(fun, callTrap) {\n  if (typeof fun != \"function\") {\n    let msg = \"tried to proxify something other than a function: \" + typeof fun;\n    console.warn(msg);\n    throw msg;\n  }\n  if (\"__isWrappedProxy\" in fun)\n    return obj;\n  if (\"___proxy\" in fun)\n    return fun.___proxy;\n  \n  let proxy = Proxy.createFunction(handlerMaker(fun), callTrap);\n  \n  Object.defineProperty(fun, \"___proxy\", {value : proxy,\n                                          writable : false,\n                                          enumerable : false,\n                                          configurable : false});\n  \n  return proxy;\n}\n\n/* \n * Check if a DOM attribute name is an event name.\n */\nfunction isEventName(id) {\n  if (id.indexOf(\"on\") != 0 || id.length == 2) \n    return false;\n  // Taken from:\n  // http://mxr.mozilla.org/mozilla-central/source/dom/base/nsDOMClassInfo.cpp#7616\n  switch (id[2]) {\n    case 'a' :\n      return (id == \"onabort\" ||\n              id == \"onafterscriptexecute\" ||\n              id == \"onafterprint\");\n    case 'b' :\n      return (id == \"onbeforeunload\" ||\n              id == \"onbeforescriptexecute\" ||\n              id == \"onblur\" ||\n              id == \"onbeforeprint\");\n    case 'c' :\n      return (id == \"onchange\"       ||\n              id == \"onclick\"        ||\n              id == \"oncontextmenu\"  ||\n              id == \"oncopy\"         ||\n              id == \"oncut\"          ||\n              id == \"oncanplay\"      ||\n              id == \"oncanplaythrough\");\n    case 'd' :\n      return (id == \"ondblclick\"     || \n              id == \"ondrag\"         ||\n              id == \"ondragend\"      ||\n              id == \"ondragenter\"    ||\n              id == \"ondragleave\"    ||\n              id == \"ondragover\"     ||\n              id == \"ondragstart\"    ||\n              id == \"ondrop\"         ||\n              id == \"ondurationchange\");\n    case 'e' :\n      return (id == \"onerror\" ||\n              id == \"onemptied\" ||\n              id == \"onended\");\n    case 'f' :\n      return id == \"onfocus\";\n    case 'h' :\n      return id == \"onhashchange\";\n    case 'i' :\n      return (id == \"oninput\" ||\n              id == \"oninvalid\");\n    case 'k' :\n      return (id == \"onkeydown\"      ||\n              id == \"onkeypress\"     ||\n              id == \"onkeyup\");\n    case 'l' :\n      return (id == \"onload\"           ||\n              id == \"onloadeddata\"     ||\n              id == \"onloadedmetadata\" ||\n              id == \"onloadstart\");\n    case 'm' :\n      return (id == \"onmousemove\"    ||\n              id == \"onmouseout\"     ||\n              id == \"onmouseover\"    ||\n              id == \"onmouseup\"      ||\n              id == \"onmousedown\"    ||\n              id == \"onmessage\");\n    case 'p' :\n      return (id == \"onpaint\"        ||\n              id == \"onpageshow\"     ||\n              id == \"onpagehide\"     ||\n              id == \"onpaste\"        ||\n              id == \"onpopstate\"     ||\n              id == \"onpause\"        ||\n              id == \"onplay\"         ||\n              id == \"onplaying\"      ||\n              id == \"onprogress\");\n    case 'r' :\n      return (id == \"onreadystatechange\" ||\n              id == \"onreset\"            ||\n              id == \"onresize\"           ||\n              id == \"onratechange\");\n    case 's' :\n      return (id == \"onscroll\"       ||\n              id == \"onselect\"       ||\n              id == \"onsubmit\"       || \n              id == \"onseeked\"       ||\n              id == \"onseeking\"      ||\n              id == \"onstalled\"      ||\n              id == \"onsuspend\");\n    case 't':\n      return id == \"ontimeupdate\" \n      /* \n        // TODO: Make it work for mobile version\n        ||\n        (nsDOMTouchEvent::PrefEnabled() &&\n         (id == \"ontouchstart\" ||\n          id == \"ontouchend\" ||\n          id == \"ontouchmove\" ||\n          id == \"ontouchenter\" ||\n          id == \"ontouchleave\" ||\n          id == \"ontouchcancel\"))*/;\n      \n    case 'u' :\n      return id == \"onunload\";\n    case 'v':\n      return id == \"onvolumechange\";\n    case 'w':\n      return id == \"onwaiting\";\n    }\n  \n  return false;\n}\n\n\n/* \n * Generate handler for proxy wrapper\n */\nfunction handlerMaker(obj) {\n  // Overloaded attributes dictionary\n  let overload = {};\n  // Expando attributes dictionary (i.e. onclick, onfocus, on* ...)\n  let expando = {};\n  return {\n    // Fundamental traps\n    getPropertyDescriptor:  function(name) {\n      return Object.getOwnPropertyDescriptor(obj, name);\n    },\n    defineProperty: function(name, desc) {\n      return Object.defineProperty(obj, name, desc);\n    },\n    getOwnPropertyNames: function () {\n      return Object.getOwnPropertyNames(obj);\n    },\n    delete: function(name) {\n      delete expando[name];\n      delete overload[name];\n      return delete obj[name];\n    },\n    \n    // derived traps\n    has: function(name) {\n      if (name == \"___proxy\") return false;\n      if (isEventName(name)) {\n        // XrayWrappers throw exception when we try to access expando attributes\n        // even on \"name in wrapper\". So avoid doing it!\n        return name in expando;\n      }\n      return name in obj || name in overload || name == \"__isWrappedProxy\";\n    },\n    hasOwn: function(name) {\n      return Object.prototype.hasOwnProperty.call(obj, name);\n    },\n    get: function(receiver, name) {\n      \n      if (name == \"___proxy\")\n        return undefined;\n      \n      // Overload toString in order to avoid returning \"[XrayWrapper [object HTMLElement]]\"\n      // or \"[object Function]\" for function's Proxy\n      if (name == \"toString\")\n        return wrap(obj.wrappedJSObject ? obj.wrappedJSObject.toString\n                                        : obj.toString,\n                    obj, name);\n      \n      // Offer a way to retrieve XrayWrapper from a proxified node through `valueOf`\n      if (name == \"valueOf\")\n        return function (key) {\n          if (key === UNWRAP_ACCESS_KEY)\n            return obj;\n          return this;\n        };\n      \n      // Return overloaded value if there is one.\n      // It allows to overload native methods like addEventListener that\n      // are not saved, even on the wrapper itself.\n      // (And avoid some methods like toSource from being returned here! [__proto__ test])\n      if (name in overload && overload[name] != overload.__proto__[name] && name != \"__proto__\") {\n        return overload[name];\n      }\n      \n      // Catch exceptions thrown by XrayWrappers when we try to access on* \n      // attributes like onclick, onfocus, ...\n      if (isEventName(name)) {\n        //console.log(\"expando:\"+obj+\" - \"+obj.nodeType);\n        return name in expando ? expando[name].original : undefined;\n      }\n      \n      let o = obj[name];\n      \n      // Fix bug with XPCNativeWrapper on HTMLCollection\n      // We can only access array item once, then it's undefined :o\n      let i = parseInt(name)\n      if (!o && obj.toString().match(/HTMLCollection|NodeList/) && i >= 0 && i < obj.length) {\n        o = XPCNativeWrapper(obj.wrappedJSObject[name]);\n      }\n      \n      // Trap access to document[\"form name\"] \n      // that may refer to an existing form node\n      // http://mxr.mozilla.org/mozilla-central/source/dom/base/nsDOMClassInfo.cpp#9285\n      if (!o && \"nodeType\" in obj && obj.nodeType == 9) {\n        let node = obj.wrappedJSObject[name];\n        // List of supported tag:\n        // http://mxr.mozilla.org/mozilla-central/source/content/html/content/src/nsGenericHTMLElement.cpp#1267\n        if (node && [\"IMG\", \"FORM\", \"APPLET\", \"EMBED\", \"OBJECT\"].indexOf(node.tagName) != -1)\n          return wrap(XPCNativeWrapper(node));\n      }\n      \n      // Trap access to window[\"frame name\"]\n      // that refer to an (i)frame node\n      // http://mxr.mozilla.org/mozilla-central/source/dom/base/nsDOMClassInfo.cpp#6824\n      if (!o && typeof obj == \"object\" && \"document\" in obj) {\n        try {\n          obj.QueryInterface(Ci.nsIDOMWindow);\n          let win = obj.wrappedJSObject[name];\n          let nodes = obj.document.getElementsByName(name);\n          for (let i = 0, l = nodes.length; i < l; i++) {\n            let node = nodes[i];\n            if (\"contentWindow\" in node && node.contentWindow.wrappedJSObject == win)\n              return wrap(node.contentWindow);\n          }\n        }\n        catch(e) {}\n      }\n      \n      // Trap access to form[\"node name\"]\n      // http://mxr.mozilla.org/mozilla-central/source/dom/base/nsDOMClassInfo.cpp#9477\n      if (!o && typeof obj == \"object\" && obj.tagName == \"FORM\") {\n        let match = obj.wrappedJSObject[name];\n        let nodes = obj.ownerDocument.getElementsByName(name);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          if (node.wrappedJSObject == match)\n            return wrap(node);\n        }\n      }\n      \n      // Fix mozMatchesSelector uses that is broken on XrayWrappers\n      // when we use document.documentElement.mozMatchesSelector.call(node, expr)\n      // It's only working if we call mozMatchesSelector on the node itself.\n      // SEE BUG 658909: mozMatchesSelector returns incorrect results with XrayWrappers\n      if (typeof o == \"function\" && name == \"mozMatchesSelector\") {\n        // We can't use `wrap` function as `f` is not a native function,\n        // so wrap it manually:\n        let f = function mozMatchesSelector(selectors) {\n          return this.mozMatchesSelector(selectors);\n        };\n        return getProxyForFunction(f, NativeFunctionWrapper(f));\n      }\n      \n      // Generic case\n      return wrap(o, obj, name);\n      \n    },\n    \n    set: function(receiver, name, val) {\n      \n      if (isEventName(name)) {\n        //console.log(\"SET on* attribute : \" + name + \" / \" + val + \"/\" + obj);\n        let shortName = name.replace(/^on/,\"\");\n        \n        // Unregister previously set listener\n        if (expando[name]) {\n          obj.removeEventListener(shortName, expando[name], true);\n          delete expando[name];\n        }\n        \n        // Only accept functions\n        if (typeof val != \"function\")\n          return false;\n        \n        // Register a new listener\n        let original = val;\n        val = ContentScriptFunctionWrapper(val);\n        expando[name] = val;\n        val.original = original;\n        obj.addEventListener(name.replace(/^on/, \"\"), val, true);\n        return true;\n      }\n      \n      obj[name] = val;\n      \n      // Handle native method not overloaded on XrayWrappers:\n      //   obj.addEventListener = val; -> obj.addEventlistener = native method\n      // And, XPCNativeWrapper bug where nested values appear to be wrapped:\n      // obj.customNestedAttribute = val -> obj.customNestedAttribute !== val\n      //                                    obj.customNestedAttribute = \"waive wrapper something\"\n      // SEE BUG 658560: Fix identity problem with CrossOriginWrappers\n      // TODO: check that DOM can't be updated by the document itself and so overloaded value becomes wrong\n      //       but I think such behavior is limited to primitive type\n      if ((typeof val == \"function\" || typeof val == \"object\") && name) {\n        overload[name] = val;\n      }\n      \n      return true;\n    },\n    \n    enumerate: function() {\n      var result = [];\n      for each (name in Object.keys(obj)) {\n        result.push(name);\n      };\n      return result;\n    },\n    \n    keys: function() {\n      return Object.keys(obj);\n    }\n  };\n};\n\n\n/* \n * Wrap an object from the document to a proxy wrapper.\n */\nexports.create = function create(object) {\n  let xpcWrapper = XPCNativeWrapper(object);\n  return getProxyForObject(xpcWrapper);\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "content/content-proxy"
    }
  }, 
  {
    "pk": 28, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { EventEmitter } = require('events');\nconst { validateOptions, getTypeOf } = require('api-utils');\nconst { URL, toFilename } = require('url');\nconst file = require(\"file\");\n\n// map of property validations\nconst valid = {\n  contentURL: {\n    ok: function (value) {\n      try {\n        URL(value);\n      }\n      catch(e) {\n        return false;\n      }\n      return true;\n    },\n    msg: 'The `contentURL` option must be a valid URL.'\n  },\n  contentScriptFile: {\n    is: ['undefined', 'null', 'string', 'array'],\n    map: function(value) 'undefined' === getTypeOf(value) ? null : value,\n    ok: function(value) {\n      if (getTypeOf(value) === 'array') {\n        // Make sure every item is a local file URL.\n        return value.every(function (item) {\n          try {\n            toFilename(item);\n            return true;\n          }\n          catch(e) {\n            return false;\n          }\n        });\n      }\n      return true;\n    },\n    msg: 'The `contentScriptFile` option must be a local file URL or an array of'\n          + 'URLs.'\n  },\n  contentScript: {\n    is: ['undefined', 'null', 'string', 'array'],\n    map: function(value) 'undefined' === getTypeOf(value) ? null : value,\n    ok: function(value) 'array' !== getTypeOf(value) ? true :\n      value.every(function(item) 'string' === getTypeOf(item))\n    ,\n    msg: 'The script option must be a string or an array of strings.'\n  },\n  contentScriptWhen: {\n    is: ['string'],\n    ok: function(value) ['start', 'ready', 'end'].indexOf(value) >= 0,\n    map: function(value) { \n      return value || 'end';\n    },\n    msg: 'The `contentScriptWhen` option must be either \"start\", \"ready\" or \"end\".'\n  }\n};\nexports.validationAttributes = valid;\n\n/**\n * Shortcut function to validate property with validation.\n * @param {Object|Number|String} suspect\n *    value to validate\n * @param {Object} validation\n *    validation rule passed to `api-utils`\n */\nfunction validate(suspect, validation) validateOptions(\n  { $: suspect },\n  { $: validation }\n).$\n\nfunction Allow(script) ({\n  get script() script,\n  set script(value) script = !!value\n})\n\n/**\n * Trait is intended to be used in some composition. It provides set of core\n * properties and bounded validations to them. Trait is useful for all the\n * compositions providing high level APIs for interaction with content.\n * Property changes emit `\"propertyChange\"` events on instances.\n */\nconst Loader = EventEmitter.compose({\n  /**\n   * Permissions for the content, with the following keys:\n   * @property {Object} [allow = { script: true }]\n   * @property {Boolean} [allow.script = true]\n   *    Whether or not to execute script in the content.  Defaults to true.\n   */\n  get allow() this._allow || (this._allow = Allow(true)),\n  set allow(value) this.allow.script = value && value.script,\n  _allow: null,\n  /**\n   * The content to load. Either a string of HTML or a URL.\n   * @type {String}\n   */\n  get contentURL() this._contentURL,\n  set contentURL(value) {\n    value = validate(value, valid.contentURL);\n    if (this._contentURL != value) {\n      this._emit('propertyChange', {\n        contentURL: this._contentURL = value\n      });\n    }\n  },\n  _contentURL: null,\n  /**\n   * When to load the content scripts.\n   * Possible values are \"end\" (default), which loads them once all page \n   * contents have been loaded, \"ready\", which loads them once DOM nodes are \n   * ready (ie like DOMContentLoaded event), and \"start\", which loads them once \n   * the `window` object for the page has been created, but before any scripts \n   * specified by the page have been loaded.\n   * Property change emits `propertyChange` event on instance with this key\n   * and new value.\n   * @type {'start'|'ready'|'end'}\n   */\n  get contentScriptWhen() this._contentScriptWhen,\n  set contentScriptWhen(value) {\n    value = validate(value, valid.contentScriptWhen);\n    if (value !== this._contentScriptWhen) {\n      this._emit('propertyChange', { \n        contentScriptWhen: this._contentScriptWhen = value \n      });\n    }\n  },\n  _contentScriptWhen: 'end',\n  /**\n   * The URLs of content scripts.\n   * Property change emits `propertyChange` event on instance with this key\n   * and new value.\n   * @type {String[]}\n   */\n  get contentScriptFile() this._contentScriptFile,\n  set contentScriptFile(value) {\n    value = validate(value, valid.contentScriptFile);\n    if (value != this._contentScriptFile) {\n      this._emit('propertyChange', { \n        contentScriptFile: this._contentScriptFile = value\n      });\n    }\n  },\n  _contentScriptFile: null,\n  /**\n   * The texts of content script.\n   * Property change emits `propertyChange` event on instance with this key\n   * and new value.\n   * @type {String|undefined}\n   */\n  get contentScript() this._contentScript,\n  set contentScript(value) {\n    value = validate(value, valid.contentScript);\n    if (value != this._contentScript) {\n      this._emit('propertyChange', {\n        contentScript: this._contentScript = value \n      });\n    }\n  },\n  _contentScript: null\n});\nexports.Loader = Loader;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "content/loader"
    }
  }, 
  {
    "pk": 30, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Worker } = require('./worker');\nconst { Loader } = require('./loader');\nconst hiddenFrames = require(\"hidden-frame\");\nconst observers = require('observer-service');\nconst unload = require(\"unload\");\n\n/**\n * This trait is layered on top of `Worker` and in contrast to symbiont\n * Worker constructor requires `content` option that represents content\n * that will be loaded in the provided frame, if frame is not provided\n * Worker will create hidden one.\n */\nconst Symbiont = Worker.resolve({\n    constructor: '_initWorker',\n    destroy: '_workerDestroy'\n  }).compose(Loader, {\n  \n  /**\n   * The constructor requires all the options that are required by\n   * `require('content').Worker` with the difference that the `frame` option\n   * is optional. If `frame` is not provided, `contentURL` is expected.\n   * @param {Object} options\n   * @param {String} options.contentURL\n   *    URL of a content to load into `this._frame` and create worker for.\n   * @param {Element} [options.frame]\n   *    iframe element that is used to load `options.contentURL` into.\n   *    if frame is not provided hidden iframe will be created.\n   */\n  constructor: function Symbiont(options) {\n    options = options || {};\n\n    if ('contentURL' in options)\n        this.contentURL = options.contentURL;\n    if ('contentScriptWhen' in options)\n      this.contentScriptWhen = options.contentScriptWhen;\n    if ('contentScriptFile' in options)\n      this.contentScriptFile = options.contentScriptFile;\n    if ('contentScript' in options)\n      this.contentScript = options.contentScript;\n    if ('allow' in options)\n      this.allow = options.allow;\n    if ('onError' in options)\n        this.on('error', options.onError);\n    if ('onMessage' in options)\n        this.on('message', options.onMessage);\n    if ('frame' in options) {\n      this._initFrame(options.frame);\n    }\n    else {\n      let self = this;\n      this._hiddenFrame = hiddenFrames.HiddenFrame({\n        onReady: function onFrame() {\n          self._initFrame(this.element);\n        }\n      });\n      hiddenFrames.add(this._hiddenFrame);\n    }\n\n    unload.ensure(this._public, \"destroy\");\n  },\n  \n  destroy: function destroy() {\n    this._workerDestroy();\n    this._unregisterListener();\n    this._frame = null;\n    if (this._hiddenFrame) {\n      hiddenFrames.remove(this._hiddenFrame);\n      this._hiddenFrame = null;\n    }\n  },\n  \n  /**\n   * XUL iframe or browser elements with attribute `type` being `content`.\n   * Used to create `ContentSymbiont` from.\n   * @type {nsIFrame|nsIBrowser}\n   */\n  _frame: null,\n  \n  /**\n   * Listener to the `'frameReady\"` event (emitted when `iframe` is ready).\n   * Removes listener, sets right permissions to the frame and loads content.\n   */\n  _initFrame: function _initFrame(frame) {\n    if (this._loadListener)\n      this._unregisterListener();\n    \n    this._frame = frame;\n    frame.docShell.allowJavascript = this.allow.script;\n    frame.setAttribute(\"src\", this._contentURL);\n    \n    if ((frame.contentDocument.readyState == \"complete\" ||\n        (frame.contentDocument.readyState == \"interactive\" &&\n         this.contentScriptWhen != 'end' )) &&\n        frame.contentDocument.location == this._contentURL) {\n      // In some cases src doesn't change and document is already ready\n      // (for ex: when the user moves a widget while customizing toolbars.)\n      this._onInit();\n      return;\n    }\n    \n    let self = this;\n    \n    if ('start' == this.contentScriptWhen) {\n      this._loadEvent = 'start';\n      observers.add('document-element-inserted', \n        this._loadListener = function onStart(doc) {\n          \n          let window = doc.defaultView;\n          if (window && window == frame.contentWindow) {\n            self._unregisterListener();\n            self._onInit();\n          }\n          \n        });\n      return;\n    }\n    \n    let eventName = 'end' == this.contentScriptWhen ? 'load' : 'DOMContentLoaded';\n    let self = this;\n    this._loadEvent = eventName;\n    frame.addEventListener(eventName, \n      this._loadListener = function _onReady(event) {\n      \n        if (event.target != frame.contentDocument)\n          return;\n        self._unregisterListener();\n        \n        self._onInit();\n        \n      }, true);\n    \n  },\n  \n  /**\n   * Unregister listener that watchs for document being ready to be injected.\n   * This listener is registered in `Symbiont._initFrame`.\n   */\n  _unregisterListener: function _unregisterListener() {\n    if (!this._loadListener)\n      return;\n    if (this._loadEvent == \"start\") {\n      observers.remove('document-element-inserted', this._loadListener);\n    }\n    else {\n      this._frame.removeEventListener(this._loadEvent, this._loadListener,\n                                      true);\n    }\n    this._loadListener = null;\n  },\n  \n  /**\n   * Called by Symbiont itself when the frame is ready to load  \n   * content scripts according to contentScriptWhen. Overloaded by Panel. \n   */\n  _onInit: function () {\n    this._initWorker({ window: this._frame.contentWindow.wrappedJSObject });\n  }\n  \n});\nexports.Symbiont = Symbiont;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "content/symbiont"
    }
  }, 
  {
    "pk": 29, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { shims } = require('cuddlefish');\nconst { Trait } = require('traits');\nconst { EventEmitter, EventEmitterTrait } = require('events');\nconst { Ci, Cu, Cc } = require('chrome');\nconst timer = require('timer');\nconst { toFilename } = require('url');\nconst file = require('file');\nconst unload = require('unload');\nconst observers = require(\"observer-service\");\nconst { Cortex } = require('cortex');\nconst { Enqueued } = require('utils/function');\nconst proxy = require('content/content-proxy');\n\nconst JS_VERSION = '1.8';\n\nconst ERR_DESTROYED =\n  \"The page has been destroyed and can no longer be used.\";\n\n/**\n * Extended `EventEmitter` allowing us to emit events asynchronously.\n */\nconst AsyncEventEmitter = EventEmitter.compose({\n  /**\n   * Emits event in the next turn of event loop.\n   */\n  _asyncEmit: function _asyncEmit() {\n    timer.setTimeout(function emitter(emit, scope, params) {\n      emit.apply(scope, params);\n    }, 0, this._emit, this, arguments)\n  }\n});\n\n/**\n * Local trait providing implementation of the workers global scope.\n * Used to configure global object in the sandbox.\n * @see http://www.w3.org/TR/workers/#workerglobalscope\n */\nconst WorkerGlobalScope = AsyncEventEmitter.compose({\n  on: Trait.required,\n  _removeAllListeners: Trait.required,\n\n  // wrapped functions from `'timer'` module.\n  // Wrapper adds `try catch` blocks to the callbacks in order to\n  // emit `error` event on a symbiont if exception is thrown in\n  // the Worker global scope.\n  // @see http://www.w3.org/TR/workers/#workerutils\n  setTimeout: function setTimeout(callback, delay) {\n    let params = Array.slice(arguments, 2);\n    return timer.setTimeout(function(worker) {\n      try {\n        callback.apply(null, params);\n      } catch(e) {\n        worker._asyncEmit('error', e);\n      }\n    }, delay, this._addonWorker);\n  },\n  clearTimeout: timer.clearTimeout,\n\n  setInterval: function setInterval(callback, delay) {\n    let params = Array.slice(arguments, 2);\n    return timer.setInterval(function(worker) {\n      try {\n        callback.apply(null, params); \n      } catch(e) {\n        worker._asyncEmit('error', e);\n      }\n    }, delay, this._addonWorker);\n  },\n  clearInterval: timer.clearInterval,\n\n  /**\n   * `onMessage` function defined in the global scope of the worker context.\n   */\n  get _onMessage() this.__onMessage,\n  set _onMessage(value) {\n    let listener = this.__onMessage;\n    if (listener && value !== listener) {\n      this.removeListener('message', listener);\n      this.__onMessage = undefined;\n    }\n    if (value)\n      this.on('message', this.__onMessage = value);\n  },\n  __onMessage: undefined,\n\n  /**\n   * Function for sending data to the addon side.\n   * Validates that data is a `JSON` or primitive value and emits\n   * 'message' event on the worker in the next turn of the event loop.\n   * _Later this will be sending data across process boundaries._\n   * @param {JSON|String|Number|Boolean} data\n   */\n  postMessage: function postMessage(data) {\n    if (!this._addonWorker)\n      throw new Error(ERR_DESTROYED);\n    this._addonWorker._asyncEmit('message',  \n                                      JSON.parse(JSON.stringify(data)));\n  },\n  \n  /**\n   * EventEmitter, that behaves (calls listeners) asynchronously.\n   * A way to send customized messages to / from the worker.\n   * Events from in the worker can be observed / emitted via self.on / self.emit \n   */\n  get port() this._port._public,\n  \n  /**\n   * Same object than this.port but private API.\n   * Allow access to _asyncEmit, in order to send event to port.\n   */\n  _port: null,\n\n  /**\n   * Alias to the global scope in the context of worker. Similar to\n   * `window` concept.\n   */\n  get self() this._public,\n\n  /**\n   * Configures sandbox and loads content scripts into it.\n   * @param {Worker} worker\n   *    content worker\n   */\n  constructor: function WorkerGlobalScope(worker) {\n    this._addonWorker = worker;\n    \n    // Hack in order to allow addon worker to access _asyncEmit\n    // as this is the private object of WorkerGlobalScope\n    worker._contentWorker = this;\n    \n    // create an event emitter that receive and send events from/to the addon\n    let contentWorker = this;\n    this._port = EventEmitterTrait.create({\n      emit: function () {\n        let addonWorker = contentWorker._addonWorker;\n        if (!addonWorker)\n          throw new Error(ERR_DESTROYED);\n        addonWorker._onContentScriptEvent.apply(addonWorker, arguments);\n      }\n    });\n    // create emit that executes in next turn of event loop.\n    this._port._asyncEmit = Enqueued(this._port._emit);\n    // expose wrapped port, that exposes only public properties. \n    this._port._public = Cortex(this._port);\n    \n    // We receive an unwrapped window, with raw js access\n    let window = worker._window;\n    \n    // Create the sandbox and bind it to window in order for content scripts to\n    // have access to all standard globals (window, document, ...)\n    let sandbox = this._sandbox = new Cu.Sandbox(window, {\n      sandboxPrototype: proxy.create(window),\n      wantXrays: false\n    });\n    Object.defineProperties(sandbox, {\n      window: { get: function() sandbox },\n      top: { get: function() sandbox }\n    });\n    \n    // Overriding / Injecting some natives into sandbox.\n    Cu.evalInSandbox(shims.contents, sandbox, JS_VERSION, shims.filename);\n    \n    let publicAPI = this._public;\n    \n    // List of content script globals:\n    let keys = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', \n                'self'];\n    for each (let key in keys) {\n      Object.defineProperty(\n        sandbox, key, Object.getOwnPropertyDescriptor(publicAPI, key)\n      );\n    }\n    let self = this;\n    Object.defineProperties(sandbox, {\n      onMessage: {\n        get: function() self._onMessage,\n        set: function(value) {\n          console.warn(\"The global `onMessage` function in content scripts \" +\n                       \"is deprecated in favor of the `self.on()` function. \" +\n                       \"Replace `onMessage = function (data){}` definitions \" +\n                       \"with calls to `self.on('message', function (data){})`.\");\n          self._onMessage = value;\n        },\n        configurable: true\n      },\n      console: { value: console, configurable: true },\n      \n      // Deprecated use of on/postMessage from globals\n      on: {\n        value: function () {\n          console.warn(\"The global `on()` function in content scripts is \" +\n                       \"deprecated in favor of the `self.on()` function, \" +\n                       \"which works the same. Replace calls to `on()` with \" +\n                       \"calls to `self.on()`\");\n          publicAPI.on.apply(publicAPI, arguments);\n        },\n        configurable: true\n      }, \n      postMessage: {\n        value: function () {\n          console.warn(\"The global `postMessage()` function in content \" +\n                       \"scripts is deprecated in favor of the \" +\n                       \"`self.postMessage()` function, which works the same. \" +\n                       \"Replace calls to `postMessage()` with calls to \" +\n                       \"`self.postMessage()`.\");\n          publicAPI.postMessage.apply(publicAPI, arguments);\n        },\n        configurable: true\n      }\n    });\n\n    // The order of `contentScriptFile` and `contentScript` evaluation is\n    // intentional, so programs can load libraries like jQuery from script URLs\n    // and use them in scripts.\n    let contentScriptFile = ('contentScriptFile' in worker) ? worker.contentScriptFile\n          : null,\n        contentScript = ('contentScript' in worker) ? worker.contentScript : null;\n\n    if (contentScriptFile) {\n      if (Array.isArray(contentScriptFile))\n        this._importScripts.apply(this, contentScriptFile);\n      else\n        this._importScripts(contentScriptFile);\n    }\n    if (contentScript) {\n      this._evaluate(\n        Array.isArray(contentScript) ? contentScript.join(';\\n') : contentScript\n      );\n    }\n  },\n  _destructor: function _destructor() {\n    this._removeAllListeners();\n    let publicAPI = this._public,\n        sandbox = this._sandbox;\n    delete sandbox.__proto__;\n    for (let key in publicAPI)\n      delete sandbox[key];\n    this._sandbox = null;\n    this._addonWorker = null;\n    this.__onMessage = undefined;\n  },\n  \n  /**\n   * JavaScript sandbox where all the content scripts are evaluated.\n   * {Sandbox}\n   */\n  _sandbox: null,\n  \n  /**\n   * Reference to the addon side of the worker.\n   * @type {Worker}\n   */\n  _addonWorker: null,\n  \n  /**\n   * Evaluates code in the sandbox.\n   * @param {String} code\n   *    JavaScript source to evaluate.\n   * @param {String} [filename='javascript:' + code]\n   *    Name of the file\n   */\n  _evaluate: function(code, filename) {\n    filename = filename || 'javascript:' + code;\n    try {\n      Cu.evalInSandbox(code, this._sandbox, JS_VERSION, filename, 1);\n    }\n    catch(e) {\n      this._addonWorker._asyncEmit('error', e);\n    }\n  },\n  /**\n   * Imports scripts to the sandbox by reading files under urls and\n   * evaluating its source. If exception occurs during evaluation\n   * `\"error\"` event is emitted on the worker.\n   * This is actually an analog to the `importScript` method in web\n   * workers but in our case it's not exposed even though content\n   * scripts may be able to do it synchronously since IO operation\n   * takes place in the UI process.\n   */\n  _importScripts: function _importScripts(url) {\n    let urls = Array.slice(arguments, 0);\n    for each (let contentScriptFile in urls) {\n      try {\n        let filename = toFilename(contentScriptFile);\n        this._evaluate(file.read(filename), filename);\n      }\n      catch(e) {\n        this._addonWorker._asyncEmit('error', e)\n      }\n    }\n  }\n});\n\n/**\n * Message-passing facility for communication between code running\n * in the content and add-on process.\n * @see https://jetpack.mozillalabs.com/sdk/latest/docs/#module/api-utils/content/worker\n */\nconst Worker = AsyncEventEmitter.compose({\n  on: Trait.required,\n  _asyncEmit: Trait.required,\n  _removeAllListeners: Trait.required,\n  \n  /**\n   * Sends a message to the worker's global scope. Method takes single\n   * argument, which represents data to be sent to the worker. The data may\n   * be any primitive type value or `JSON`. Call of this method asynchronously\n   * emits `message` event with data value in the global scope of this\n   * symbiont.\n   *\n   * `message` event listeners can be set either by calling\n   * `self.on` with a first argument string `\"message\"` or by\n   * implementing `onMessage` function in the global scope of this worker.\n   * @param {Number|String|JSON} data\n   */\n  postMessage: function postMessage(data) {\n    if (!this._contentWorker)\n      throw new Error(ERR_DESTROYED);\n    this._contentWorker._asyncEmit('message',  JSON.parse(JSON.stringify(data)));\n  },\n  \n  /**\n   * EventEmitter, that behaves (calls listeners) asynchronously.\n   * A way to send customized messages to / from the worker.\n   * Events from in the worker can be observed / emitted via \n   * worker.on / worker.emit.\n   */\n  get port() {\n    // We generate dynamically this attribute as it needs to be accessible\n    // before Worker.constructor gets called. (For ex: Panel)\n    \n    // create an event emitter that receive and send events from/to the worker\n    let self = this;\n    this._port = EventEmitterTrait.create({\n      emit: function () self._emitEventToContent(arguments)\n    });\n    // create emit that executes in next turn of event loop.\n    this._port._asyncEmit = Enqueued(this._port._emit);\n    // expose wrapped port, that exposes only public properties:\n    // We need to destroy this getter in order to be able to set the\n    // final value. We need to update only public port attribute as we never \n    // try to access port attribute from private API.\n    delete this._public.port;\n    this._public.port = Cortex(this._port);\n    // Replicate public port to the private object\n    delete this.port;\n    this.port = this._public.port;\n    \n    return this._port;\n  },\n  \n  /**\n   * Same object than this.port but private API.\n   * Allow access to _asyncEmit, in order to send event to port.\n   */\n  _port: null,\n  \n  /**\n   * Emit a custom event to the content script, \n   * i.e. emit this event on `self.port`\n   */\n  _emitEventToContent: function _emitEventToContent(args) {\n    // We need to save events that are emitted before the worker is \n    // initialized\n    if (!this._inited) {\n      this._earlyEvents.push(args);\n      return;\n    }\n    \n    // We throw exception when the worker has been destroyed\n    if (!this._contentWorker) {\n      throw new Error(ERR_DESTROYED);\n    }\n    \n    let scope = this._contentWorker._port;\n    scope._asyncEmit.apply(scope, args);\n  },\n  \n  // Is worker connected to the content worker (i.e. WorkerGlobalScope) ?\n  _inited: false,\n  \n  // List of custom events fired before worker is initialized\n  get _earlyEvents() {\n    delete this._earlyEvents;\n    this._earlyEvents = [];\n    return this._earlyEvents;\n  },\n  \n  constructor: function Worker(options) {\n    options = options || {};\n\n    if ('window' in options)\n      this._window = options.window;\n    if ('contentScriptFile' in options)\n      this.contentScriptFile = options.contentScriptFile;\n    if ('contentScript' in options)\n      this.contentScript = options.contentScript;\n    if ('onError' in options)\n      this.on('error', options.onError);\n    if ('onMessage' in options)\n      this.on('message', options.onMessage);\n    if ('onDetach' in options)\n      this.on('detach', options.onDetach);\n    \n    // Track document unload to destroy this worker.\n    // We can't watch for unload event on page's window object as it \n    // prevents bfcache from working: \n    // https://developer.mozilla.org/En/Working_with_BFCache\n    this._windowID = this._window.\n                     QueryInterface(Ci.nsIInterfaceRequestor).\n                     getInterface(Ci.nsIDOMWindowUtils).\n                     currentInnerWindowID;\n    observers.add(\"inner-window-destroyed\", \n                  this._documentUnload = this._documentUnload.bind(this));\n    \n    unload.ensure(this._public, \"destroy\");\n    \n    // Ensure that worker._port is initialized for contentWorker to be able\n    // to send use event during WorkerGlobalScope(this)\n    this.port;\n    \n    // will set this._contentWorker pointing to the private API:\n    WorkerGlobalScope(this);  \n    \n    // Mainly enable worker.port.emit to send event to the content worker\n    this._inited = true;\n    \n    // Flush all events that have been fired before the worker is initialized.\n    this._earlyEvents.forEach((function (args) this._emitEventToContent(args)).\n                              bind(this));\n  },\n  \n  _documentUnload: function _documentUnload(subject, topic, data) {\n    let innerWinID = subject.QueryInterface(Ci.nsISupportsPRUint64).data;\n    if (innerWinID != this._windowID) return;\n    this._workerCleanup();\n  },\n\n  get url() {\n    return this._window.document.location.href;\n  },\n  \n  get tab() {\n    let tab = require(\"tabs/tab\");\n    return tab.getTabForWindow(this._window);\n  },\n  \n  /**\n   * Tells content worker to unload itself and \n   * removes all the references from itself.\n   */\n  destroy: function destroy() {\n    this._workerCleanup();\n    this._removeAllListeners('message');\n    this._removeAllListeners('error');\n    this._removeAllListeners('detach');\n  },\n  \n  /**\n   * Remove all internal references to the attached document\n   * Tells _port to unload itself and removes all the references from itself.\n   */\n  _workerCleanup: function _workerCleanup() {\n    // maybe unloaded before content side is created\n    // As Symbiont call worker.constructor on document load\n    if (this._contentWorker) \n      this._contentWorker._destructor();\n    this._contentWorker = null;\n    this._window = null;\n    observers.remove(\"inner-window-destroyed\", this._documentUnload);\n    this._windowID = null;\n    this._earlyEvents.slice(0, this._earlyEvents.length);\n    this._emit(\"detach\");\n  },\n  \n  /**\n   * Receive an event from the content script that need to be sent to \n   * worker.port. Provide a way for composed object to catch all events.\n   */\n  _onContentScriptEvent: function _onContentScriptEvent() {\n    this._port._asyncEmit.apply(this._port, arguments);\n  },\n  \n  /**\n   * Reference to the content side of the worker.\n   * @type {WorkerGlobalScope}\n   */\n  _contentWorker: null,\n\n  /**\n   * Reference to the window that is accessible from\n   * the content scripts.\n   * @type {Object}\n   */\n  _window: null,\n});\nexports.Worker = Worker;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "content/worker"
    }
  }, 
  {
    "pk": 80, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Ci} = require(\"chrome\");\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The context-menu module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nconst apiUtils = require(\"api-utils\");\nconst collection = require(\"collection\");\nconst { Worker } = require(\"content\");\nconst url = require(\"url\");\nconst { MatchPattern } = require(\"match-pattern\");\nconst { EventEmitterTrait: EventEmitter } = require(\"events\");\nconst observerServ = require(\"observer-service\");\nconst jpSelf = require(\"self\");\n\n// All user items we add have this class name.\nconst ITEM_CLASS = \"jetpack-context-menu-item\";\n\n// Items in the top-level context menu also have this class.\nconst TOPLEVEL_ITEM_CLASS = \"jetpack-context-menu-item-toplevel\";\n\n// Items in the overflow submenu also have this class.\nconst OVERFLOW_ITEM_CLASS = \"jetpack-context-menu-item-overflow\";\n\n// The ID of the menu separator that separates standard context menu items from\n// our user items.\nconst SEPARATOR_ID = \"jetpack-context-menu-separator\";\n\n// If more than this number of items are added to the context menu, all items\n// overflow into a \"Jetpack\" submenu.\nconst OVERFLOW_THRESH_DEFAULT = 10;\nconst OVERFLOW_THRESH_PREF =\n  \"extensions.addon-sdk.context-menu.overflowThreshold\";\n\n// The label of the overflow sub-xul:menu.\n//\n// TODO: Localize this.\nconst OVERFLOW_MENU_LABEL = \"Add-ons\";\n\n// The ID of the overflow sub-xul:menu.\nconst OVERFLOW_MENU_ID = \"jetpack-content-menu-overflow-menu\";\n\n// The ID of the overflow submenu's xul:menupopup.\nconst OVERFLOW_POPUP_ID = \"jetpack-content-menu-overflow-popup\";\n\n// These are used by PageContext.isCurrent below.  If the popupNode or any of\n// its ancestors is one of these, Firefox uses a tailored context menu, and so\n// the page context doesn't apply.\nconst NON_PAGE_CONTEXT_ELTS = [\n  Ci.nsIDOMHTMLAnchorElement,\n  Ci.nsIDOMHTMLAppletElement,\n  Ci.nsIDOMHTMLAreaElement,\n  Ci.nsIDOMHTMLButtonElement,\n  Ci.nsIDOMHTMLCanvasElement,\n  Ci.nsIDOMHTMLEmbedElement,\n  Ci.nsIDOMHTMLImageElement,\n  Ci.nsIDOMHTMLInputElement,\n  Ci.nsIDOMHTMLIsIndexElement,\n  Ci.nsIDOMHTMLMapElement,\n  Ci.nsIDOMHTMLMediaElement,\n  Ci.nsIDOMHTMLMenuElement,\n  Ci.nsIDOMHTMLObjectElement,\n  Ci.nsIDOMHTMLOptionElement,\n  Ci.nsIDOMHTMLSelectElement,\n  Ci.nsIDOMHTMLTextAreaElement,\n];\n\n// This object is used elsewhere in this file to access private properties of\n// Item and Menu instances.\nconst PRIVATE_PROPS_KEY = {\n  valueOf: function valueOf() \"private properties key\"\n};\n\n// Used as an internal ID for items and as part of a public ID for item DOM\n// elements.\nlet nextItemID = 0;\n\nexports.Item = apiUtils.publicConstructor(Item);\nexports.Menu = apiUtils.publicConstructor(Menu);\nexports.Separator = apiUtils.publicConstructor(Separator);\n\n\nfunction Item(options) {\n  let rules = optionsRules();\n  rules.data = {\n    map: function (v) v.toString(),\n    is: [\"string\", \"undefined\"]\n  };\n  options = apiUtils.validateOptions(options, rules);\n\n  defineItemProps(this, options);\n\n  // TODO: Add setter for this?\n  this.__defineGetter__(\"data\", function () {\n    return \"data\" in options ? options.data : undefined;\n  });\n\n  this.toString = function Item_toString() {\n    return '[object Item \"' + options.label + '\"]';\n  };\n\n  browserManager.addItem(this);\n}\n\nfunction Menu(options) {\n  let rules = optionsRules();\n  rules.items = {\n    is: [\"array\"]\n  };\n  options = apiUtils.validateOptions(options, rules);\n\n  defineItemProps(this, options);\n\n  // TODO: Add setter for this?\n  this.__defineGetter__(\"items\", function () options.items.slice(0));\n\n  this.toString = function Menu_toString() {\n    return '[object Menu \"' + options.label + '\"]';\n  };\n\n  options.items.forEach(function (i) browserManager.removeItem(i));\n  browserManager.addItem(this);\n}\n\nfunction Separator() {\n  this.toString = function Separator_toString() {\n    return \"[object Separator]\";\n  };\n}\n\n\nfunction Context() {}\n\nfunction PageContext() {\n  this.isCurrent = function PageContext_isCurrent(popupNode) {\n    let win = popupNode.ownerDocument.defaultView;\n    if (win && !win.getSelection().isCollapsed)\n      return false;\n\n    let cursor = popupNode;\n    while (cursor && !(cursor instanceof Ci.nsIDOMHTMLHtmlElement)) {\n      if (NON_PAGE_CONTEXT_ELTS.some(function (iface) cursor instanceof iface))\n        return false;\n      cursor = cursor.parentNode;\n    }\n    return true;\n  };\n}\n\nPageContext.prototype = new Context();\n\nfunction SelectorContext(selector) {\n  let opts = apiUtils.validateOptions({ selector: selector }, {\n    selector: {\n      is: [\"string\"],\n      msg: \"selector must be a string.\"\n    }\n  });\n\n  this.adjustPopupNode = function SelectorContext_adjustPopupNode(node) {\n    return closestMatchingAncestor(node);\n  };\n\n  this.isCurrent = function SelectorContext_isCurrent(popupNode) {\n    return !!closestMatchingAncestor(popupNode);\n  };\n\n  // Returns node if it matches selector, or the closest ancestor of node that\n  // matches, or null if node and none of its ancestors matches.\n  function closestMatchingAncestor(node) {\n    let cursor = node;\n    while (cursor) {\n      if (cursor.mozMatchesSelector(selector))\n        return cursor;\n      if (cursor instanceof Ci.nsIDOMHTMLHtmlElement)\n        break;\n      cursor = cursor.parentNode;\n    }\n    return null;\n  }\n}\n\nSelectorContext.prototype = new Context();\n\nfunction SelectionContext() {\n  this.isCurrent = function SelectionContext_isCurrent(popupNode) {\n    let win = popupNode.ownerDocument.defaultView;\n    if (!win)\n      return false;\n    return !win.getSelection().isCollapsed;\n  };\n}\n\nSelectionContext.prototype = new Context();\n\nfunction URLContext(patterns) {\n  let opts = apiUtils.validateOptions({ patterns: patterns }, {\n    patterns: {\n      map: function (v) apiUtils.getTypeOf(v) === \"array\" ? v : [v],\n      ok: function (v) v.every(function (p) typeof(p) === \"string\"),\n      msg: \"patterns must be a string or an array of strings.\"\n    }\n  });\n  try {\n    patterns = opts.patterns.map(function (p) new MatchPattern(p));\n  }\n  catch (err) {\n    console.error(\"Error creating URLContext match pattern:\");\n    throw err;\n  }\n\n  const self = this;\n\n  this.isCurrent = function URLContext_isCurrent(popupNode) {\n    return self.isCurrentForURL(popupNode.ownerDocument.URL);\n  };\n\n  this.isCurrentForURL = function URLContext_isCurrentForURL(url) {\n    return patterns.some(function (p) p.test(url));\n  };\n}\n\nURLContext.prototype = new Context();\n\nexports.PageContext = apiUtils.publicConstructor(PageContext);\nexports.SelectorContext = apiUtils.publicConstructor(SelectorContext);\nexports.SelectionContext = apiUtils.publicConstructor(SelectionContext);\nexports.URLContext = apiUtils.publicConstructor(URLContext);\n\n\n// Returns rules for apiUtils.validateOptions() common to Item and Menu.\nfunction optionsRules() {\n  return {\n    context: {\n      is: [\"undefined\", \"object\", \"array\"],\n      ok: function (v) {\n        if (!v)\n          return true;\n        let arr = apiUtils.getTypeOf(v) === \"array\" ? v : [v];\n        return arr.every(function (o) o instanceof Context);\n      },\n      msg: \"The 'context' option must be a Context object or an array of \" +\n           \"Context objects.\"\n    },\n    label: {\n      map: function (v) v.toString(),\n      is: [\"string\"],\n      ok: function (v) !!v,\n      msg: \"The item must have a non-empty string label.\"\n    },\n    contentScript: {\n      is: [\"string\", \"array\", \"undefined\"],\n      ok: function (v) {\n        return apiUtils.getTypeOf(v) !== \"array\" ||\n               v.every(function (s) typeof(s) === \"string\");\n      }\n    },\n    contentScriptFile: {\n      is: [\"string\", \"array\", \"undefined\"],\n      ok: function (v) {\n        if (!v)\n          return true;\n        let arr = apiUtils.getTypeOf(v) === \"array\" ? v : [v];\n        try {\n          return arr.every(function (s) {\n            return apiUtils.getTypeOf(s) === \"string\" && url.toFilename(s);\n          });\n        }\n        catch (err) {}\n        return false;\n      },\n      msg: \"The 'contentScriptFile' option must be a local file URL or \" +\n           \"an array of local file URLs.\"\n    },\n    onMessage: {\n      is: [\"function\", \"undefined\"]\n    }\n  };\n}\n\n// Defines some getters and other properties that are common to Item and Menu.\n// item is the Item or Menu object on which to define the properties, and\n// options is a validated options object.\nfunction defineItemProps(item, options) {\n  item.__defineGetter__(\"label\", function () options.label);\n  item.__defineSetter__(\"label\", function setItemLabel(val) {\n    let { label } = apiUtils.validateOptions({ label: val }, optionsRules());\n    options.label = label;\n    browserManager.setItemLabel(item, label);\n  });\n\n  // Stupid ternaries to avoid Spidermonkey strict warnings.\n  item.__defineGetter__(\"contentScript\", function () {\n    return \"contentScript\" in options ? options.contentScript : undefined;\n  });\n  item.__defineGetter__(\"contentScriptFile\", function () {\n    return \"contentScriptFile\" in options ? options.contentScriptFile :\n           undefined;\n  });\n\n  item.destroy = function Item_destroy() {\n    browserManager.removeItem(item);\n  };\n\n  // Create a private properties object for the item.\n  let privateProps = {\n    eventEmitter: EventEmitter.create(item),\n    workerReg: new WorkerRegistry(item),\n    id: nextItemID++\n  };\n\n  // This makes the private properties accessible to anyone with access to the\n  // PRIVATE_PROPS_KEY object.  Only this file has has access to it, so only\n  // this file has access to the private properties.\n  item.valueOf = function Item_valueOf(key) {\n    return key === PRIVATE_PROPS_KEY ? privateProps : item;\n  };\n\n  // Add all of privateProps.eventEmitter's own public methods to the item,\n  // binding them to eventEmitter.  This will allow clients to treat the item as\n  // an event emitter.\n  Object.keys(privateProps.eventEmitter).forEach(function (key) {\n    if (key[0] !== \"_\")\n      item[key] =\n        privateProps.eventEmitter[key].bind(privateProps.eventEmitter);\n  });\n\n  // Register a message listener if one was passed to the constructor.\n  if (\"onMessage\" in options)\n    privateProps.eventEmitter.on(\"message\", options.onMessage);\n\n  // When a URL context is removed (by calling item.context.remove(urlContext)),\n  // we may need to create workers for windows containing pages that the item\n  // now matches.  Likewise, when a URL context is added, we need to destroy\n  // workers for windows containing pages that the item now does not match.\n  //\n  // collection doesn't provide a way to listen for removals.  utils/registry\n  // does, but it doesn't allow its elements to be enumerated.  So as a hack,\n  // use a collection for item.context and replace its add and remove methods.\n  collection.addCollectionProperty(item, \"context\");\n  if (options.context)\n    item.context.add(options.context);\n\n  let add = item.context.add;\n  item.context.add = function itemContextAdd() {\n    let args = Array.slice(arguments);\n    add.apply(item.context, args);\n    if (args.some(function (a) a instanceof URLContext))\n      privateProps.workerReg.destroyUnneededWorkers();\n  };\n\n  let remove = item.context.remove;\n  item.context.remove = function itemContextRemove() {\n    let args = Array.slice(arguments);\n    remove.apply(item.context, args);\n    if (args.some(function (a) a instanceof URLContext))\n      privateProps.workerReg.createNeededWorkers();\n  };\n}\n\n// Does a binary search on elts, a NodeList, and returns the DOM element\n// before which an item with targetLabel should be inserted.  null is returned\n// if the new item should be inserted at the end.\nfunction insertionPoint(targetLabel, elts) {\n  let from = 0;\n  let to = elts.length - 1;\n\n  while (from <= to) {\n    let i = Math.floor((from + to) / 2);\n    let comp = targetLabel.localeCompare(elts[i].getAttribute(\"label\"));\n    if (comp < 0)\n      to = i - 1;\n    else if (comp > 0)\n      from = i + 1;\n    else\n      return elts[i];\n  }\n  return elts[from] || null;\n}\n\n// Builds an ID suitable for a DOM element from the given item ID.  The optional\n// suffix will be appended to the returned ID.\nfunction domEltIDFromItemID(itemID, suffix) {\n  suffix = suffix || \"\";\n  if (!/^[-a-z]*$/.test(suffix))\n    throw new Error(\"Internal error: suffix must match the regexp [-a-z]*\");\n  return jpSelf.id + \"-context-menu-item-\" + itemID + suffix;\n}\n\n// Parses the item ID out of the given DOM element ID and returns it.\nfunction itemIDFromDOMEltID(domEltID) {\n  return Number(/([0-9]+)[-a-z]*$/.exec(domEltID)[1]);\n}\n\n\n// Keeps track of all browser windows.\nlet browserManager = {\n  items: [],\n  windows: [],\n\n  // Registers an item with the manager.  It's added to the context menus of\n  // all currently registered windows, and when new windows are registered it\n  // will be added to them, too.\n  addItem: function browserManager_addItem(item) {\n    this.items.push(item);\n    this.windows.forEach(function (w) w.addItems([item]));\n  },\n\n  // Sets the given item's label in all the browser windows.  See\n  // ContextMenuPopup.setItemLabel.\n  setItemLabel: function browserManager_setItemLabel(item, label) {\n    this.windows.forEach(function (w) w.setItemLabel(item, label));\n  },\n\n  // Registers the manager to listen for window openings and closings.  Note\n  // that calling this method can cause onTrack to be called immediately if\n  // there are open windows.\n  init: function browserManager_init() {\n    require(\"unload\").ensure(this);\n    let windowTracker = new (require(\"window-utils\").WindowTracker)(this);\n\n    // On inner-window-destroyed, remove the destroyed inner window's outer\n    // window from all items' worker registries.\n    observerServ.add(\"inner-window-destroyed\", function observe(subj) {\n      let innerWinID = subj.QueryInterface(Ci.nsISupportsPRUint64).data;\n      this.items.forEach(function (item) {\n        let workerReg = item.valueOf(PRIVATE_PROPS_KEY).workerReg;\n        workerReg.unregisterContentWin(innerWinID);\n      });\n    }, this);\n  },\n\n  // When the window tracker is unloaded, it'll call our onUntrack for every\n  // open browser window, so there's no need to do that here.  The only other\n  // things to clean up are items and their worker registries.\n  unload: function browserManager_unload() {\n    this.items.forEach(function (item) {\n      item.valueOf(PRIVATE_PROPS_KEY).workerReg.destroy();\n    });\n    this.items.splice(0, this.items.length);\n  },\n\n  // Registers a window with the manager.  This is a WindowTracker callback.\n  onTrack: function browserManager_onTrack(window) {\n    if (this._isBrowserWindow(window)) {\n      let win = new BrowserWindow(window);\n      this.windows.push(win);\n      win.addItems(this.items);\n    }\n  },\n\n  // Unregisters a window from the manager.  It's told to undo all menu\n  // modifications.  This is a WindowTracker callback.\n  onUntrack: function browserManager_onUntrack(window) {\n    if (this._isBrowserWindow(window)) {\n      for (let i = 0; i < this.windows.length; i++) {\n        if (this.windows[i].window == window) {\n          let win = this.windows.splice(i, 1)[0];\n          win.destroy();\n          return;\n        }\n      }\n    }\n  },\n\n  // Unregisters an item from the manager.  It's removed from the context menus\n  // of all windows that are currently registered.  If the item is not\n  // registered, this is a no-op.\n  removeItem: function browserManager_removeItem(item) {\n    let idx = this.items.indexOf(item);\n    if (idx >= 0) {\n      this.items.splice(idx, 1);\n      this.windows.forEach(function (w) w.removeItems([item]));\n      item.valueOf(PRIVATE_PROPS_KEY).workerReg.destroy();\n    }\n  },\n\n  _isBrowserWindow: function browserManager__isBrowserWindow(win) {\n    let winType = win.document.documentElement.getAttribute(\"windowtype\");\n    return winType === \"navigator:browser\";\n  }\n};\n\n\n// A type of Worker tailored to our uses.\nconst ContextMenuWorker = Worker.compose({\n  destroy: Worker.required,\n\n  // Returns true if any context listeners are defined in the worker's port.\n  anyContextListeners: function CMW_anyContextListeners() {\n    return this._contentWorker._listeners(\"context\").length > 0;\n  },\n\n  // Returns true if any of the context listeners in the worker's port return\n  // true.  popupNode is the node that was context-clicked.\n  isAnyContextCurrent: function CMW_isAnyContextCurrent(popupNode) {\n    let listeners = this._contentWorker._listeners(\"context\");\n    for (let i = 0; i < listeners.length; i++) {\n      try {\n        if (listeners[i].call(this._contentWorker._sandbox, popupNode))\n          return true;\n      }\n      catch (err) {\n        console.exception(err);\n      }\n    }\n    return false;\n  },\n\n  // Emits a click event in the worker's port.  popupNode is the node that was\n  // context-clicked, and clickedItemData is the data of the item that was\n  // clicked.\n  fireClick: function CMW_fireClick(popupNode, clickedItemData) {\n    this._contentWorker._asyncEmit(\"click\", popupNode, clickedItemData);\n  }\n});\n\n\n// This class creates and stores content workers for pairs of menu items and\n// content windows.  Use one instance for each item.  Not all pairs need a\n// worker: if an item has a URL context that does not match a window's page,\n// then no worker is created for the pair.\nfunction WorkerRegistry(item) {\n  this.item = item;\n\n  // inner window ID => { win, worker }\n  this.winWorkers = {};\n\n  // inner window ID => content window\n  this.winsWithoutWorkers = {};\n}\n\nWorkerRegistry.prototype = {\n\n  // Registers a content window, creating a worker for it if it needs one.\n  registerContentWin: function WR_registerContentWin(win) {\n    let innerWinID = this._innerWinID(win);\n    if (this._doesURLNeedWorker(win.document.URL))\n      this.winWorkers[innerWinID] = { win: win, worker: this._makeWorker(win) };\n    else\n      this.winsWithoutWorkers[innerWinID] = win;\n  },\n\n  // Unregisters a content window, destroying its related worker if it has one.\n  unregisterContentWin: function WR_unregisterContentWin(innerWinID) {\n    // Sometimes inner-window-destroyed is sent for a window that's not\n    // registered, which implies that DOMContentLoaded is not dispatched to any\n    // tabbrowser for that inner window's outer window...  So rather than\n    // erroneously throwing an error if the window is not registered, don't\n    // assume that the window is registered in the first place.\n    if (innerWinID in this.winWorkers) {\n      let winWorker = this.winWorkers[innerWinID];\n      winWorker.worker.destroy();\n      delete winWorker.worker;\n      delete winWorker.win;\n      delete this.winWorkers[innerWinID];\n    }\n    else\n      delete this.winsWithoutWorkers[innerWinID];\n  },\n\n  // Creates a worker for each window that needs a worker but doesn't have one.\n  createNeededWorkers: function WR_createNeededWorkers() {\n    for (let [innerWinID, win] in Iterator(this.winsWithoutWorkers)) {\n      delete this.winsWithoutWorkers[innerWinID];\n      this.registerContentWin(win);\n    }\n  },\n\n  // Destroys the worker for each window that has a worker but doesn't need it.\n  destroyUnneededWorkers: function WR_destroyUnneededWorkers() {\n    for (let [innerWinID, winWorker] in Iterator(this.winWorkers)) {\n      if (!this._doesURLNeedWorker(winWorker.win.document.URL)) {\n        this.unregisterContentWin(innerWinID);\n        this.winsWithoutWorkers[innerWinID] = winWorker.win;\n      }\n    }\n  },\n\n  // Returns the worker for the item-window pair or null if none exists.\n  find: function WR_find(contentWin) {\n    let innerWinID = this._innerWinID(contentWin);\n    return (innerWinID in this.winWorkers) ?\n           this.winWorkers[innerWinID].worker :\n           null;\n  },\n\n  // Unregisters all content windows in the registry, destroying all workers.\n  destroy: function WR_destroy() {\n    for (let innerWinID in this.winWorkers)\n      this.unregisterContentWin(innerWinID);\n    for (let innerWinID in this.winsWithoutWorkers)\n      this.unregisterContentWin(innerWinID);\n  },\n\n  // Returns false if the item has a URL context that does not match the given\n  // URL.\n  _doesURLNeedWorker: function WR__doesURLNeedWorker(url) {\n    for (let ctxt in this.item.context)\n      if ((ctxt instanceof URLContext) && !ctxt.isCurrentForURL(url))\n        return false;\n    return true;\n  },\n\n  _makeWorker: function WR__makeWorker(win) {\n    let worker = ContextMenuWorker({\n      window: win.wrappedJSObject,\n      contentScript: this.item.contentScript,\n      contentScriptFile: this.item.contentScriptFile,\n      onError: function (err) console.exception(err)\n    });\n    let (item = this.item) worker.on(\"message\", function workerOnMessage(msg) {\n      try {\n        let eventEmitter = item.valueOf(PRIVATE_PROPS_KEY).eventEmitter;\n        eventEmitter._emitOnObject(item, \"message\", msg);\n      }\n      catch (err) {\n        console.exception(err);\n      }\n    });\n    return worker;\n  },\n\n  _innerWinID: function WR__innerWinID(win) {\n    return win.\n           QueryInterface(Ci.nsIInterfaceRequestor).\n           getInterface(Ci.nsIDOMWindowUtils).\n           currentInnerWindowID;\n  }\n};\n\n\n// Keeps track of a single browser window.  Responsible for providing a\n// description of the window's current context and determining whether an item\n// matches the current context.\n//\n// TODO: If other apps besides Firefox want to support the context menu in\n// whatever way is appropriate for them, plugging in a substitute for this class\n// should be the way to do it.  Make it easy for them.  See bug 560716.\nfunction BrowserWindow(window) {\n  this.window = window;\n  this.doc = window.document;\n\n  let popup = this.doc.getElementById(\"contentAreaContextMenu\");\n  if (!popup)\n    throw new Error(\"Internal error: Context menu popup not found.\");\n  this.contextMenuPopup = new ContextMenuPopup(popup, this);\n\n  // Listen for page loads on the tabbrowser so we can create workers.\n  window.gBrowser.addEventListener(\"DOMContentLoaded\", this, false);\n}\n\nBrowserWindow.prototype = {\n\n  // Adds an array of items to the window's context menu.\n  addItems: function BW_addItems(items) {\n    this.contextMenuPopup.addItems(items);\n\n    // Register all open and loaded content windows in this browser window with\n    // each item's worker registry.\n    items.forEach(function (item) {\n      this.window.gBrowser.browsers.forEach(function (browser) {\n        if (browser.contentDocument.readyState === \"complete\") {\n          item.valueOf(PRIVATE_PROPS_KEY).workerReg.\n            registerContentWin(browser.contentWindow);\n        }\n      }, this);\n    }, this);\n  },\n\n  // Sets the given item's label in the browser window's context menu.  See\n  // ContextMenuPopup.setItemLabel.\n  setItemLabel: function BW_setItemLabel(item, label) {\n    this.contextMenuPopup.setItemLabel(item, label);\n  },\n\n  // The context specified for a top-level item may not match exactly the real\n  // context that triggers it.  For example, if the user context-clicks a span\n  // inside an anchor, we want items that specify an anchor context to be\n  // triggered, but the real context will indicate that the span was clicked,\n  // not the anchor.  Where the real context and an item's context conflict,\n  // clients should be given the item's context, and this method can be used to\n  // make such adjustments.  Returns an adjusted popupNode.\n  adjustPopupNode: function BW_adjustPopupNode(popupNode, topLevelItem) {\n    for (let ctxt in topLevelItem.context) {\n      if (typeof(ctxt.adjustPopupNode) === \"function\") {\n        let ctxtNode = ctxt.adjustPopupNode(popupNode);\n        if (ctxtNode) {\n          popupNode = ctxtNode;\n          break;\n        }\n      }\n    }\n    return popupNode;\n  },\n\n  // Returns true if all of item's contexts are current in the window.\n  areAllContextsCurrent: function BW_areAllContextsCurrent(item, popupNode) {\n    let win = popupNode.ownerDocument.defaultView;\n    let worker = item.valueOf(PRIVATE_PROPS_KEY).workerReg.find(win);\n\n    // If the worker for the item-window pair doesn't exist (e.g., because the\n    // page hasn't loaded yet), we can't really make a good decision since the\n    // content script may have a context listener.  So just don't show the item\n    // at all.\n    if (!worker)\n      return false;\n\n    // If there are no contexts given at all, the page context applies.\n    let hasContentContext = worker.anyContextListeners();\n    if (!hasContentContext && !item.context.length)\n      return new PageContext().isCurrent(popupNode);\n\n    // Otherwise, determine if all given contexts are current.  Evaluate the\n    // declarative contexts first and the worker's context listeners last.  That\n    // way the listener might be able to avoid some work.\n    let curr = true;\n    for (let ctxt in item.context) {\n      curr = curr && ctxt.isCurrent(popupNode);\n      if (!curr)\n        return false;\n    }\n    return !hasContentContext || worker.isAnyContextCurrent(popupNode);\n  },\n\n  // Sets this.popupNode to the node the user context-clicked to invoke the\n  // context menu.  For Gecko 2.0 and later, triggerNode is this node; if it's\n  // falsey, document.popupNode is used.  Returns the popupNode.\n  capturePopupNode: function BW_capturePopupNode(triggerNode) {\n    this.popupNode = triggerNode || this.doc.popupNode;\n    if (!this.popupNode)\n      console.warn(\"popupNode is null.\");\n    return this.popupNode;\n  },\n\n  // Undoes all modifications to the window's context menu.  The BrowserWindow\n  // should not be used afterward.\n  destroy: function BW_destroy() {\n    this.contextMenuPopup.destroy();\n    this.window.gBrowser.removeEventListener(\"DOMContentLoaded\", this, false);\n  },\n\n  // Emits a click event in the port of the content worker related to item and\n  // popupNode's content window.  Listeners will be passed popupNode and\n  // clickedItemData.\n  fireClick: function BW_fireClick(item, popupNode, clickedItemData) {\n    let win = popupNode.ownerDocument.defaultView;\n    let worker = item.valueOf(PRIVATE_PROPS_KEY).workerReg.find(win);\n    if (worker)\n      worker.fireClick(popupNode, clickedItemData);\n  },\n\n  // Removes an array of items from the window's context menu.\n  removeItems: function BW_removeItems(items) {\n    this.contextMenuPopup.removeItems(items);\n  },\n\n  // Handles content window loads.\n  handleEvent: function BW_handleEvent(event) {\n    try {\n      switch (event.type) {\n      case \"DOMContentLoaded\":\n        if (event.target.defaultView)\n          this._registerContentWin(event.target.defaultView);\n        break;\n      }\n    }\n    catch (err) {\n      console.exception(err);\n    }\n  },\n\n  _registerContentWin: function BW__registerContentWin(win) {\n    browserManager.items.forEach(function (item) {\n      item.valueOf(PRIVATE_PROPS_KEY).workerReg.registerContentWin(win);\n    });\n  }\n};\n\n\n// Represents a container of items that's the child of the given Menu and Popup.\n// popupElt is a xul:menupopup that represents the popup in the DOM, and window\n// is the BrowserWindow containing the popup.  The popup is responsible for\n// creating and adding items to poupElt and handling command events.\nfunction Popup(parentMenu, parentPopup, popupElt, window) {\n  this.parentMenu = parentMenu;\n  this.parentPopup = parentPopup;\n  this.popupElt = popupElt;\n  this.window = window;\n  this.doc = popupElt.ownerDocument;\n\n  // item ID => { item, domElt }\n  this.items = {};\n\n  popupElt.addEventListener(\"command\", this, false);\n}\n\nPopup.prototype = {\n\n  // Adds an array of items to the popup.\n  addItems: function Popup_addItems(items) {\n    items.forEach(function (item) {\n      let domElt = this._makeItemElt(item);\n      this.items[item.valueOf(PRIVATE_PROPS_KEY).id] = {\n        item: item,\n        domElt: domElt\n      };\n      this.popupElt.appendChild(domElt);\n    }, this);\n  },\n\n  // Undoes all modifications to the popup.  The popup should not be used\n  // afterward.\n  destroy: function Popup_destroy() {\n    this.popupElt.removeEventListener(\"command\", this, false);\n  },\n\n  // The popup is responsible for two command events: those originating at items\n  // in the popup and those bubbling to the popup's parent menu.  In the first\n  // case the popup dispatches a click to the item, and in the second the popup\n  // dispatches a click to its parent menu -- in that order.\n  handleEvent: function Popup_handleEvent(event) {\n    try {\n      let elt = event.target;\n      if (elt.className.split(/\\s+/).indexOf(ITEM_CLASS) >= 0) {\n        // If the event originated at an item in the popup, dispatch a click.\n        // Also set Popup.clickedItem and popupNode so ancestor popups know\n        // which item was clicked and under what context.\n        let itemID = itemIDFromDOMEltID(elt.id);\n        if (itemID in this.items) {\n          let clickedItem = this.items[itemID].item;\n          let topLevelItem = this._topLevelItem(clickedItem);\n          let popupNode = this.window.adjustPopupNode(this.window.popupNode,\n                                                      topLevelItem);\n          Popup.clickedItem = clickedItem;\n          Popup.popupNode = popupNode;\n          this.window.fireClick(clickedItem, popupNode, clickedItem.data);\n        }\n\n        // Dispatch a click to this popup's parent menu.\n        if (this.parentMenu) {\n          this.window.fireClick(this.parentMenu, Popup.popupNode,\n                                Popup.clickedItem.data);\n        }\n      }\n    }\n    catch (err) {\n      console.exception(err);\n    }\n  },\n\n  // Returns a DOM element representing the item.  All elements will have the\n  // ITEM_CLASS class, and className can optionally be used to add another.  The\n  // element will have a unique ID.  idSuffix, if given, will be appended to the\n  // ID.\n  _makeItemElt: function Popup__makeItemElt(item, className, idSuffix) {\n    let elt = item instanceof Item ? this._makeMenuitem(item, className) :\n              item instanceof Menu ? this._makeMenu(item, className) :\n              item instanceof Separator ? this._makeSeparator(className) :\n              null;\n    if (!elt)\n      throw new Error(\"Internal error: can't make element, unknown item type\");\n\n    elt.id = domEltIDFromItemID(item.valueOf(PRIVATE_PROPS_KEY).id, idSuffix);\n    return elt;\n  },\n\n  // Returns a new xul:menu representing the menu.\n  _makeMenu: function Popup__makeMenu(menu, className) {\n    let menuElt = this.doc.createElement(\"menu\");\n    menuElt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    menuElt.setAttribute(\"label\", menu.label);\n    let popupElt = this.doc.createElement(\"menupopup\");\n    menuElt.appendChild(popupElt);\n\n    // Once items are added, this value can be thrown away.  The popup handles\n    // popupshowing on its own.\n    let popup = new Popup(menu, this, popupElt, this.window);\n    popup.addItems(menu.items);\n\n    return menuElt;\n  },\n\n  // Returns a new xul:menuitem representing the item.\n  _makeMenuitem: function Popup__makeMenuitem(item, className) {\n    let elt = this.doc.createElement(\"menuitem\");\n    elt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    elt.setAttribute(\"label\", item.label);\n    if (item.data)\n      elt.setAttribute(\"value\", item.data);\n    return elt;\n  },\n\n  // Returns a new xul:menuseparator.\n  _makeSeparator: function Popup__makeSeparator(className) {\n    let elt = this.doc.createElement(\"menuseparator\");\n    elt.className = ITEM_CLASS + (className ? \" \" + className : \"\");\n    return elt;\n  },\n\n  // Returns the top-level menu that contains item or item if it is top-level.\n  _topLevelItem: function Popup__topLevelItem(item) {\n    let popup = this;\n    let topLevelItem = item;\n    while (popup.parentPopup) {\n      topLevelItem = popup.parentMenu;\n      popup = popup.parentPopup;\n    }\n    return topLevelItem;\n  }\n};\n\n\n// A subclass of Popup, this represents a window's context menu popup.  It's\n// responsible for hiding and showing items according to the window's current\n// context.\nfunction ContextMenuPopup(popupElt, window) {\n  const self = this;\n  Popup.call(this, null, null, popupElt, window);\n\n  // Adds an array of items to the popup.\n  this.addItems = function CMP_addItems(items) {\n    if (!items.length)\n      return;\n\n    ensureStaticEltsExist();\n    ensureListeningForPopups();\n\n    // Add each item to the top-level menu and the overflow submenu.\n    items.forEach(function (item) {\n      let itemID = item.valueOf(PRIVATE_PROPS_KEY).id;\n      let domElt = self._makeItemElt(item, TOPLEVEL_ITEM_CLASS);\n      let overflowDOMElt = self._makeItemElt(item, OVERFLOW_ITEM_CLASS,\n                                             \"-overflow\");\n      self.items[itemID] = {\n        item: item,\n        domElt: domElt,\n        overflowDOMElt: overflowDOMElt\n      };\n      insertItemInSortedOrder(item);\n    }, self);\n  };\n\n  // Sets the given item's label if the item has a DOM element.  The item is\n  // re-inserted into the popup so that it remains in sorted order.  If the item\n  // has no DOM element yet, does nothing.\n  this.setItemLabel = function CMP_setItemLabel(item, label) {\n    let itemID = item.valueOf(PRIVATE_PROPS_KEY).id;\n    if (!(itemID in self.items))\n      return;\n\n    let { domElt, overflowDOMElt } = self.items[itemID];\n    domElt.parentNode.removeChild(domElt);\n    overflowDOMElt.parentNode.removeChild(overflowDOMElt);\n    domElt.setAttribute(\"label\", label);\n    overflowDOMElt.setAttribute(\"label\", label);\n    insertItemInSortedOrder(item);\n  };\n\n  // Undoes all modifications to the popup.  The popup should not be used\n  // afterward.\n  this.destroy = function CMP_destroy() {\n    for each (let { item } in self.items)\n      self.removeItems([item]);\n\n    // If there are no more items from any instance of the module, remove the\n    // separator and overflow submenu, if they exist.\n    let elts = topLevelElts();\n    if (!elts.length) {\n      let submenu = overflowMenu();\n      if (submenu)\n        self.popupElt.removeChild(submenu);\n\n      let sep = separator();\n      if (sep)\n        self.popupElt.removeChild(sep);\n    }\n\n    // Remove event listeners.\n    if (self._listeningForPopups) {\n      self.popupElt.removeEventListener(\"popupshowing\", self, false);\n      delete self._listeningForPopups;\n    }\n    self.__proto__.destroy.call(self);\n  };\n\n  // The context menu popup needs to handle popupshowing in addition to command\n  // events.  popupshowing is used to show top-level items that match the\n  // window's current context and hide items that don't.  Each module instance\n  // is responsible for showing and hiding the items it owns.\n  this.handleEvent = function CMP_handleEvent(event) {\n    if (event.type === \"command\") {\n      self.__proto__.handleEvent.call(self, event);\n    }\n    else if (event.type === \"popupshowing\" && event.target === popupElt) {\n      try {\n        // popupElt.triggerNode was added in Gecko 2.0 by bug 383930.  The || is\n        // to avoid a Spidermonkey strict warning on earlier versions.\n        let triggerNode = popupElt.triggerNode || undefined;\n        let popupNode = window.capturePopupNode(triggerNode);\n\n        // Show and hide items.  Set a \"jetpackContextCurrent\" property on the\n        // DOM elements to signal which of our items match the current context.\n        for each (let { item, domElt, overflowDOMElt } in self.items) {\n          let contextCurr = window.areAllContextsCurrent(item, popupNode);\n          domElt.jetpackContextCurrent = contextCurr;\n          domElt.hidden = !contextCurr;\n          overflowDOMElt.jetpackContextCurrent = contextCurr;\n          overflowDOMElt.hidden = !contextCurr;\n        }\n\n        // Get the total number of items that match the current context.  It's a\n        // little tricky:  There may be other instances of this module loaded,\n        // each hiding and showing their items.  So we can't base this number on\n        // only our items, or on the hidden state of items.  That's why we set\n        // the jetpackContextCurrent property above.  The last instance to run\n        // will leave the menupopup in the correct state.\n        let elts = topLevelElts();\n        let numShown = Array.reduce(elts, function (total, elt) {\n          return total + (elt.jetpackContextCurrent ? 1 : 0);\n        }, 0);\n\n        // If too many items are shown, show the submenu and hide the top-level\n        // items.  Otherwise, hide the submenu and show the top-level items.\n        let overflow = numShown > overflowThreshold();\n        if (overflow)\n          Array.forEach(elts, function (e) e.hidden = true);\n\n        let submenu = overflowMenu();\n        if (submenu)\n          submenu.hidden = !overflow;\n\n        // If no items are shown, hide the menu separator.\n        let sep = separator();\n        if (sep)\n          sep.hidden = numShown === 0;\n      }\n      catch (err) {\n        console.exception(err);\n      }\n    }\n  };\n\n  // Removes an array of items from the popup.\n  this.removeItems = function CMP_removeItems(items) {\n    items.forEach(function (item) {\n      let itemID = item.valueOf(PRIVATE_PROPS_KEY).id;\n      let { domElt, overflowDOMElt } = self.items[itemID];\n      domElt.parentNode.removeChild(domElt);\n      overflowDOMElt.parentNode.removeChild(overflowDOMElt);\n      delete self.items[itemID];\n    }, self);\n  };\n\n  // Adds the popupshowing listener if it hasn't been added already.\n  function ensureListeningForPopups() {\n    if (!self._listeningForPopups) {\n      self.popupElt.addEventListener(\"popupshowing\", self, false);\n      self._listeningForPopups = true;\n    }\n  }\n\n  // Adds the menu separator and overflow submenu if they don't exist.\n  function ensureStaticEltsExist() {\n    let sep = separator();\n    if (!sep) {\n      sep = makeSeparator();\n      self.popupElt.appendChild(sep);\n    }\n\n    let submenu = overflowMenu();\n    if (!submenu) {\n      submenu = makeOverflowMenu();\n      self.popupElt.insertBefore(submenu, sep.nextSibling);\n    }\n  }\n\n  // Inserts the given item's DOM element into the popup in sorted order.\n  function insertItemInSortedOrder(item) {\n    let itemID = item.valueOf(PRIVATE_PROPS_KEY).id;\n    self.popupElt.insertBefore(self.items[itemID].domElt,\n                               insertionPoint(item.label, topLevelElts()));\n    overflowPopup().insertBefore(self.items[itemID].overflowDOMElt,\n                                 insertionPoint(item.label, overflowElts()));\n  }\n\n  // Creates and returns the xul:menu that's shown when too many items are added\n  // to the popup.\n  function makeOverflowMenu() {\n    let submenu = self.doc.createElement(\"menu\");\n    submenu.id = OVERFLOW_MENU_ID;\n    submenu.setAttribute(\"label\", OVERFLOW_MENU_LABEL);\n    let popup = self.doc.createElement(\"menupopup\");\n    popup.id = OVERFLOW_POPUP_ID;\n    submenu.appendChild(popup);\n    return submenu;\n  }\n\n  // Creates and returns the xul:menuseparator that separates the standard\n  // context menu items from our items.\n  function makeSeparator() {\n    let elt = self.doc.createElement(\"menuseparator\");\n    elt.id = SEPARATOR_ID;\n    return elt;\n  }\n\n  // Returns the item elements contained in the overflow menu, a NodeList.\n  function overflowElts() {\n    return overflowPopup().getElementsByClassName(OVERFLOW_ITEM_CLASS);\n  }\n\n  // Returns the overflow xul:menu.\n  function overflowMenu() {\n    return self.doc.getElementById(OVERFLOW_MENU_ID);\n  }\n\n  // Returns the overflow xul:menupopup.\n  function overflowPopup() {\n    return self.doc.getElementById(OVERFLOW_POPUP_ID);\n  }\n\n  // Returns the OVERFLOW_THRESH_PREF pref value if it exists or\n  // OVERFLOW_THRESH_DEFAULT if it doesn't.\n  function overflowThreshold() {\n    let prefs = require(\"preferences-service\");\n    return prefs.get(OVERFLOW_THRESH_PREF, OVERFLOW_THRESH_DEFAULT);\n  }\n\n  // Returns the xul:menuseparator.\n  function separator() {\n    return self.doc.getElementById(SEPARATOR_ID);\n  }\n\n  // Returns the item elements contained in the top-level menu, a NodeList.\n  function topLevelElts() {\n    return self.popupElt.getElementsByClassName(TOPLEVEL_ITEM_CLASS);\n  }\n};\n\nContextMenuPopup.prototype = Popup.prototype;\n\n\n// Init the browserManager only after setting prototypes and such above, because\n// it will cause browserManager.onTrack to be called immediately if there are\n// open windows.\nbrowserManager.init();\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "context-menu"
    }
  }, 
  {
    "pk": 36, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\n// `var` is being used in the module in order to make it reusable in\n// environments in which `let` and `const` is not yet supported.\n\n// Returns `object`'s property value, where `name` is a name of the property.\nfunction get(object, name) {\n  return object[name];\n}\n\n// Assigns `value` to the `object`'s property, where `name` is the name of the\n// property.\nfunction set(object, name, value) {\n  return object[name] = value;\n}\n\n/**\n * Given an `object` containing a property with the given `name`, create\n * a property descriptor that can be used to define alias/proxy properties\n * on other objects.  A change in the value of an alias will propagate\n * to the aliased property and vice versa.\n */\nfunction createAliasProperty(object, name) {\n  // Getting own property descriptor of an `object` for the given `name` as\n  // we are going to create proxy analog.\n  var property = Object.getOwnPropertyDescriptor(object, name);\n  var descriptor = {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    alias: true\n  };\n\n  // If the original property has a getter and/or setter, bind a\n  // corresponding getter/setter in the alias descriptor to the original\n  // object, so the `this` object in the getter/setter is the original object\n  // rather than the alias.\n  if (\"get\" in property)\n    descriptor.get = property.get.bind(object);\n  if (\"set\" in property)\n    descriptor.set = property.set.bind(object);\n  \n  // If original property was a value property.\n  if (\"value\" in property) {\n    // If original property is a method using it's `object` bounded copy.\n    if (typeof property.value === \"function\") {\n      descriptor.value = property.value.bind(object);\n      // Also preserving writability of the original property.\n      descriptor.writable = property.writable;\n    }\n\n    // If the original property was just a data property, we create proxy\n    // accessors using our custom get/set functions to propagate changes to the\n    // original `object` and vice versa.\n    else {\n      descriptor.get = get.bind(null, object, name);\n      descriptor.set = set.bind(null, object, name);\n    }\n  }\n  return descriptor;\n}\n\n// Defines property on `object` object with a name `alias` if given if not\n// defaults to `name` that represents an alias of `source[name]`. If aliased\n// property was an assessor or a method `this` pseudo-variable will be `source`\n// when invoked. If aliased property was a data property changes on any of the\n// aliases will propagate to the `source[name]` and also other way round.\nfunction defineAlias(source, target, name, alias) {\n  return Object.defineProperty(target, alias || name,\n                               createAliasProperty(source, name));\n}\n\n/**\n * Function takes any `object` and returns a proxy for its own public\n * properties. By default properties are considered to be public if they don't\n * start with `\"_\"`, but default behavior can be overridden if needed, by\n * passing array of public property `names` as a second argument. By default\n * returned object will be direct decedent of the given `object`'s prototype,\n * but this can be overridden by passing third optional argument, that will be\n * used as `prototype` instead.\n * @param {Object} object\n *    Object to create cortex for.\n * @param {String[]} [names]\n *    Optional array of public property names.\n * @param {Object} [prototype]\n *    Optional argument that will be used as `prototype` of the returned object,\n *    if not provided `Object.getPrototypeOf(object)` is used instead.\n */\nexports.Cortex = function Cortex(object, names, prototype) {\n  // Creating a cortex object from the given `prototype`, if one was not\n  // provided then `prototype` of a given `object` is used. This allows\n  // consumer to define expected behavior `instanceof`. In common case\n  // `prototype` argument can be omitted to preserve same behavior of\n  // `instanceof` as on original `object`.\n  var cortex = Object.create(prototype || Object.getPrototypeOf(object));\n  // Creating alias properties on the `cortex` object for all the own\n  // properties of the original `object` that are contained in `names` array.\n  // If `names` array is not provided then all the properties that don't\n  // start with `\"_\"` are aliased.\n  Object.getOwnPropertyNames(object).forEach(function (name) {\n    if ((!names && \"_\" !== name.charAt(0)) || (names && ~names.indexOf(name)))\n      defineAlias(object, cortex, name);\n  });\n  return cortex;\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "cortex"
    }
  }, 
  {
    "pk": 16, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n(function(global) {\n   const Cc = Components.classes;\n   const Ci = Components.interfaces;\n   const Cu = Components.utils;\n   const Cr = Components.results;\n\n   var exports = {};\n\n   // Load the SecurableModule prerequisite.\n   var securableModule;\n   var myURI = Components.stack.filename.split(\" -> \").slice(-1)[0];\n\n   if (global.require) {\n     // We're being loaded in a SecurableModule. This call also tells the\n     // manifest-scanner that it ought to scan securable-module.js\n     securableModule = require(\"securable-module\");\n   } else {\n     var ios = Cc['@mozilla.org/network/io-service;1']\n               .getService(Ci.nsIIOService);\n     var securableModuleURI = ios.newURI(\"securable-module.js\", null,\n                                         ios.newURI(myURI, null, null));\n     if (securableModuleURI.scheme == \"chrome\") {\n       // The securable-module module is at a chrome URI, so we can't\n       // simply load it via Cu.import(). Let's assume we're in a\n       // chrome-privileged document and use mozIJSSubScriptLoader.\n       var loader = Cc[\"@mozilla.org/moz/jssubscript-loader;1\"]\n                    .getService(Ci.mozIJSSubScriptLoader);\n\n       // Import the script, don't pollute the global scope.\n       securableModule = {__proto__: global};\n       loader.loadSubScript(securableModuleURI.spec, securableModule);\n       securableModule = securableModule.SecurableModule;\n     } else {\n       securableModule = {};\n       try {\n         Cu.import(securableModuleURI.spec, securableModule);\n       } catch (e if e.result == Cr.NS_ERROR_ILLEGAL_VALUE) {\n         Cu.reportError(\"Failed to load \" + securableModuleURI.spec);\n       }\n     }\n   }\n\n   if (false) // force the manifest-scanner to copy shims.js into the XPI\n     require(\"shims\");\n   var localFS = new securableModule.LocalFileSystem(myURI);\n   var shimsPath = localFS.resolveModule(null, \"shims\");\n   var shims = exports.shims = localFS.getFile(shimsPath);\n\n   shims.filename = shimsPath;\n\n   function unloadLoader(reason) {\n     this.require(\"unload\").send(reason);\n   }\n\n   function makeGetModuleExports(delegate) {\n     return function getModuleExports(basePath, module) {\n       switch (module) {\n       case \"chrome\":\n         var chrome = { Cc: Components.classes,\n                        Ci: Components.interfaces,\n                        Cu: Components.utils,\n                        Cr: Components.results,\n                        Cm: Components.manager,\n                        components: Components };\n         return chrome;\n       case \"parent-loader\":\n         return this;\n       default:\n         return (delegate ? delegate.call(this, basePath, module) : null);\n       }\n     };\n   }\n\n   function modifyModuleSandbox(sandbox, options) {\n     sandbox.evaluate(shims);\n     var filename = options.filename ? options.filename : null;\n     sandbox.defineProperty(\"__url__\", filename);\n   }\n\n   var Loader = exports.Loader = function Loader(options) {\n     var globals = {};\n\n     if (options.globals)\n       for (var name in options.globals)\n         globals[name] = options.globals[name];\n\n     if (options.console)\n       globals.console = options.console;\n     if (options.memory)\n       globals.memory = options.memory;\n\n     if ('modules' in options)\n       throw new Error('options.modules is no longer supported');\n\n     var getModuleExports = makeGetModuleExports(options.getModuleExports);\n\n     var manifest = {};\n     if (\"packaging\" in options)\n       manifest = options.packaging.options.manifest;\n     var loaderOptions = {rootPath: options.rootPath,\n                          rootPaths: options.rootPaths,\n                          metadata: options.metadata,\n                          uriPrefix: options.uriPrefix,\n                          name: options.name,\n                          fs: options.fs,\n                          defaultPrincipal: \"system\",\n                          globals: globals,\n                          modifyModuleSandbox: modifyModuleSandbox,\n                          manifest: manifest,\n                          getModuleExports: getModuleExports};\n\n     var loader = new securableModule.Loader(loaderOptions);\n\n     if (!globals.console) {\n       var console = loader.require(\"plain-text-console\");\n       globals.console = new console.PlainTextConsole(options.print);\n     }\n     if (!globals.memory)\n       globals.memory = loader.require(\"memory\");\n\n     loader.console = globals.console;\n     loader.memory = globals.memory;\n     loader.unload = unloadLoader;\n\n     return loader;\n   };\n\n   if (global.window) {\n     // We're being loaded in a chrome window, or a web page with\n     // UniversalXPConnect privileges.\n     global.Cuddlefish = exports;\n   } else if (global.exports) {\n     // We're being loaded in a SecurableModule.\n     for (name in exports) {\n       global.exports[name] = exports[name];\n     }\n   } else {\n     // We're being loaded in a JS module.\n     global.EXPORTED_SYMBOLS = [];\n     for (name in exports) {\n       global.EXPORTED_SYMBOLS.push(name);\n       global[name] = exports[name];\n     }\n   }\n })(this);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "cuddlefish"
    }
  }, 
  {
    "pk": 10, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\n// Utility function that returns copy of the given `text` with last character\n// removed if it is `\"s\"`.\nfunction singularify(text) {\n  return text[text.length - 1] === \"s\" ? text.substr(0, text.length - 1) : text;\n}\n\n// Utility function that takes event type, argument is passed to\n// `document.createEvent` and returns name of the initializer method of the\n// given event. Please note that there are some event types whose initializer\n// methods can't be guessed by this function. For more details see following\n// link: https://developer.mozilla.org/En/DOM/Document.createEvent\nfunction getInitializerName(category) {\n  return \"init\" + singularify(category);\n}\n\n/**\n * Registers an event `listener` on a given `element`, that will be called\n * when events of specified `type` is dispatched on the `element`.\n * @param {Element} element\n *    Dom element to register listener on.\n * @param {String} type\n *    A string representing the\n *    [event type](https://developer.mozilla.org/en/DOM/event.type) to\n *    listen for.\n * @param {Function} listener\n *    Function that is called whenever an event of the specified `type` \n *    occurs.\n * @param {Boolean} capture\n *    If true, indicates that the user wishes to initiate capture. After\n *    initiating capture, all events of the specified type will be dispatched\n *    to the registered listener before being dispatched to any `EventTarget`s\n *    beneath it in the DOM tree. Events which are bubbling upward through\n *    the tree will not trigger a listener designated to use capture.\n *    See [DOM Level 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n *    for a detailed explanation.\n */\nfunction on(element, type, listener, capture) {\n  // `capture` defaults to `false`.\n  capture = capture || false;\n  element.addEventListener(type, listener, capture);\n}\nexports.on = on;\n\n/**\n * Registers an event `listener` on a given `element`, that will be called\n * only once, next time event of specified `type` is dispatched on the\n * `element`.\n * @param {Element} element\n *    Dom element to register listener on.\n * @param {String} type\n *    A string representing the\n *    [event type](https://developer.mozilla.org/en/DOM/event.type) to\n *    listen for.\n * @param {Function} listener\n *    Function that is called whenever an event of the specified `type` \n *    occurs.\n * @param {Boolean} capture\n *    If true, indicates that the user wishes to initiate capture. After\n *    initiating capture, all events of the specified type will be dispatched\n *    to the registered listener before being dispatched to any `EventTarget`s\n *    beneath it in the DOM tree. Events which are bubbling upward through\n *    the tree will not trigger a listener designated to use capture.\n *    See [DOM Level 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n *    for a detailed explanation.\n */\nfunction once(element, type, listener, capture) {\n  on(element, type, function selfRemovableListener(event) {\n    removeListener(element, type, selfRemovableListener, capture);\n    listener.apply(this, arguments);\n  }, capture);\n}\nexports.once = once;\n\n/**\n * Unregisters an event `listener` on a given `element` for the events of the\n * specified `type`.\n *\n * @param {Element} element\n *    Dom element to unregister listener from.\n * @param {String} type\n *    A string representing the\n *    [event type](https://developer.mozilla.org/en/DOM/event.type) to\n *    listen for.\n * @param {Function} listener\n *    Function that is called whenever an event of the specified `type` \n *    occurs.\n * @param {Boolean} capture\n *    If true, indicates that the user wishes to initiate capture. After\n *    initiating capture, all events of the specified type will be dispatched\n *    to the registered listener before being dispatched to any `EventTarget`s\n *    beneath it in the DOM tree. Events which are bubbling upward through\n *    the tree will not trigger a listener designated to use capture.\n *    See [DOM Level 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n *    for a detailed explanation.\n */\nfunction removeListener(element, type, listener, capture) {\n  element.removeEventListener(type, listener, capture);\n}\nexports.removeListener = removeListener;\n\n/**\n * Emits event of the specified `type` and `category` on the given `element`.\n * Specified `settings` are used to initialize event before dispatching it.\n * @param {Element} element\n *    Dom element to dispatch event on.\n * @param {String} type\n *    A string representing the\n *    [event type](https://developer.mozilla.org/en/DOM/event.type).\n * @param {Object} options\n *    Options object containing following properties:\n *    - `category`: String passed to the `document.createEvent`. Option is\n *      optional and defaults to \"UIEvents\".\n *    - `initializer`: If passed it will be used as name of the method used\n *      to initialize event. If omitted name will be generated from the\n *      `category` field by prefixing it with `\"init\"` and removing last\n *      character if it matches `\"s\"`.\n *    - `settings`: Array of settings that are forwarded to the event\n *      initializer after firs `type` argument.\n * @see https://developer.mozilla.org/En/DOM/Document.createEvent\n */\nfunction emit(element, type, { category, initializer, settings }) {\n  category = category || \"UIEvents\";\n  initializer = initializer || getInitializerName(category);\n  let document = element.ownerDocument;\n  let event = document.createEvent(category);\n  event[initializer].apply(event, [type].concat(settings));\n  element.dispatchEvent(event);\n};\nexports.emit = emit;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "dom/events"
    }
  }, 
  {
    "pk": 11, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { emit } = require(\"dom/events\");\nconst { getCodeForKey, toJSON } = require(\"keyboard/utils\");\nconst { has } = require(\"array\");\nconst { isString } = require(\"type\");\n\nconst INITIALIZER = \"initKeyEvent\";\nconst CATEGORY = \"KeyboardEvent\";\n\nfunction Options(options) {\n  if (!isString(options))\n    return options;\n\n  var { key, modifiers } = toJSON(options);\n  return {\n    key: key,\n    control: has(modifiers, \"control\"),\n    alt: has(modifiers, \"alt\"),\n    shift: has(modifiers, \"shift\"),\n    meta: has(modifiers, \"meta\")\n  };\n}\n\nvar keyEvent = exports.keyEvent = function keyEvent(element, type, options) {\n\n  emit(element, type, {\n    initializer: INITIALIZER,\n    category: CATEGORY,\n    settings: [\n      !(\"bubbles\" in options) || options.bubbles !== false,\n      !(\"cancelable\" in options) || options.cancelable !== false,\n      \"window\" in options && options.window ? options.window : null,\n      \"control\" in options && !!options.control,\n      \"alt\" in options && !!options.alt,\n      \"shift\" in options && !!options.shift,\n      \"meta\" in options && !!options.meta,\n      getCodeForKey(options.key) || 0,\n      options.key.charCodeAt(0)\n    ]\n  });\n}\n\nexports.keyDown = function keyDown(element, options) {\n  keyEvent(element, \"keydown\", Options(options));\n};\n\nexports.keyUp = function keyUp(element, options) {\n  keyEvent(element, \"keyup\", Options(options));\n};\n\nexports.keyPress = function keyPress(element, options) {\n  keyEvent(element, \"keypress\", Options(options));\n};\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "dom/events/keys"
    }
  }, 
  {
    "pk": 33, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nlet {Cc, Ci, Cr} = require('chrome');\n\nlet url = require(\"url\");\nlet file = require(\"file\");\nlet errors = require(\"errors\");\n\nlet jetpackService = Cc[\"@mozilla.org/jetpack/service;1\"]\n                     .getService(Ci.nsIJetpackService);\n\nfunction AddonProcess(jetpack) {\n  var syncListeners = {};\n\n  this.on = function(name, cb) {\n    jetpack.registerReceiver(name, function() {\n      try {\n        // Intentionally do not return the return value of\n        // the function; we want developers to use registerCall() for that.\n        cb.apply(undefined, arguments);\n      } catch (e) {\n        console.exception(e);\n      }\n    });\n  };\n\n  this.registerCall = function(name, cb) {\n    if (name in syncListeners)\n      throw new Error(\"call already registered for '\" + name + \"'\");\n    syncListeners[name] = true;\n    jetpack.registerReceiver(name, errors.catchAndReturn(cb));\n  };\n\n  this.send = function() {\n    return jetpack.sendMessage.apply(this, arguments);\n  };\n  \n  this.createHandle = function() {\n    return jetpack.createHandle();\n  };\n\n  this.destroy = function() {\n    try {\n      jetpack.destroy();\n    } catch (e if e.result == Cr.NS_ERROR_NOT_INITIALIZED) {}\n  };\n}\n\nfunction makeScriptFrom(fs, moduleURL) {\n  // TODO: Why can't we just return fs.getFile(moduleURL) here?\n  return {\n    filename: moduleURL,\n    contents: fs.getFile(moduleURL).contents\n  };\n}\n\nvar defaultConsole = console;\n\nexports.AddonProcess = function createAddonProcess(options) {\n  if (!options)\n    options = {};\n\n  var jetpack = jetpackService.createJetpack();  \n  var process = new AddonProcess(jetpack);\n  var registeredModules = {};\n\n  var console = options.console || defaultConsole;\n  var pkg = options.packaging || packaging;\n\n  // Whenever our add-on is disabled or uninstalled, we want to\n  // destroy the remote process.\n\n  require(\"unload\").when(function() {\n                           process.destroy();\n                           process = null;\n                         });\n\n  // Set up message receivers that the remote process will use to\n  // communicate with us.\n\n  ['log', 'debug', 'info', 'warn', 'error'].forEach(function(method) {\n    process.on(\"console:\" + method, function(name, args) {\n      console[method].apply(console, args);\n    });\n  });\n\n  function remoteException(exception) {\n    return {\n      toString: function toString() {\n        return \"Error: \" + this.message;\n      },\n      __proto__: exception\n    };\n  }\n  \n  process.on(\"quit\", function(name, status) {\n    if (options.quit)\n      options.quit(status);\n  });\n\n  process.on(\"console:trace\", function(name, exception) {\n    var traceback = require(\"traceback\");\n    var stack = traceback.fromException(remoteException(exception));\n    console.log(traceback.format(stack.slice(0, -2)));\n  });\n\n  process.on(\"console:exception\", function(name, exception) {\n    console.exception(remoteException(exception));\n  });\n  \n  jetpack.registerReceiver(\"dump\", function(name, msg) {\n    dump(msg);\n  });\n\n  jetpack.registerReceiver(\n    \"core:exception\",\n    function(name, exception) {\n      console.log(\"An exception occurred in the child Jetpack process.\");\n      console.exception(remoteException(exception));\n    });\n\n  process.registerCall(\n    \"require\",\n    function(name, base, path) {\n      var loader = options.loader || require(\"parent-loader\");\n      var parentFS = loader.fs;\n      var moduleURL = parentFS.resolveModule(base, path);\n\n      if (!moduleURL)\n        return {code: \"not-found\"};\n\n      var moduleInfo = pkg.getModuleInfo(moduleURL);\n      var moduleName = path;\n\n      function maybeImportAdapterModule() {\n        var adapterModuleName = moduleName + \"-e10s-adapter\";\n        var adapterModuleURL = parentFS.resolveModule(base,\n                                                      adapterModuleName);\n        var adapterModuleInfo = null;\n        if (adapterModuleURL)\n          adapterModuleInfo = pkg.getModuleInfo(adapterModuleURL);\n\n        if (moduleInfo['e10s-adapter'] != adapterModuleURL) {\n          console.warn(\"Adapter module URL is \" + adapterModuleURL +\n                       \" but expected \" + moduleInfo['e10s-adapter']);\n          return {code: \"error\"};\n        }\n\n        if (adapterModuleInfo) {\n          // e10s adapter found!\n          try {\n            if (!(adapterModuleURL in registeredModules)) {\n              // This e10s adapter has already been loaded for this\n              // addon process, and we only really need to give it the\n              // absolute URL of the adapter.\n              registeredModules[adapterModuleURL] = true;\n              loader.require(adapterModuleName).register(process);\n            }\n          } catch (e) {\n            console.exception(e);\n            return {code: \"error\"};\n          }\n          return {\n            code: \"ok\",\n            needsMessaging: true,\n            script: makeScriptFrom(parentFS, adapterModuleURL)\n          };\n        }\n        \n        return null;\n      }\n\n      if (moduleInfo) {\n        if (moduleInfo.needsChrome) {\n          return maybeImportAdapterModule() || {code: \"access-denied\"};\n        } else {\n\n          // Even if a module doesn't explicitly require chrome privileges, if\n          // an e10s adapter exists for it, use it, because said module might\n          // import other modules that require chrome.\n          //\n          // In the future we may want to look at the module's dependencies to\n          // determine whether importing an adapter is a better idea.\n\n          return maybeImportAdapterModule() || {\n            code: \"ok\",\n            needsMessaging: false,\n            script: makeScriptFrom(parentFS, moduleURL)\n          };\n        }\n      } else {\n        return maybeImportAdapterModule() || {code: \"not-found\"};\n      }\n    });\n\n  var bootURL = require(\"self\").data.url(\"bootstrap-remote-process.js\");\n  var bootFilename = url.toFilename(bootURL);\n  var bootJS = file.read(bootFilename);\n\n  // The try ... catch is a workaround for bug 589308.\n  jetpack.evalScript('//@line 1 \"' + bootFilename + '\"\\n' +\n                     \"try { \" + bootJS + \" } catch (e) { \" +\n                     \"sendMessage('core:exception', e); }\");\n\n  process.send(\"addInjectedSandboxScript\",\n               require(\"cuddlefish\").shimsCode);\n\n  return process;\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "e10s"
    }
  }, 
  {
    "pk": 2, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nfunction logToConsole(e) {\n  console.exception(e);\n}\n\nvar catchAndLog = exports.catchAndLog = function(callback,\n                                                 defaultResponse,\n                                                 logException) {\n  if (!logException)\n    logException = logToConsole;\n\n  return function() {\n    try {\n      return callback.apply(this, arguments);\n    } catch (e) {\n      logException(e);\n      return defaultResponse;\n    }\n  };\n};\n\nexports.catchAndLogProps = function catchAndLogProps(object,\n                                                     props,\n                                                     defaultResponse,\n                                                     logException) {\n  if (typeof(props) == \"string\")\n    props = [props];\n  props.forEach(\n    function(property) {\n      object[property] = catchAndLog(object[property],\n                                     defaultResponse,\n                                     logException);\n    });\n};\n\n/**\n * Catch and return an exception while calling the callback.  If the callback\n * doesn't throw, return the return value of the callback in a way that makes it\n * possible to distinguish between a return value and an exception.\n *\n * This function is useful when you need to pass the result of a call across\n * a process boundary (across which exceptions don't propagate).  It probably\n * doesn't need to be factored out into this module, since it is only used by\n * a single caller, but putting it here works around bug 625560.\n */\nexports.catchAndReturn = function(callback) {\n  return function() {\n    try {\n      return { returnValue: callback.apply(this, arguments) };\n    }\n    catch (exception) {\n      return { exception: exception };\n    }\n  };\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "errors"
    }
  }, 
  {
    "pk": 17, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst ERROR_TYPE = 'error',\n      UNCAUGHT_ERROR = 'An error event was dispatched for which there was'\n        + ' no listener.',\n      BAD_LISTENER = 'The event listener must be a function.';\n/**\n * This object is used to create an `EventEmitter` that, useful for composing\n * objects that emit events. It implements an interface like `EventTarget` from\n * DOM Level 2, which is implemented by Node objects in implementations that\n * support the DOM Event Model.\n * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n * @see http://nodejs.org/api.html#EventEmitter\n * @see http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/events/EventDispatcher.html\n */\nconst eventEmitter =  {\n  /**\n   * Registers an event `listener` that is called every time events of\n   * specified `type` are emitted.\n   * @param {String} type\n   *    The type of event.\n   * @param {Function} listener\n   *    The listener function that processes the event.\n   * @example\n   *      worker.on('message', function (data) {\n   *          console.log('data received: ' + data)\n   *      })\n   */\n  on: function on(type, listener) {\n    if ('function' !== typeof listener)\n      throw new Error(BAD_LISTENER);\n    let listeners = this._listeners(type);\n    if (0 > listeners.indexOf(listener))\n      listeners.push(listener);\n    // Use of `_public` is required by the legacy traits code that will go away\n    // once bug-637633 is fixed.\n    return this._public || this;\n  },\n\n  /**\n   * Registers an event `listener` that is called once the next time an event\n   * of the specified `type` is emitted.\n   * @param {String} type\n   *    The type of the event.\n   * @param {Function} listener\n   *    The listener function that processes the event.\n   */\n  once: function once(type, listener) {\n    this.on(type, function selfRemovableListener() {\n      this.removeListener(type, selfRemovableListener);\n      listener.apply(this, arguments);\n    });\n  },\n\n  /**\n   * Unregister `listener` for the specified event type.\n   * @param {String} type\n   *    The type of event.\n   * @param {Function} listener\n   *    The listener function that processes the event.\n   */\n  removeListener: function removeListener(type, listener) {\n    if ('function' !== typeof listener)\n      throw new Error(BAD_LISTENER);\n    let listeners = this._listeners(type),\n        index = listeners.indexOf(listener);\n    if (0 <= index)\n      listeners.splice(index, 1);\n    // Use of `_public` is required by the legacy traits code, that will go away\n    // once bug-637633 is fixed.\n    return this._public || this;\n  },\n\n  /**\n   * Hash of listeners on this EventEmitter.\n   */\n  _events: null,\n\n  /**\n   * Returns an array of listeners for the specified event `type`. This array\n   * can be manipulated, e.g. to remove listeners.\n   * @param {String} type\n   *    The type of event.\n   */\n  _listeners: function listeners(type) {\n    let events = this._events || (this._events = {});\n    return events[type] || (events[type] = []);\n  },\n\n  /**\n   * Execute each of the listeners in order with the supplied arguments.\n   * Returns `true` if listener for this event was called, `false` if there are\n   * no listeners for this event `type`.\n   *\n   * All the exceptions that are thrown by listeners during the emit\n   * are caught and can be handled by listeners of 'error' event. Thrown\n   * exceptions are passed as an argument to an 'error' event listener.\n   * If no 'error' listener is registered exception will propagate to a\n   * caller of this method.\n   *\n   * **It's recommended to have a default 'error' listener in all the complete\n   * composition that in worst case may dump errors to the console.**\n   *\n   * @param {String} type\n   *    The type of event.\n   * @params {Object|Number|String|Boolean}\n   *    Arguments that will be passed to listeners.\n   * @returns {Boolean}\n   */\n  _emit: function _emit(type, event) {\n    let args = Array.slice(arguments);\n    // Use of `_public` is required by the legacy traits code that will go away\n    // once bug-637633 is fixed.\n    args.unshift(this._public || this);\n    return this._emitOnObject.apply(this, args);\n  },\n\n  /**\n   * A version of _emit that lets you specify the object on which listeners are\n   * called.  This is a hack that is sometimes necessary when such an object\n   * (exports, for example) cannot be an EventEmitter for some reason, but other\n   * object(s) managing events for the object are EventEmitters.  Once bug\n   * 577782 is fixed, this method shouldn't be necessary.\n   *\n   * @param {object} targetObj\n   *    The object on which listeners will be called.\n   * @param {string} type\n   *    The event name.\n   * @param {value} event\n   *    The first argument to pass to listeners.\n   * @param {value} ...\n   *    More arguments to pass to listeners.\n   * @returns {boolean}\n   */\n  _emitOnObject: function _emitOnObject(targetObj, type, event /* , ... */) {\n    let listeners = this._listeners(type).slice(0);\n    // If there is no 'error' event listener then throw.\n    if (type === ERROR_TYPE && !listeners.length)\n      console.exception(event);\n    if (!listeners.length)\n      return false;\n    let params = Array.slice(arguments, 2);\n    for each (let listener in listeners) {\n      try {\n        listener.apply(targetObj, params);\n      } catch(e) {\n        this._emit('error', e);\n      }\n    }\n    return true;\n  },\n\n  /**\n   * Removes all the event listeners for the specified event `type`.\n   * @param {String} type\n   *    The type of event.\n   */\n  _removeAllListeners: function _removeAllListeners(type) {\n    this._listeners(type).splice(0);\n    return this;\n  }\n};\nexports.EventEmitter = require(\"traits\").Trait.compose(eventEmitter);\nexports.EventEmitterTrait = require('light-traits').Trait(eventEmitter);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "events"
    }
  }, 
  {
    "pk": 56, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Trait } = require(\"light-traits\");\nconst { removeListener, on } = require(\"dom/events\");\n\n/**\n * Trait may be used for building objects / composing traits that wish to handle\n * multiple dom events from multiple event targets in one place. Event targets\n * can be added / removed by calling `observe / ignore` methods. Composer should\n * provide array of event types it wishes to handle as property\n * `supportedEventsTypes` and function for handling all those events as\n * `handleEvent` property.\n */\nexports.DOMEventAssembler = Trait({\n  /**\n   * Function that is supposed to handle all the supported events (that are\n   * present in the `supportedEventsTypes`) from all the observed\n   * `eventTargets`.\n   * @param {Event} event\n   *    Event being dispatched.\n   */\n  handleEvent: Trait.required,\n  /**\n   * Array of supported event names.\n   * @type {String[]}\n   */\n  supportedEventsTypes: Trait.required,\n  /**\n   * Adds `eventTarget` to the list of observed `eventTarget`s. Listeners for\n   * supported events will be registered on the given `eventTarget`.\n   * @param {EventTarget} eventTarget\n   */\n  observe: function observe(eventTarget) {\n    this.supportedEventsTypes.forEach(function(eventType) {\n      on(eventTarget, eventType, this);\n    }, this);\n  },\n  /**\n   * Removes `eventTarget` from the list of observed `eventTarget`s. Listeners\n   * for all supported events will be unregistered from the given `eventTarget`.\n   * @param {EventTarget} eventTarget\n   */\n  ignore: function ignore(eventTarget) {\n    this.supportedEventsTypes.forEach(function(eventType) {\n      removeListener(eventTarget, eventType, this);\n    }, this);\n  }\n});\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "events/assembler"
    }
  }, 
  {
    "pk": 46, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is nsINarwhal.\n *\n * The Initial Developer of the Original Code is\n * Irakli Gozalishvili <rfobic@gmail.com>.\n * Portions created by the Initial Developer are Copyright (C) 2009\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <rfobic@gmail.com>\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\nconst byteStreams = require(\"byte-streams\");\nconst textStreams = require(\"text-streams\");\n\n// Flags passed when opening a file.  See nsprpub/pr/include/prio.h.\nconst OPEN_FLAGS = {\n  RDONLY: 0x01,\n  WRONLY: 0x02,\n  CREATE_FILE: 0x08,\n  APPEND: 0x10,\n  TRUNCATE: 0x20,\n  EXCL: 0x80\n};\n\nvar dirsvc = Cc[\"@mozilla.org/file/directory_service;1\"]\n             .getService(Ci.nsIProperties);\n\nfunction MozFile(path) {\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  return file;\n}\n\nfunction ensureReadable(file) {\n  if (!file.isReadable())\n    throw new Error(\"path is not readable: \" + file.path);\n}\n\nfunction ensureDir(file) {\n  ensureExists(file);\n  if (!file.isDirectory())\n    throw new Error(\"path is not a directory: \" + file.path);\n}\n\nfunction ensureFile(file) {\n  ensureExists(file);\n  if (!file.isFile())\n    throw new Error(\"path is not a file: \" + file.path);\n}\n\nfunction ensureExists(file) {\n  if (!file.exists())\n    throw friendlyError(Cr.NS_ERROR_FILE_NOT_FOUND, file.path);\n}\n\nfunction friendlyError(errOrResult, filename) {\n  var isResult = typeof(errOrResult) === \"number\";\n  var result = isResult ? errOrResult : errOrResult.result;\n  switch (result) {\n  case Cr.NS_ERROR_FILE_NOT_FOUND:\n    return new Error(\"path does not exist: \" + filename);\n  }\n  return isResult ? new Error(\"XPCOM error code: \" + errOrResult) : errOrResult;\n}\n\nexports.exists = function exists(filename) {\n  return MozFile(filename).exists();\n};\n\nexports.isFile = function isFile(filename) {\n  return MozFile(filename).isFile();\n};\n\nexports.read = function read(filename, mode) {\n  if (typeof(mode) !== \"string\")\n    mode = \"\";\n\n  // Ensure mode is read-only.\n  mode = /b/.test(mode) ? \"b\" : \"\";\n\n  var stream = exports.open(filename, mode);\n  try {\n    var str = stream.read();\n  }\n  finally {\n    stream.close();\n  }\n\n  return str;\n};\n\nexports.join = function join(base) {\n  if (arguments.length < 2)\n    throw new Error(\"need at least 2 args\");\n  base = MozFile(base);\n  for (var i = 1; i < arguments.length; i++)\n    base.append(arguments[i]);\n  return base.path;\n};\n\nexports.dirname = function dirname(path) {\n  var parent = MozFile(path).parent;\n  return parent ? parent.path : \"\";\n};\n\nexports.basename = function basename(path) {\n  var leafName = MozFile(path).leafName;\n\n  // On Windows, leafName when the path is a volume letter and colon (\"c:\") is\n  // the path itself.  But such a path has no basename, so we want the empty\n  // string.\n  return leafName == path ? \"\" : leafName;\n};\n\nexports.list = function list(path) {\n  var file = MozFile(path);\n  ensureDir(file);\n  ensureReadable(file);\n\n  var entries = file.directoryEntries;\n  var entryNames = [];\n  while(entries.hasMoreElements()) {\n    var entry = entries.getNext();\n    entry.QueryInterface(Ci.nsIFile);\n    entryNames.push(entry.leafName);\n  }\n  return entryNames;\n};\n\nexports.open = function open(filename, mode) {\n  var file = MozFile(filename);\n  if (typeof(mode) !== \"string\")\n    mode = \"\";\n\n  // File opened for write only.\n  if (/w/.test(mode)) {\n    if (file.exists())\n      ensureFile(file);\n    var stream = Cc['@mozilla.org/network/file-output-stream;1'].\n                 createInstance(Ci.nsIFileOutputStream);\n    var openFlags = OPEN_FLAGS.WRONLY |\n                    OPEN_FLAGS.CREATE_FILE |\n                    OPEN_FLAGS.TRUNCATE;\n    var permFlags = 0644; // u+rw go+r\n    try {\n      stream.init(file, openFlags, permFlags, 0);\n    }\n    catch (err) {\n      throw friendlyError(err, filename);\n    }\n    return /b/.test(mode) ?\n           new byteStreams.ByteWriter(stream) :\n           new textStreams.TextWriter(stream);\n  }\n\n  // File opened for read only, the default.\n  ensureFile(file);\n  stream = Cc['@mozilla.org/network/file-input-stream;1'].\n           createInstance(Ci.nsIFileInputStream);\n  try {\n    stream.init(file, OPEN_FLAGS.RDONLY, 0, 0);\n  }\n  catch (err) {\n    throw friendlyError(err, filename);\n  }\n  return /b/.test(mode) ?\n         new byteStreams.ByteReader(stream) :\n         new textStreams.TextReader(stream);\n};\n\nexports.remove = function remove(path) {\n  var file = MozFile(path);\n  ensureFile(file);\n  file.remove(false);\n};\n\nexports.mkpath = function mkpath(path) {\n  var file = MozFile(path);\n  if (!file.exists())\n    file.create(Ci.nsIFile.DIRECTORY_TYPE, 0755); // u+rwx go+rx\n  else if (!file.isDirectory())\n    throw new Error(\"The path already exists and is not a directory: \" + path);\n};\n\nexports.rmdir = function rmdir(path) {\n  var file = MozFile(path);\n  ensureDir(file);\n  try {\n    file.remove(false);\n  }\n  catch (err) {\n    // Bug 566950 explains why we're not catching a specific exception here.\n    throw new Error(\"The directory is not empty: \" + path);\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "file"
    }
  }, 
  {
    "pk": 13, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// this file left intentionally blank\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "find-tests"
    }
  }, 
  {
    "pk": 60, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (this.chrome) {\n  var timer = require(\"timer\");\n  var ut = require(\"unit-test\");\n\n  chrome.on(\n    \"runTest\",\n    function(name, test) {\n      var runner = new ut.TestRunner();\n      runner.start({\n        test: test.testHandle,\n        onDone: function() {\n          test.passed = runner.test.passed;\n          test.failed = runner.test.failed;\n          test.errors = runner.test.errors;\n          chrome.send(\"testDone\", test);\n        }\n      });\n    });\n    \n  exports.main = function(options, callbacks) {\n    function makeTest(suite, name, test) {\n      return function runTest(runner) {\n        console.info(\"executing '\" + suite + \".\" + name + \"' remotely\");\n        test(runner);\n      };\n    }\n\n    var tests = [];\n\n    options.suites.forEach(function(suite) {\n      var module = require(suite);\n      for (testName in module) {\n        var handle = chrome.createHandle();\n        handle.testFunction = makeTest(suite, testName, module[testName]);\n        handle.name = suite + \".\" + testName;\n        tests.push({testHandle: handle, name: handle.name});\n      }\n    });\n    chrome.send(\"testsFound\", tests, options.finderHandle);\n  }\n} else {\n  exports.register = function(addon) {\n    addon.on(\"testDone\", function(name, remoteTest) {\n      var runner = remoteTest.testHandle.runner;\n      runner.passed += remoteTest.passed;\n      runner.failed += remoteTest.failed;\n      runner.test.passed = remoteTest.passed;\n      runner.test.failed = remoteTest.failed;\n      runner.test.errors = remoteTest.errors;\n      runner.done();\n    });\n    addon.on(\"testPass\", function(name, remoteTest, msg) {\n      remoteTest.testHandle.runner.pass(msg);\n    });\n    addon.on(\"testFail\", function(name, remoteTest, msg) {\n      remoteTest.testHandle.runner.fail(msg);\n    });\n    addon.on(\"testsFound\", function(name, remoteTests,\n                                    finderHandle) {\n      var tests = [];\n      remoteTests.forEach(function(remoteTest) {\n        tests.push({\n          testFunction: function(runner) {\n            remoteTest.testHandle.runner = runner;\n            runner.waitUntilDone();\n            addon.send(\"runTest\", remoteTest);\n          },\n          name: remoteTest.name\n        });\n      });\n      finderHandle.onTestsFound(tests);\n    });\n  };\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "find-tests-e10s-adapter"
    }
  }, 
  {
    "pk": 69, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Felipe Gomes <felipc@gmail.com> (Original Author)\n *   Myk Melez <myk@mozilla.org>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc, Ci} = require(\"chrome\");\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\nconst timer = require(\"timer\");\n\nconst XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\";\n\nlet hostFrame, hostDocument, hiddenWindow, isHostFrameReady = false;\n\nif (!require(\"xul-app\").isOneOf([\"Firefox\", \"Thunderbird\"])) {\n  throw new Error([\n    \"The hidden-frame module currently supports only Firefox and Thunderbird. \",\n    \"In the future, we would like it to support other applications, however. \",\n    \"Please see https://bugzilla.mozilla.org/show_bug.cgi?id=546740 for more \",\n    \"information.\"\n  ].join(\"\"));\n}\n\nlet appShellService = Cc[\"@mozilla.org/appshell/appShellService;1\"].\n                        getService(Ci.nsIAppShellService);\nhiddenWindow = appShellService.hiddenDOMWindow;\n\nif (!hiddenWindow) {\n  throw new Error([\n    \"The hidden-frame module needs an app that supports a hidden window. \",\n    \"We would like it to support other applications, however. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=546740 for more information.\"\n  ].join(\"\"));\n}\n\n// Check if we can use the hidden window itself to host our iframes.\n// If it's not a suitable host, the hostFrame will be lazily created\n// by the first HiddenFrame instance.\nif (hiddenWindow.location.protocol == \"chrome:\" &&\n    (hiddenWindow.document.contentType == \"application/vnd.mozilla.xul+xml\" ||\n     hiddenWindow.document.contentType == \"application/xhtml+xml\")) {\n  hostFrame = hiddenWindow;\n  hostDocument = hiddenWindow.document;\n  isHostFrameReady = true;\n}\n\nfunction setHostFrameReady() {\n  hostDocument = hostFrame.contentDocument;\n  hostFrame.removeEventListener(\"DOMContentLoaded\", setHostFrameReady, false);\n  isHostFrameReady = true;\n}\n\n// This cache is used to access friend properties between functions\n// without exposing them on the public API.\nlet cache = [];\n\nexports.HiddenFrame = apiUtils.publicConstructor(HiddenFrame);\n\nfunction HiddenFrame(options) {\n  options = options || {};\n  let self = this;\n\n  for each (let [key, val] in Iterator(apiUtils.validateOptions(options, {\n    onReady: {\n      is: [\"undefined\", \"function\", \"array\"],\n      ok: function(v) {\n        if (apiUtils.getTypeOf(v) === \"array\") {\n          // make sure every item is a function\n          return v.every(function (item) typeof(item) === \"function\")\n        }\n        return true;\n      }\n    }\n  }))) {\n    if (typeof(val) != \"undefined\")\n      options[key] = val;\n  }\n\n  require(\"collection\").addCollectionProperty(this, \"onReady\");\n  if (options.onReady)\n    this.onReady.add(options.onReady);\n\n  if (!hostFrame) {\n    hostFrame = hiddenWindow.document.createElement(\"iframe\");\n\n    // ugly ugly hack. This is the most lightweight chrome:// file I could find on the tree\n    // This hack should be removed by proper platform support on bug 565388 \n    hostFrame.setAttribute(\"src\", \"chrome://global/content/mozilla.xhtml\");\n    hostFrame.addEventListener(\"DOMContentLoaded\", setHostFrameReady, false);\n\n    hiddenWindow.document.body.appendChild(hostFrame);\n  }\n\n  this.toString = function toString() \"[object Frame]\";\n}\n\nexports.add = function JP_SDK_Frame_add(frame) {\n  if (!(frame instanceof HiddenFrame))\n    throw new Error(\"The object to be added must be a HiddenFrame.\");\n\n  // This instance was already added.\n  if (cache.filter(function (v) v.frame === frame)[0])\n    return frame;\n\n  function createElement() {\n    hostFrame.removeEventListener(\"DOMContentLoaded\", createElement, false);\n\n    let element = hostDocument.createElementNS(XUL_NS, \"iframe\");\n\n    element.setAttribute(\"type\", \"content\");\n    hostDocument.documentElement.appendChild(element);\n\n    /* Public API: hiddenFrame.element */\n    frame.__defineGetter__(\"element\", function () element);\n\n    // Notify consumers that the frame is ready.\n    function onReadyListener(event) {\n      element.removeEventListener(\"DOMContentLoaded\", onReadyListener, false);\n      if (event.target == element.contentDocument) {\n        for (let handler in frame.onReady)\n          errors.catchAndLog(function () handler.call(frame))();\n      }\n    }\n    element.addEventListener(\"DOMContentLoaded\", onReadyListener, false);\n\n    cache.push({\n      frame: frame,\n      element: element,\n      unload: function unload() {\n        hostDocument.documentElement.removeChild(element);\n      }\n    });\n  }\n\n  /* Begin element construction or schedule it for later */\n  if (isHostFrameReady) {\n    createElement();\n  } else {\n    hostFrame.addEventListener(\"DOMContentLoaded\", createElement, false);\n  }\n\n  return frame;\n}\n\nexports.remove = function remove(frame) {\n  if (!(frame instanceof HiddenFrame))\n    throw new Error(\"The object to be removed must be a HiddenFrame.\");\n\n  let entry = cache.filter(function (v) v.frame === frame)[0];\n  if (!entry)\n    return;\n\n  entry.unload();\n  cache.splice(cache.indexOf(entry), 1);\n}\n\nrequire(\"unload\").when(function () {\n  for each (let entry in cache.slice())\n    exports.remove(entry.frame);\n\n  if (hostFrame && hostFrame !== hiddenWindow)\n    hiddenWindow.document.body.removeChild(hostFrame);\n});\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "hidden-frame"
    }
  }, 
  {
    "pk": 73, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *   Henri Wiechers <hwiechers@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst INVALID_HOTKEY = \"Hotkey must have at least one modifier.\";\n\nconst { toJSON: jsonify, toString: stringify } = require(\"keyboard/utils\");\nconst { register, unregister } = require(\"keyboard/hotkeys\");\n\nconst Hotkey = exports.Hotkey = function Hotkey(options) {\n  if (!(this instanceof Hotkey))\n    return new Hotkey(options);\n\n  // Parsing key combination string.\n  let hotkey = jsonify(options.combo);\n  if (!hotkey.modifiers.length) {\n    throw new TypeError(INVALID_HOTKEY);\n  }\n\n  this.onPress = options.onPress;\n  this.toString = stringify.bind(null, hotkey);\n  // Registering listener on keyboard combination enclosed by this hotkey.\n  // Please note that `this.toString()` is a normalized version of\n  // `options.combination` where order of modifiers is sorted and `accel` is\n  // replaced with platform specific key.\n  register(this.toString(), this.onPress);\n  // We freeze instance before returning it in order to make it's properties\n  // read-only.\n  return Object.freeze(this);\n};\nHotkey.prototype.destroy = function destroy() {\n  unregister(this.toString(), this.onPress);\n};\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "hotkeys"
    }
  }, 
  {
    "pk": 1, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// This is first module of the API Utils Library", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "index"
    }
  }, 
  {
    "pk": 71, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// This is first module of the Addon Kit Library", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "index"
    }
  }, 
  {
    "pk": 43, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *   Paul Vet <original.roju@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst keyboardObserver = require(\"keyboard/observer\");\nconst { getKeyForCode, normalize } = require(\"keyboard/utils\");\n\n/**\n * Register a global `hotkey` that executes `listener` when the key combination\n * in `hotkey` is pressed. If more then one `listener` is registered on the same\n * key combination only last one will be executed.\n *\n * @param {string} hotkey\n *    Key combination in the format of 'modifier key'.\n *\n * Examples:\n *\n *     \"accel s\"\n *     \"meta shift i\"\n *     \"control alt d\"\n *\n * Modifier keynames:\n *\n *  - **shift**: The Shift key.\n *  - **alt**: The Alt key. On the Macintosh, this is the Option key. On\n *    Macintosh this can only be used in conjunction with another modifier,\n *    since `Alt+Letter` combinations are reserved for entering special\n *    characters in text.\n *  - **meta**: The Meta key. On the Macintosh, this is the Command key.\n *  - **control**: The Control key.\n *  - **accel**: The key used for keyboard shortcuts on the user's platform,\n *    which is Control on Windows and Linux, and Command on Mac. Usually, this\n *    would be the value you would use.\n *\n * @param {function} listener\n *    Function to execute when the `hotkey` is executed.\n */\nexports.register = function register(hotkey, listener) {\n  hotkey = normalize(hotkey);\n  hotkeys[hotkey] = listener;\n};\n\n/**\n * Unregister a global `hotkey`. If passed `listener` is not the one registered\n * for the given `hotkey`, the call to this function will be ignored.\n *\n * @param {string} hotkey\n *    Key combination in the format of 'modifier key'.\n * @param {function} listener\n *    Function that will be invoked when the `hotkey` is pressed.\n */\nexports.unregister = function unregister(hotkey, listener) {\n  hotkey = normalize(hotkey);\n  if (hotkeys[hotkey] === listener)\n    delete hotkeys[hotkey];\n};\n\n/**\n * Map of hotkeys and associated functions.\n */\nconst hotkeys = exports.hotkeys = {};\n\nkeyboardObserver.on(\"keypress\", function onKeypress(event, window) {\n  let key, modifiers = [];\n  let isChar = \"isChar\" in event && event.isChar;\n  let which = \"which\" in event ? event.which : null;\n  let keyCode = \"keyCode\" in event ? event.keyCode : null;\n\n  if (\"shiftKey\" in event && event.shiftKey)\n    modifiers.push(\"shift\");\n  if (\"altKey\" in event && event.altKey)\n    modifiers.push(\"alt\");\n  if (\"ctrlKey\" in event && event.ctrlKey)\n    modifiers.push(\"control\");\n  if (\"metaKey\" in event && event.metaKey)\n    modifiers.push(\"meta\");\n\n  // If it's not a printable character then we fall back to a human readable\n  // equivalent of one of the following constants.\n  // http://mxr.mozilla.org/mozilla-central/source/dom/interfaces/events/nsIDOMKeyEvent.idl\n  if (!isChar)\n    key = getKeyForCode(keyCode);\n\n  // If don't have a key yet then it's either printable character so we just\n  // create a string from it's charcode. For some keys like \"!\" `isChar` is\n  // `false` but it's still printable and that's also a case when\n  // `getKeyForCode` returns `undefined`.\n  if (!key)\n    key = String.fromCharCode(which);\n\n\n  let combination = normalize({ key: key, modifiers: modifiers });\n  let hotkey = hotkeys[combination];\n\n  if (hotkey) {\n    try {\n      hotkey();\n    } catch (exception) {\n      console.exception(exception);\n    } finally {\n      // Work around bug 582052 by preventing the (nonexistent) default action.\n      event.preventDefault();\n    }\n  }\n});\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "keyboard/hotkeys"
    }
  }, 
  {
    "pk": 45, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Trait } = require(\"light-traits\");\nconst { EventEmitterTrait: EventEmitter } = require(\"events\");\nconst { DOMEventAssembler } = require(\"events/assembler\");\nconst { windowIterator } = require('window-utils');\nconst windowObserver = require(\"windows/observer\");\n\n// Event emitter objects used to register listeners and emit events on them\n// when they occur.\nconst observer = Trait.compose(DOMEventAssembler, EventEmitter).create({\n  /**\n   * Method is implemented by `EventEmitter` and is used just for emitting\n   * events on registered listeners.\n   */\n  _emit: Trait.required,\n  /**\n   * Events that are supported and emitted by the module.\n   */\n  supportedEventsTypes: [ \"keydown\", \"keyup\", \"keypress\" ],\n  /**\n   * Function handles all the supported events on all the windows that are\n   * observed. Method is used to proxy events to the listeners registered on\n   * this event emitter.\n   * @param {Event} event\n   *    Keyboard event being emitted.\n   */\n  handleEvent: function handleEvent(event) {\n    this._emit(event.type, event, event.target.ownerDocument.defaultView);\n  }\n});\n\n// Adding each opened window to a list of observed windows.\nwindowObserver.on(\"open\", observer.observe.bind(observer));\n// Removing each closed window form the list of observed windows.\nwindowObserver.on(\"close\", observer.ignore.bind(observer));\n\n// Making observer aware of already opened windows.\nfor each (let window in windowIterator())\n  observer.observe(window);\n\nrequire(\"unload\").when(function() { observer._events = {} });\n\nmodule.exports = observer;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "keyboard/observer"
    }
  }, 
  {
    "pk": 44, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *   Henri Wiechers <hwiechers@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Cc, Ci } = require(\"chrome\");\nconst runtime = require(\"runtime\");\nconst { isString } = require(\"type\");\nconst array = require(\"array\");\n\n\nconst SWP = \"{{SEPARATOR}}\";\nconst SEPARATOR = \"-\"\nconst INVALID_COMBINATION = \"Hotkey key combination must contain one or more \" +\n                            \"modifiers and only one key\";\n\n// Key codes for non printable chars.\n// @See: http://mxr.mozilla.org/mozilla-central/source/dom/interfaces/events/nsIDOMKeyEvent.idl\nconst DOM_VK_CODES = exports.DOM_VK_CODES = Ci.nsIDOMKeyEvent;\n\n// Map of modifier key mappings.\nconst MODIFIERS = exports.MODIFIERS = {\n  'accel': runtime.OS === \"Darwin\" ? 'meta' : 'control',\n  'meta': 'meta',\n  'control': 'control',\n  'ctrl': 'control',\n  'option': 'alt',\n  'command': 'meta',\n  'alt': 'alt',\n  'shift': 'shift'\n};\n\n// Map of keys that contain `_` chars.\nconst ALIAS_KEYS = exports.KEYS = {\n  'backspace': DOM_VK_CODES.BACK_SPACE,\n  'capslock': DOM_VK_CODES.CAPS_LOCK,\n  'pageup': DOM_VK_CODES.PAGE_UP,\n  'pagedown': DOM_VK_CODES.PAGE_DOWN,\n  'numlock': DOM_VK_CODES.NUM_LOCK,\n  'scrolllock': DOM_VK_CODES.SCROLL_LOCK\n};\n\nexports.getKeyForCode = function getKeyForCode(code) {\n  for (let key in DOM_VK_CODES) {\n    if (DOM_VK_CODES[key] === code) {\n      return key.substr(7).              // Remove DOM_VK_ part.\n                 replace(/_/g, '').      // Remove all the _ chars.\n                 toLowerCase();          // Lover casing the rest.\n    }\n  }\n};\n\nexports.getCodeForKey = function getCodeForKey(key) {\n  return key in ALIAS_KEYS ? ALIAS_KEYS[key] :\n         (key = \"DOM_VK_\" + key.toUpperCase()) in DOM_VK_CODES ?\n         DOM_VK_CODES[key] : undefined;\n};\n\n/**\n * Utility function that takes string or JSON that defines a `hotkey` and\n * returns normalized string version of it.\n * @param {JSON|String} hotkey\n * @param {String} [separator=\" \"]\n *    Optional string that represents separator used to concatenate keys in the\n *    given `hotkey`.\n * @returns {String}\n * @examples\n *\n *    require(\"keyboard/hotkeys\").normalize(\"b Shift accel\");\n *    // 'control shift b' -> on windows & linux\n *    // 'meta shift b'    -> on mac\n *    require(\"keyboard/hotkeys\").normalize(\"alt-d-shift\", \"-\");\n *    // 'alt shift d'\n */\nvar normalize = exports.normalize = function normalize(hotkey, separator) {\n  if (!isString(hotkey))\n    hotkey = toString(hotkey, separator);\n  return toString(toJSON(hotkey, separator), separator);\n};\n\n/*\n * Utility function that splits a string of characters that defines a `hotkey`\n * into modifier keys and the defining key.\n * @param {String} hotkey\n * @param {String} [separator=\" \"]\n *    Optional string that represents separator used to concatenate keys in the\n *    given `hotkey`.\n * @returns {JSON}\n * @examples\n *\n *    require(\"keyboard/hotkeys\").toJSON(\"accel shift b\");\n *    // { key: 'b', modifiers: [ 'control', 'shift' ] } -> on windows & linux\n *    // { key: 'b', modifiers: [ 'meta', 'shift' ] }    -> on mac\n *\n *    require(\"keyboard/hotkeys\").normalize(\"alt-d-shift\", \"-\");\n *    // { key: 'd', modifiers: [ 'alt', 'shift' ] }\n */\nvar toJSON = exports.toJSON = function toJSON(hotkey, separator) {\n  separator = separator || SEPARATOR;\n  // Since default separator is `-`, combination may take form of `alt--`. To\n  // avoid misbehavior we replace `--` with `-{{SEPARATOR}}` where\n  // `{{SEPARATOR}}` can be swapped later.\n  hotkey = hotkey.toLowerCase().replace(separator + separator, separator + SWP);\n\n  let value = {};\n  let modifiers = [];\n  let keys = hotkey.split(separator);\n  keys.forEach(function(name) {\n    // If name is `SEPARATOR` than we swap it back.\n    if (name === SWP)\n      name = separator;\n    if (name in MODIFIERS) {\n      array.add(modifiers, MODIFIERS[name]);\n    } else {\n      if (!value.key)\n        value.key = name;\n      else\n        throw new TypeError(INVALID_COMBINATION);\n    }\n  });\n\n  if (!value.key)\n      throw new TypeError(INVALID_COMBINATION);\n\n  value.modifiers = modifiers.sort();\n  return value;\n};\n\n/**\n * Utility function that takes object that defines a `hotkey` and returns\n * string representation of it.\n *\n * _Please note that this function does not validates data neither it normalizes\n * it, if you are unsure that data is well formed use `normalize` function\n * instead.\n *\n * @param {JSON} hotkey\n * @param {String} [separator=\" \"]\n *    Optional string that represents separator used to concatenate keys in the\n *    given `hotkey`.\n * @returns {String}\n * @examples\n *\n *    require(\"keyboard/hotkeys\").toString({\n *      key: 'b',\n *      modifiers: [ 'control', 'shift' ]\n *    }, '+');\n *    // 'control+shift+b\n *\n */\nvar toString = exports.toString = function toString(hotkey, separator) {\n  let keys = hotkey.modifiers.slice();\n  keys.push(hotkey.key);\n  return keys.join(separator || SEPARATOR);\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "keyboard/utils"
    }
  }, 
  {
    "pk": 68, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:ts=2:sts=2:sw=2:\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <rfobic@gmail.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\n// `var` is being used in the module in order to make it reusable in\n// environments in which `let` is not yet supported.\n\n// Shortcut to `Object.prototype.hasOwnProperty.call`.\n// owns(object, name) would be the same as\n// Object.prototype.hasOwnProperty.call(object, name);\nvar owns = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\n\n/**\n * Whether or not given property descriptors are equivalent. They are\n * equivalent either if both are marked as 'conflict' or 'required' property\n * or if all the properties of descriptors are equal.\n * @param {Object} actual\n * @param {Object} expected\n */\nfunction equivalentDescriptors(actual, expected) {\n  return (actual.conflict && expected.conflict) ||\n         (actual.required && expected.required) ||\n         equalDescriptors(actual, expected);\n}\n/**\n * Whether or not given property descriptors define equal properties.\n */\nfunction equalDescriptors(actual, expected) {\n  return actual.get === expected.get &&\n         actual.set === expected.set &&\n         actual.value === expected.value &&\n         !!actual.enumerable === !!expected.enumerable &&\n         !!actual.configurable === !!expected.configurable &&\n         !!actual.writable === !!expected.writable;\n}\n\n// Utilities that throwing exceptions for a properties that are marked\n// as \"required\" or \"conflict\" properties.\nfunction throwConflictPropertyError(name) {\n  throw new Error(\"Remaining conflicting property: `\" + name + \"`\");\n}\nfunction throwRequiredPropertyError(name) {\n  throw new Error(\"Missing required property: `\" + name + \"`\");\n}\n\n/**\n * Generates custom **required** property descriptor. Descriptor contains\n * non-standard property `required` that is equal to `true`.\n * @param {String} name\n *    property name to generate descriptor for.\n * @returns {Object}\n *    custom property descriptor\n */\nfunction RequiredPropertyDescriptor(name) {\n  // Creating function by binding first argument to a property `name` on the\n  // `throwConflictPropertyError` function. Created function is used as a\n  // getter & setter of the created property descriptor. This way we ensure\n  // that we throw exception late (on property access) if object with\n  // `required` property was instantiated using built-in `Object.create`.\n  var accessor = throwRequiredPropertyError.bind(null, name);\n  return { get: accessor, set: accessor, required: true };\n}\n\n/**\n * Generates custom **conflicting** property descriptor. Descriptor contains\n * non-standard property `conflict` that is equal to `true`.\n * @param {String} name\n *    property name to generate descriptor for.\n * @returns {Object}\n *    custom property descriptor\n */\nfunction ConflictPropertyDescriptor(name) {\n  // For details see `RequiredPropertyDescriptor` since idea is same.\n  var accessor = throwConflictPropertyError.bind(null, name);\n  return { get: accessor, set: accessor, conflict: true };\n}\n\n/**\n * Tests if property is marked as `required` property.\n */\nfunction isRequiredProperty(object, name) {\n  return !!object[name].required;\n}\n\n/**\n * Tests if property is marked as `conflict` property.\n */\nfunction isConflictProperty(object, name) {\n  return !!object[name].conflict;\n}\n\n/**\n * Function tests whether or not method of the `source` object with a given\n * `name` is inherited from `Object.prototype`.\n */\nfunction isBuiltInMethod(name, source) {\n  var target = Object.prototype[name];\n\n  // If methods are equal then we know it's `true`.\n  return target == source ||\n  // If `source` object comes form a different sandbox `==` will evaluate\n  // to `false`, in that case we check if functions names and sources match.\n         (String(target) === String(source) && target.name === source.name);\n}\n\n/**\n * Function overrides `toString` and `constructor` methods of a given `target`\n * object with a same-named methods of a given `source` if methods of `target`\n * object are inherited / copied from `Object.prototype`.\n * @see create\n */\nfunction overrideBuiltInMethods(target, source) {\n  if (isBuiltInMethod(\"toString\", target.toString)) {\n    Object.defineProperty(target, \"toString\",  {\n      value: source.toString,\n      configurable: true,\n      enumerable: false\n    });\n  }\n\n  if (isBuiltInMethod(\"constructor\", target.constructor)) {\n    Object.defineProperty(target, \"constructor\", {\n      value: source.constructor,\n      configurable: true,\n      enumerable: false\n    });\n  }\n}\n\n/**\n * Composes new trait with the same own properties as the original trait,\n * except that all property names appearing in the first argument are replaced\n * by \"required\" property descriptors.\n * @param {String[]} keys\n *    Array of strings property names.\n * @param {Object} trait\n *    A trait some properties of which should be excluded.\n * @returns {Object}\n * @example\n *    var newTrait = exclude([\"name\", ...], trait)\n */\nfunction exclude(names, trait) {\n  var map = {};\n\n  Object.keys(trait).forEach(function(name) {\n\n    // If property is not excluded (the array of names does not contain it),\n    // or it is a \"required\" property, copy it to the property descriptor `map`\n    // that will be used for creation of resulting trait.\n    if (!~names.indexOf(name) || isRequiredProperty(trait, name))\n      map[name] = { value: trait[name], enumerable: true };\n\n    // For all the `names` in the exclude name array we create required\n    // property descriptors and copy them to the `map`.\n    else\n      map[name] = { value: RequiredPropertyDescriptor(name), enumerable: true };\n  });\n\n  return Object.create(Trait.prototype, map);\n}\n\n/**\n * Composes new instance of `Trait` with a properties of a given `trait`,\n * except that all properties whose name is an own property of `renames` will\n * be renamed to `renames[name]` and a `\"required\"` property for name will be\n * added instead.\n *\n * For each renamed property, a required property is generated. If\n * the `renames` map two properties to the same name, a conflict is generated.\n * If the `renames` map a property to an existing unrenamed property, a\n * conflict is generated.\n *\n * @param {Object} renames\n *    An object whose own properties serve as a mapping from old names to new\n *    names.\n * @param {Object} trait\n *    A new trait with renamed properties.\n * @returns {Object}\n * @example\n *\n *    // Return trait with `bar` property equal to `trait.foo` and with\n *    // `foo` and `baz` \"required\" properties.\n *    var renamedTrait = rename({ foo: \"bar\", baz: null }), trait);\n *\n *    // t1 and t2 are equivalent traits\n *    var t1 = rename({a: \"b\"}, t);\n *    var t2 = compose(exclude([\"a\"], t), { a: { required: true }, b: t[a] });\n */\nfunction rename(renames, trait) {\n  var map = {};\n\n  // Loop over all the properties of the given `trait` and copy them to a\n  // property descriptor `map` that will be used for the creation of the\n  // resulting trait.  Also, rename properties in the `map` as specified by\n  // `renames`.\n  Object.keys(trait).forEach(function(name) {\n    var alias;\n\n    // If the property is in the `renames` map, and it isn't a \"required\"\n    // property (which should never need to be aliased because \"required\"\n    // properties never conflict), then we must try to rename it.\n    if (owns(renames, name) && !isRequiredProperty(trait, name)) {\n      alias = renames[name];\n\n      // If the `map` already has the `alias`, and it isn't a \"required\"\n      // property, that means the `alias` conflicts with an existing name for a\n      // provided trait (that can happen if >=2 properties are aliased to the\n      // same name). In this case we mark it as a conflicting property.\n      // Otherwise, everything is fine, and we copy property with an `alias`\n      // name.\n      if (owns(map, alias) && !map[alias].value.required) {\n        map[alias] = {\n          value: ConflictPropertyDescriptor(alias),\n          enumerable: true\n        };\n      }\n      else {\n        map[alias] = {\n          value: trait[name],\n          enumerable: true\n        };\n      }\n\n      // Regardless of whether or not the rename was successful, we check to\n      // see if the original `name` exists in the map (such a property\n      // could exist if previous another property was aliased to this `name`).\n      // If it isn't, we mark it as \"required\", to make sure the caller\n      // provides another value for the old name, which methods of the trait\n      // might continue to reference.\n      if (!owns(map, name)) {\n        map[name] = {\n          value: RequiredPropertyDescriptor(name),\n          enumerable: true\n        };\n      }\n    }\n\n    // Otherwise, either the property isn't in the `renames` map (thus the\n    // caller is not trying to rename it) or it is a \"required\" property.\n    // Either way, we don't have to alias the property, we just have to copy it\n    // to the map.\n    else {\n      // The property isn't in the map yet, so we copy it over.\n      if (!owns(map, name)) {\n        map[name] = { value: trait[name], enumerable: true };\n      }\n\n      // The property is already in the map (that means another property was\n      // aliased with this `name`, which creates a conflict if the property is\n      // not marked as \"required\"), so we have to mark it as a \"conflict\"\n      // property.\n      else if (!isRequiredProperty(trait, name)) {\n        map[name] = {\n          value: ConflictPropertyDescriptor(name),\n          enumerable: true\n        };\n      }\n    }\n  });\n  return Object.create(Trait.prototype, map);\n}\n\n/**\n * Composes new resolved trait, with all the same properties as the original\n * `trait`, except that all properties whose name is an own property of\n * `resolutions` will be renamed to `resolutions[name]`.\n *\n * If `resolutions[name]` is `null`, the value is mapped to a property\n * descriptor that is marked as a \"required\" property.\n */\nfunction resolve(resolutions, trait) {\n    var renames = {};\n    var exclusions = [];\n\n    // Go through each mapping in `resolutions` object and distribute it either\n    // to `renames` or `exclusions`.\n    Object.keys(resolutions).forEach(function(name) {\n\n      // If `resolutions[name]` is a truthy value then it's a mapping old -> new\n      // so we copy it to `renames` map.\n      if (resolutions[name])\n        renames[name] = resolutions[name];\n\n      // Otherwise it's not a mapping but an exclusion instead in which case we\n      // add it to the `exclusions` array.\n      else\n        exclusions.push(name);\n    });\n\n    // First `exclude` **then** `rename` and order is important since\n    // `exclude` and `rename` are not associative.\n    return rename(renames, exclude(exclusions, trait));\n}\n\n/**\n * Create a Trait (a custom property descriptor map) that represents the given\n * `object`'s own properties. Property descriptor map is a \"custom\", because it\n * inherits from `Trait.prototype` and it's property descriptors may contain\n * two attributes that is not part of the ES5 specification:\n *\n *  - \"required\" (this property must be provided by another trait\n *    before an instance of this trait can be created)\n *  - \"conflict\" (when the trait is composed with another trait,\n *    a unique value for this property is provided by two or more traits)\n *\n * Data properties bound to the `Trait.required` singleton exported by\n * this module will be marked as \"required\" properties.\n *\n * @param {Object} object\n *    Map of properties to compose trait from.\n * @returns {Trait}\n *    Trait / Property descriptor map containing all the own properties of the\n *    given argument.\n */\nfunction trait(object) {\n  var map;\n  var trait = object;\n\n  if (!(object instanceof Trait)) {\n    // If the passed `object` is not already an instance of `Trait`, we create\n    // a property descriptor `map` containing descriptors for the own properties\n    // of the given `object`.  `map` is then used to create a `Trait` instance\n    // after all properties are mapped.  Note that we can't create a trait and\n    // then just copy properties into it since that will fail for inherited\n    // read-only properties.\n    map = {};\n\n    // Each own property of the given `object` is mapped to a data property\n    // whose value is a property descriptor.\n    Object.keys(object).forEach(function (name) {\n\n      // If property of an `object` is equal to a `Trait.required`, it means\n      // that it was marked as \"required\" property, in which case we map it\n      // to \"required\" property.\n      if (Trait.required ==\n          Object.getOwnPropertyDescriptor(object, name).value) {\n        map[name] = {\n          value: RequiredPropertyDescriptor(name),\n          enumerable: true\n        };\n      }\n      // Otherwise property is mapped to it's property descriptor.\n      else {\n        map[name] = {\n          value: Object.getOwnPropertyDescriptor(object, name),\n          enumerable: true\n        };\n      }\n    });\n\n    trait = Object.create(Trait.prototype, map);\n  }\n  return trait;\n}\n\n/**\n * Compose a property descriptor map that inherits from `Trait.prototype` and\n * contains property descriptors for all the own properties of the passed\n * traits.\n *\n * If two or more traits have own properties with the same name, the returned\n * trait will contain a \"conflict\" property for that name. Composition is a\n * commutative and associative operation, and the order of its arguments is\n * irrelevant.\n */\nfunction compose(trait1, trait2/*, ...*/) {\n  // Create a new property descriptor `map` to which all the own properties\n  // of the passed traits are copied.  This map will be used to create a `Trait`\n  // instance that will be the result of this composition.\n  var map = {};\n\n  // Properties of each passed trait are copied to the composition.\n  Array.prototype.forEach.call(arguments, function(trait) {\n    // Copying each property of the given trait.\n    Object.keys(trait).forEach(function(name) {\n\n      // If `map` already owns a property with the `name` and it is not\n      // marked \"required\".\n      if (owns(map, name) && !map[name].value.required) {\n\n        // If the source trait's property with the `name` is marked as\n        // \"required\", we do nothing, as the requirement was already resolved\n        // by a property in the `map` (because it already contains a\n        // non-required property with that `name`).  But if properties are just\n        // different, we have a name clash and we substitute it with a property\n        // that is marked \"conflict\".\n        if (!isRequiredProperty(trait, name) &&\n            !equivalentDescriptors(map[name].value, trait[name])\n        ) {\n          map[name] = {\n            value: ConflictPropertyDescriptor(name),\n            enumerable: true\n          };\n        }\n      }\n\n      // Otherwise, the `map` does not have an own property with the `name`, or\n      // it is marked \"required\".  Either way, the trait's property is copied to\n      // the map (if the property of the `map` is marked \"required\", it is going\n      // to be resolved by the property that is being copied).\n      else {\n        map[name] = { value: trait[name], enumerable: true };\n      }\n    });\n  });\n\n  return Object.create(Trait.prototype, map);\n}\n\n/**\n *  `defineProperties` is like `Object.defineProperties`, except that it\n *  ensures that:\n *    - An exception is thrown if any property in a given `properties` map\n *      is marked as \"required\" property and same named property is not\n *      found in a given `prototype`.\n *    - An exception is thrown if any property in a given `properties` map\n *      is marked as \"conflict\" property.\n * @param {Object} object\n *    Object to define properties on.\n * @param {Object} properties\n *    Properties descriptor map.\n * @returns {Object}\n *    `object` that was passed as a first argument.\n */\nfunction defineProperties(object, properties) {\n\n  // Create a map into which we will copy each verified property from the given\n  // `properties` description map. We use it to verify that none of the\n  // provided properties is marked as a \"conflict\" property and that all\n  // \"required\" properties are resolved by a property of an `object`, so we\n  // can throw an exception before mutating object if that isn't the case.\n  var verifiedProperties = {};\n\n  // Coping each property from a given `properties` descriptor map to a\n  // verified map of property descriptors.\n  Object.keys(properties).forEach(function(name) {\n\n    // If property is marked as \"required\" property and we don't have a same\n    // named property in a given `object` we throw an exception. If `object`\n    // has same named property just skip this property since required property\n    // is was inherited and there for requirement was satisfied.\n    if (isRequiredProperty(properties, name)) {\n      if (!(name in object))\n        throwRequiredPropertyError(name);\n    }\n\n    // If property is marked as \"conflict\" property we throw an exception.\n    else if (isConflictProperty(properties, name)) {\n      throwConflictPropertyError(name);\n    }\n\n    // If property is not marked neither as \"required\" nor \"conflict\" property\n    // we copy it to verified properties map.\n    else {\n      verifiedProperties[name] = properties[name];\n    }\n  });\n\n  // If no exceptions were thrown yet, we know that our verified property\n  // descriptor map has no properties marked as \"conflict\" or \"required\",\n  // so we just delegate to the built-in `Object.defineProperties`.\n  return Object.defineProperties(object, verifiedProperties);\n}\n\n/**\n *  `create` is like `Object.create`, except that it ensures that:\n *    - An exception is thrown if any property in a given `properties` map\n *      is marked as \"required\" property and same named property is not\n *      found in a given `prototype`.\n *    - An exception is thrown if any property in a given `properties` map\n *      is marked as \"conflict\" property.\n * @param {Object} prototype\n *    prototype of the composed object\n * @param {Object} properties\n *    Properties descriptor map.\n * @returns {Object}\n *    An object that inherits form a given `prototype` and implements all the\n *    properties defined by a given `properties` descriptor map.\n */\nfunction create(prototype, properties) {\n\n  // Creating an instance of the given `prototype`.\n  var object = Object.create(prototype);\n\n  // Overriding `toString`, `constructor` methods if they are just inherited\n  // from `Object.prototype` with a same named methods of the `Trait.prototype`\n  // that will have more relevant behavior.\n  overrideBuiltInMethods(object, Trait.prototype);\n\n  // Trying to define given `properties` on the `object`. We use our custom\n  // `defineProperties` function instead of build-in `Object.defineProperties`\n  // that behaves exactly the same, except that it will throw if any\n  // property in the given `properties` descriptor is marked as \"required\" or\n  // \"conflict\" property.\n  return defineProperties(object, properties);\n}\n\n/**\n * Composes new trait. If two or more traits have own properties with the\n * same name, the new trait will contain a \"conflict\" property for that name.\n * \"compose\" is a commutative and associative operation, and the order of its\n * arguments is not significant.\n *\n * **Note:** Use `Trait.compose` instead of calling this function with more\n * than one argument. The multiple-argument functionality is strictly for\n * backward compatibility.\n *\n * @params {Object} trait\n *    Takes traits as an arguments\n * @returns {Object}\n *    New trait containing the combined own properties of all the traits.\n * @example\n *    var newTrait = compose(trait_1, trait_2, ..., trait_N)\n */\nfunction Trait(trait1, trait2) {\n\n  // If the function was called with one argument, the argument should be\n  // an object whose properties are mapped to property descriptors on a new\n  // instance of Trait, so we delegate to the trait function.\n  // If the function was called with more than one argument, those arguments\n  // should be instances of Trait or plain property descriptor maps\n  // whose properties should be mixed into a new instance of Trait,\n  // so we delegate to the compose function.\n\n  return trait2 === undefined ? trait(trait1) : compose.apply(null, arguments);\n}\n\nObject.freeze(Object.defineProperties(Trait.prototype, {\n  toString: {\n    value: function toString() {\n      return \"[object \" + this.constructor.name + \"]\";\n    }\n  },\n\n  /**\n   * `create` is like `Object.create`, except that it ensures that:\n   *    - An exception is thrown if this trait defines a property that is\n   *      marked as required property and same named property is not\n   *      found in a given `prototype`.\n   *    - An exception is thrown if this trait contains property that is\n   *      marked as \"conflict\" property.\n   * @param {Object}\n   *    prototype of the compared object\n   * @returns {Object}\n   *    An object with all of the properties described by the trait.\n   */\n  create: {\n    value: function createTrait(prototype) {\n      return create(undefined === prototype ? Object.prototype : prototype,\n                    this);\n    },\n    enumerable: true\n  },\n\n  /**\n   * Composes a new resolved trait, with all the same properties as the original\n   * trait, except that all properties whose name is an own property of\n   * `resolutions` will be renamed to the value of `resolutions[name]`. If\n   * `resolutions[name]` is `null`, the property is marked as \"required\".\n   * @param {Object} resolutions\n   *   An object whose own properties serve as a mapping from old names to new\n   *   names, or to `null` if the property should be excluded.\n   * @returns {Object}\n   *   New trait with the same own properties as the original trait but renamed.\n   */\n  resolve: {\n    value: function resolveTrait(resolutions) {\n      return resolve(resolutions, this);\n    },\n    enumerable: true\n  }\n}));\n\n/**\n * @see compose\n */\nTrait.compose = Object.freeze(compose);\nObject.freeze(compose.prototype);\n\n/**\n * Constant singleton, representing placeholder for required properties.\n * @type {Object}\n */\nTrait.required = Object.freeze(Object.create(Object.prototype, {\n  toString: {\n    value: Object.freeze(function toString() {\n      return \"<Trait.required>\";\n    })\n  }\n}));\nObject.freeze(Trait.required.toString.prototype);\n\nexports.Trait = Object.freeze(Trait);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "light-traits"
    }
  }, 
  {
    "pk": 21, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Trait } = require('traits');\n\n/**\n * @see https://jetpack.mozillalabs.com/sdk/latest/docs/#module/api-utils/list\n */\nconst Iterable = Trait.compose({\n  /**\n   * Hash map of key-values to iterate over.\n   * Note: That this property can be a getter if you need dynamic behavior.\n   * @type {Object}\n   */\n  _keyValueMap: Trait.required,\n  /**\n   * Custom iterator providing `Iterable`s enumeration behavior.\n   * @param {Boolean} onKeys\n   */\n  __iterator__: function __iterator__(onKeys, onKeyValue) {\n    let map = this._keyValueMap;\n    for (let key in map)\n      yield onKeyValue ? [key, map[key]] : onKeys ? key : map[key];\n  }\n});\nexports.Iterable = Iterable;\n\n/**\n * An ordered collection (also known as a sequence) disallowing duplicate\n * elements. List is composed out of `Iterable` there for it provides custom\n * enumeration behavior that is similar to array (enumerates only on the\n * elements of the list). List is a base trait and is meant to be a part of\n * composition, since all of it's API is private except length property.\n */\nconst List = Trait.resolve({ toString: null }).compose({\n  _keyValueMap: null,\n  /**\n   * List constructor can take any number of element to populate itself.\n   * @params {Object|String|Number} element\n   * @example\n   *    List(1,2,3).length == 3 // true\n   */\n  constructor: function List() {\n    this._keyValueMap = [];\n    for (let i = 0, ii = arguments.length; i < ii; i++)\n      this._add(arguments[i]);\n  },\n  /**\n   * Number of elements in this list.\n   * @type {Number}\n   */\n  get length() this._keyValueMap.length,\n   /**\n    * Returns a string representing this list.\n    * @returns {String}\n    */\n  toString: function toString() 'List(' + this._keyValueMap + ')',\n  /**\n   * Returns `true` if this list contains the specified `element`.\n   * @param {Object|Number|String} element\n   * @returns {Boolean}\n   */\n  _has: function _has(element) 0 <= this._keyValueMap.indexOf(element),\n  /**\n   * Appends the specified `element` to the end of this list, if it doesn't\n   * contains it. Ignores the call if `element` is already contained.\n   * @param {Object|Number|String} element\n   */\n  _add: function _add(element) {\n    let list = this._keyValueMap,\n        index = list.indexOf(element);\n    if (0 > index)\n      list.push(this._public[list.length] = element);\n  },\n  /**\n   * Removes specified `element` from this list, if it contains it.\n   * Ignores the call if `element` is not contained.\n   * @param {Object|Number|String} element\n   */\n  _remove: function _remove(element) {\n    let list = this._keyValueMap,\n        index = list.indexOf(element);\n    if (0 <= index) {\n      delete this._public[list.length];\n      list.splice(index, 1);\n      for (let length = list.length; index < length; index++)\n        this._public[index] = list[index];\n    }\n  },\n  /**\n   * Removes all of the elements from this list.\n   */\n  _clear: function _clear() {\n    for (let i = 0, ii = this._keyValueMap.length; i < ii; i ++)\n      delete this._public[i];\n    this._keyValueMap.splice(0);\n  },\n  /**\n   * Custom iterator providing `List`s enumeration behavior.\n   * We cant reuse `_iterator` that is defined by `Iterable` since it provides\n   * iteration in an arbitrary order.\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in\n   * @param {Boolean} onKeys\n   */\n  __iterator__: function __iterator__(onKeys, onKeyValue) {\n    let array = this._keyValueMap.slice(0),\n        i = -1;\n    for each(let element in array)\n      yield onKeyValue ? [++i, element] : onKeys ? ++i : element;\n  }\n});\nexports.List = List;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "list"
    }
  }, 
  {
    "pk": 70, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Nickolay Ponomarev.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Nickolay Ponomarev <asqueella@gmail.com> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst { URL } = require(\"url\");\n\nexports.MatchPattern = MatchPattern;\n\nfunction MatchPattern(pattern) {\n  if (typeof pattern.test == \"function\") {\n\n    // For compatibility with -moz-document rules, we require the RegExp's\n    // global, ignoreCase, and multiline flags to be set to false.\n    if (pattern.global) {\n      throw new Error(\"A RegExp match pattern cannot be set to `global` \" +\n                      \"(i.e. //g).\");\n    }\n    if (pattern.ignoreCase) {\n      throw new Error(\"A RegExp match pattern cannot be set to `ignoreCase` \" +\n                      \"(i.e. //i).\");\n    }\n    if (pattern.multiline) {\n      throw new Error(\"A RegExp match pattern cannot be set to `multiline` \" +\n                      \"(i.e. //m).\");\n    }\n\n    this.regexp = pattern;\n  }\n  else {\n    let firstWildcardPosition = pattern.indexOf(\"*\");\n    let lastWildcardPosition = pattern.lastIndexOf(\"*\");\n    if (firstWildcardPosition != lastWildcardPosition)\n      throw new Error(\"There can be at most one '*' character in a wildcard.\");\n\n    if (firstWildcardPosition == 0) {\n      if (pattern.length == 1)\n        this.anyWebPage = true;\n      else if (pattern[1] != \".\")\n        throw new Error(\"Expected a *.<domain name> string, got: \" + pattern);\n      else\n        this.domain = pattern.substr(2);\n    }\n    else {\n      if (pattern.indexOf(\":\") == -1) {\n        throw new Error(\"When not using *.example.org wildcard, the string \" +\n                        \"supplied is expected to be either an exact URL to \" +\n                        \"match or a URL prefix. The provided string ('\" +\n                        pattern + \"') is unlikely to match any pages.\");\n      }\n\n      if (firstWildcardPosition == -1)\n        this.exactURL = pattern;\n      else if (firstWildcardPosition == pattern.length - 1)\n        this.urlPrefix = pattern.substr(0, pattern.length - 1);\n      else {\n        throw new Error(\"The provided wildcard ('\" + pattern + \"') has a '*' \" +\n                        \"in an unexpected position. It is expected to be the \" +\n                        \"first or the last character in the wildcard.\");\n      }\n    }\n  }\n}\n\nMatchPattern.prototype = {\n\n  test: function MatchPattern_test(urlStr) {\n    try {\n      var url = URL(urlStr);\n    }\n    catch (err) {\n      return false;\n    }\n\n    // Test the URL against a RegExp pattern.  For compatibility with\n    // -moz-document rules, we require the RegExp to match the entire URL,\n    // so we not only test for a match, we also make sure the matched string\n    // is the entire URL string.\n    //\n    // Assuming most URLs don't match most match patterns, we call `test` for\n    // speed when determining whether or not the URL matches, then call `exec`\n    // for the small subset that match to make sure the entire URL matches.\n    //\n    if (this.regexp && this.regexp.test(urlStr) &&\n        this.regexp.exec(urlStr)[0] == urlStr)\n      return true;\n\n    if (this.anyWebPage && /^(https?|ftp)$/.test(url.scheme))\n      return true;\n    if (this.exactURL && this.exactURL == urlStr)\n      return true;\n    if (this.domain && url.host &&\n        url.host.slice(-this.domain.length) == this.domain)\n      return true;\n    if (this.urlPrefix && 0 == urlStr.indexOf(this.urlPrefix))\n      return true;\n\n    return false;\n  }\n\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "match-pattern"
    }
  }, 
  {
    "pk": 42, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cu,components} = require(\"chrome\");\nvar trackedObjects = {};\n\nvar Compacter = {\n  INTERVAL: 5000,\n  notify: function(timer) {\n    var newTrackedObjects = {};\n    for (name in trackedObjects) {\n      var oldBin = trackedObjects[name];\n      var newBin = [];\n      var strongRefs = [];\n      for (var i = 0; i < oldBin.length; i++) {\n        var strongRef = oldBin[i].weakref.get();\n        if (strongRef && strongRefs.indexOf(strongRef) == -1) {\n          strongRefs.push(strongRef);\n          newBin.push(oldBin[i]);\n        }\n      }\n      if (newBin.length)\n        newTrackedObjects[name] = newBin;\n    }\n    trackedObjects = newTrackedObjects;\n  }\n};\n\nvar timer = Cc[\"@mozilla.org/timer;1\"]\n            .createInstance(Ci.nsITimer);\n\ntimer.initWithCallback(Compacter,\n                       Compacter.INTERVAL,\n                       Ci.nsITimer.TYPE_REPEATING_SLACK);\n\nvar track = exports.track = function track(object, bin, stackFrameNumber) {\n  var frame = components.stack.caller;\n  var weakref = Cu.getWeakReference(object);\n  if (!bin)\n    bin = object.constructor.name;\n  if (bin == \"Object\")\n    bin = frame.name;\n  if (!bin)\n    bin = \"generic\";\n  if (!(bin in trackedObjects))\n    trackedObjects[bin] = [];\n\n  if (stackFrameNumber > 0)\n    for (var i = 0; i < stackFrameNumber; i++)\n      frame = frame.caller;\n\n  trackedObjects[bin].push({weakref: weakref,\n                            created: new Date(),\n                            filename: frame.filename,\n                            lineNo: frame.lineNumber,\n                            bin: bin});\n};\n\nvar getBins = exports.getBins = function getBins() {\n  var names = [];\n  for (name in trackedObjects)\n    names.push(name);\n  return names;\n};\n\nvar getObjects = exports.getObjects = function getObjects(bin) {\n  function getLiveObjectsInBin(bin, array) {\n    for (var i = 0; i < bin.length; i++) {\n      var object = bin[i].weakref.get();\n      if (object)\n        array.push(bin[i]);\n    }\n  }\n\n  var results = [];\n  if (bin) {\n    if (bin in trackedObjects)\n      getLiveObjectsInBin(trackedObjects[bin], results);\n  } else\n    for (name in trackedObjects)\n      getLiveObjectsInBin(trackedObjects[name], results);\n  return results;\n};\n\nvar gc = exports.gc = function gc() {\n  // Components.utils.forceGC() doesn't currently perform\n  // cycle collection, which means that e.g. DOM elements\n  // won't be collected by it. Fortunately, there are\n  // other ways...\n\n  var window = Cc[\"@mozilla.org/appshell/appShellService;1\"]\n               .getService(Ci.nsIAppShellService)\n               .hiddenDOMWindow;\n  var test_utils = window.QueryInterface(Ci.nsIInterfaceRequestor)\n                   .getInterface(Ci.nsIDOMWindowUtils);\n  test_utils.garbageCollect();\n  Compacter.notify();\n\n  // Not sure why, but sometimes it appears that we don't get\n  // them all with just one CC, so let's do it again.\n  test_utils.garbageCollect();\n};\n\nrequire(\"unload\").when(\n  function() {\n    trackedObjects = {};\n    if (timer) {\n      timer.cancel();\n      timer = null;\n    }\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "memory"
    }
  }, 
  {
    "pk": 79, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst { Cc, Ci, Cr } = require(\"chrome\");\nconst apiUtils = require(\"api-utils\");\nconst errors = require(\"errors\");\n\ntry {\n  let alertServ = Cc[\"@mozilla.org/alerts-service;1\"].\n                  getService(Ci.nsIAlertsService);\n\n  // The unit test sets this to a mock notification function.\n  var notify = alertServ.showAlertNotification.bind(alertServ);\n}\ncatch (err) {\n  // An exception will be thrown if the platform doesn't provide an alert\n  // service, e.g., if Growl is not installed on OS X.  In that case, use a\n  // mock notification function that just logs to the console.\n  notify = notifyUsingConsole;\n}\n\nexports.notify = function notifications_notify(options) {\n  let valOpts = validateOptions(options);\n  let clickObserver = !valOpts.onClick ? null : {\n    observe: function notificationClickObserved(subject, topic, data) {\n      if (topic === \"alertclickcallback\")\n        errors.catchAndLog(valOpts.onClick).call(exports, valOpts.data);\n    }\n  };\n  function notifyWithOpts(notifyFn) {\n    notifyFn(valOpts.iconURL, valOpts.title, valOpts.text, !!clickObserver,\n             valOpts.data, clickObserver);\n  }\n  try {\n    notifyWithOpts(notify);\n  }\n  catch (err if err instanceof Ci.nsIException &&\n                err.result == Cr.NS_ERROR_FILE_NOT_FOUND) {\n    console.warn(\"The notification icon named by \" + valOpts.iconURL +\n                 \" does not exist.  A default icon will be used instead.\");\n    delete valOpts.iconURL;\n    notifyWithOpts(notify);\n  }\n  catch (err) {\n    notifyWithOpts(notifyUsingConsole);\n  }\n};\n\nfunction notifyUsingConsole(iconURL, title, text) {\n  title = title ? \"[\" + title + \"]\" : \"\";\n  text = text || \"\";\n  let str = [title, text].filter(function (s) s).join(\" \");\n  console.log(str);\n}\n\nfunction validateOptions(options) {\n  return apiUtils.validateOptions(options, {\n    data: {\n      is: [\"string\", \"undefined\"]\n    },\n    iconURL: {\n      is: [\"string\", \"undefined\"]\n    },\n    onClick: {\n      is: [\"function\", \"undefined\"]\n    },\n    text: {\n      is: [\"string\", \"undefined\"]\n    },\n    title: {\n      is: [\"string\", \"undefined\"]\n    }\n  });\n}\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "notifications"
    }
  }, 
  {
    "pk": 39, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Observers.\n *\n * The Initial Developer of the Original Code is Daniel Aquino.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Daniel Aquino <mr.danielaquino@gmail.com>\n *   Myk Melez <myk@mozilla.org>\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nvar xpcom = require(\"xpcom\");\n\n/**\n * A service for adding, removing and notifying observers of notifications.\n * Wraps the nsIObserverService interface.\n *\n * @version 0.2\n */\n\nvar service = Cc[\"@mozilla.org/observer-service;1\"].\n              getService(Ci.nsIObserverService);\n\n/**\n * A cache of observers that have been added.\n *\n * We use this to remove observers when a caller calls |Observers.remove|.\n */\nvar cache = [];\n\n/**\n * Topics specifically available to Jetpack-generated extensions.\n *\n * Using these predefined consts instead of the platform strings is good:\n *   - allows us to scope topics specifically for Jetpacks\n *   - addons aren't dependent on strings nor behavior of core platform topics\n *   - the core platform topics are not clearly named\n *\n */\nexports.topics = {\n  /**\n   * A topic indicating that the application is in a state usable\n   * by add-ons.\n   */\n  get APPLICATION_READY() packaging.jetpackID + \"_APPLICATION_READY\"\n};\n\n/**\n * Register the given callback as an observer of the given topic.\n *\n * @param   topic       {String}\n *          the topic to observe\n *\n * @param   callback    {Object}\n *          the callback; an Object that implements nsIObserver or a Function\n *          that gets called when the notification occurs\n *\n * @param   thisObject  {Object}  [optional]\n *          the object to use as |this| when calling a Function callback\n *\n * @returns the observer\n */\nvar add = exports.add = function add(topic, callback, thisObject) {\n  var observer = new Observer(topic, callback, thisObject);\n  service.addObserver(observer, topic, true);\n  cache.push(observer);\n\n  return observer;\n};\n\n/**\n * Unregister the given callback as an observer of the given topic.\n *\n * @param   topic       {String}\n *          the topic being observed\n *\n * @param   callback    {Object}\n *          the callback doing the observing\n *\n * @param   thisObject  {Object}  [optional]\n *          the object being used as |this| when calling a Function callback\n */\nvar remove = exports.remove = function remove(topic, callback, thisObject) {\n  // This seems fairly inefficient, but I'm not sure how much better\n  // we can make it.  We could index by topic, but we can't index by callback\n  // or thisObject, as far as I know, since the keys to JavaScript hashes\n  // (a.k.a. objects) can apparently only be primitive values.\n  var [observer] = cache.filter(function(v) {\n                                  return (v.topic      == topic    &&\n                                          v.callback   == callback &&\n                                          v.thisObject == thisObject);\n                                });\n  if (observer) {\n    service.removeObserver(observer, topic);\n    cache.splice(cache.indexOf(observer), 1);\n  }\n};\n\n/**\n * Notify observers about something.\n *\n * @param topic   {String}\n *        the topic to notify observers about\n *\n * @param subject {Object}  [optional]\n *        some information about the topic; can be any JS object or primitive\n *\n * @param data    {String}  [optional] [deprecated]\n *        some more information about the topic; deprecated as the subject\n *        is sufficient to pass all needed information to the JS observers\n *        that this module targets; if you have multiple values to pass to\n *        the observer, wrap them in an object and pass them via the subject\n *        parameter (i.e.: { foo: 1, bar: \"some string\", baz: myObject })\n */\nvar notify = exports.notify = function notify(topic, subject, data) {\n  subject = (typeof subject == \"undefined\") ? null : new Subject(subject);\n  data = (typeof    data == \"undefined\") ? null : data;\n  service.notifyObservers(subject, topic, data);\n};\n\nfunction Observer(topic, callback, thisObject) {\n  memory.track(this);\n  this.topic = topic;\n  this.callback = callback;\n  this.thisObject = thisObject;\n}\n\nObserver.prototype = {\n  QueryInterface: xpcom.utils.generateQI([Ci.nsIObserver,\n                                          Ci.nsISupportsWeakReference]),\n  observe: function(subject, topic, data) {\n    // Extract the wrapped object for subjects that are one of our\n    // wrappers around a JS object.  This way we support both wrapped\n    // subjects created using this module and those that are real\n    // XPCOM components.\n    if (subject && typeof subject == \"object\" &&\n        (\"wrappedJSObject\" in subject) &&\n        (\"observersModuleSubjectWrapper\" in subject.wrappedJSObject))\n      subject = subject.wrappedJSObject.object;\n\n    try {\n      if (typeof this.callback == \"function\") {\n        if (this.thisObject)\n          this.callback.call(this.thisObject, subject, data);\n        else\n          this.callback(subject, data);\n      } else // typeof this.callback == \"object\" (nsIObserver)\n        this.callback.observe(subject, topic, data);\n    } catch (e) {\n      console.exception(e);\n    }\n  }\n};\n\nfunction Subject(object) {\n  // Double-wrap the object and set a property identifying the\n  // wrappedJSObject as one of our wrappers to distinguish between\n  // subjects that are one of our wrappers (which we should unwrap\n  // when notifying our observers) and those that are real JS XPCOM\n  // components (which we should pass through unaltered).\n  this.wrappedJSObject = {\n    observersModuleSubjectWrapper: true,\n    object: object\n  };\n}\n\nSubject.prototype = {\n  QueryInterface: xpcom.utils.generateQI([]),\n  getHelperForLanguage: function() {},\n  getInterfaces: function() {}\n};\n\nrequire(\"unload\").when(\n  function removeAllObservers() {\n    // Make a copy of cache first, since cache will be changing as we\n    // iterate through it.\n    cache.slice().forEach(\n      function(observer) {\n        remove(observer.topic, observer.callback, observer.thisObject);\n      });\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "observer-service"
    }
  }, 
  {
    "pk": 75, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack Packages.\n *\n * The Initial Developer of the Original Code is Nickolay Ponomarev.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Nickolay Ponomarev <asqueella@gmail.com> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst observers = require(\"observer-service\");\nconst { Worker, Loader } = require('content');\nconst { EventEmitter } = require('events');\nconst { List } = require('list');\nconst { Registry } = require('utils/registry');\nconst xulApp = require(\"xul-app\");\nconst { MatchPattern } = require('match-pattern');\n\n// Whether or not the host application dispatches a document-element-inserted\n// notification when the document element is inserted into the DOM of a page.\n// The notification was added in Gecko 2.0b6, it's a better time to attach\n// scripts with contentScriptWhen \"start\" than content-document-global-created,\n// since libraries like jQuery assume the presence of the document element.\nconst HAS_DOCUMENT_ELEMENT_INSERTED =\n        xulApp.versionInRange(xulApp.platformVersion, \"2.0b6\", \"*\");\nconst ON_CONTENT = HAS_DOCUMENT_ELEMENT_INSERTED ? 'document-element-inserted' :\n                   'content-document-global-created';\n\n// Workaround bug 642145: document-element-inserted is fired multiple times.\n// This bug is fixed in Firefox 4.0.1, but we want to keep FF 4.0 compatibility\n// Tracking bug 641457. To be removed when 4.0 has disappeared from earth.\nconst HAS_BUG_642145_FIXED =\n        xulApp.versionInRange(xulApp.platformVersion, \"2.0.1\", \"*\");\n\n// rules registry\nconst RULES = {};\n\nconst Rules = EventEmitter.resolve({ toString: null }).compose(List, {\n  add: function() Array.slice(arguments).forEach(function onAdd(rule) {\n    if (this._has(rule))\n      return;\n    // registering rule to the rules registry\n    if (!(rule in RULES))\n      RULES[rule] = new MatchPattern(rule);\n    this._add(rule);\n    this._emit('add', rule);\n  }.bind(this)),\n  remove: function() Array.slice(arguments).forEach(function onRemove(rule) {\n    if (!this._has(rule))\n      return;\n    this._remove(rule);\n    this._emit('remove', rule);\n  }.bind(this)),\n});\n\n/**\n * PageMod constructor (exported below).\n * @constructor\n */\nconst PageMod = Loader.compose(EventEmitter, {\n  on: EventEmitter.required,\n  _listeners: EventEmitter.required,\n  contentScript: Loader.required,\n  contentScriptFile: Loader.required,\n  contentScriptWhen: Loader.required,\n  include: null,\n  constructor: function PageMod(options) {\n    this._onContent = this._onContent.bind(this);\n    options = options || {};\n\n    if ('contentScript' in options)\n      this.contentScript = options.contentScript;\n    if ('contentScriptFile' in options)\n      this.contentScriptFile = options.contentScriptFile;\n    if ('contentScriptWhen' in options)\n      this.contentScriptWhen = options.contentScriptWhen;\n    if ('onAttach' in options)\n      this.on('attach', options.onAttach);\n    if ('onError' in options)\n      this.on('error', options.onError);\n\n    let include = options.include;\n    let rules = this.include = Rules();\n    rules.on('add', this._onRuleAdd = this._onRuleAdd.bind(this));\n    rules.on('remove', this._onRuleRemove = this._onRuleRemove.bind(this));\n\n    if (Array.isArray(include))\n      rules.add.apply(null, include);\n    else\n      rules.add(include);\n\n    this.on('error', this._onUncaughtError = this._onUncaughtError.bind(this));\n    pageModManager.add(this._public);\n\n    this._loadingWindows = [];\n  },\n\n  destroy: function destroy() {\n    for each (let rule in this.include)\n      this.include.remove(rule);\n    pageModManager.remove(this._public);\n    this._loadingWindows = [];\n  },\n\n  _loadingWindows: [],\n\n  _onContent: function _onContent(window) {\n    // not registered yet\n    if (!pageModManager.has(this))\n      return;\n\n    if (!HAS_BUG_642145_FIXED) {\n      if (this._loadingWindows.indexOf(window) != -1)\n        return;\n      this._loadingWindows.push(window);\n    }\n\n    if ('start' == this.contentScriptWhen) {\n      this._createWorker(window);\n      return;\n    }\n\n    let eventName = 'end' == this.contentScriptWhen ? 'load' : 'DOMContentLoaded';\n    let self = this;\n    window.addEventListener(eventName, function onReady(event) {\n      if (event.target.defaultView != window)\n        return;\n      window.removeEventListener(eventName, onReady, true);\n\n      self._createWorker(window);\n    }, true);\n  },\n  _createWorker: function _createWorker(window) {\n    let worker = Worker({\n      window: window.wrappedJSObject,\n      contentScript: this.contentScript,\n      contentScriptFile: this.contentScriptFile,\n      onError: this._onUncaughtError\n    });\n    this._emit('attach', worker);\n    let self = this;\n    worker.once('detach', function detach() {\n      worker.destroy();\n\n      if (!HAS_BUG_642145_FIXED) {\n        let idx = self._loadingWindows.indexOf(window);\n        if (idx != -1)\n          self._loadingWindows.splice(idx, 1);\n      }\n    });\n  },\n  _onRuleAdd: function _onRuleAdd(url) {\n    pageModManager.on(url, this._onContent);\n  },\n  _onRuleRemove: function _onRuleRemove(url) {\n    pageModManager.off(url, this._onContent);\n  },\n  _onUncaughtError: function _onUncaughtError(e) {\n    if (this._listeners('error').length == 1)\n      console.exception(e);\n  }\n});\nexports.PageMod = function(options) PageMod(options)\nexports.PageMod.prototype = PageMod.prototype;\n\nconst PageModManager = Registry.resolve({\n  constructor: '_init',\n  _destructor: '_registryDestructor'\n}).compose({\n  constructor: function PageModRegistry(constructor) {\n    this._init(PageMod);\n    observers.add(\n      ON_CONTENT, this._onContentWindow = this._onContentWindow.bind(this)\n    );\n  },\n  _destructor: function _destructor() {\n    observers.remove(ON_CONTENT, this._onContentWindow);\n    for (let rule in RULES) {\n      this._removeAllListeners(rule);\n      delete RULES[rule];\n    }\n    this._registryDestructor();\n  },\n  _onContentWindow: function _onContentWindow(domObj) {\n    let window = HAS_DOCUMENT_ELEMENT_INSERTED ? domObj.defaultView : domObj;\n    // XML documents don't have windows, and we don't yet support them.\n    if (!window)\n      return;\n    for (let rule in RULES)\n      if (RULES[rule].test(window.document.URL))\n        this._emit(rule, window);\n  },\n  off: function off(topic, listener) {\n    this.removeListener(topic, listener);\n    if (!this._listeners(topic).length)\n      delete RULES[topic];\n  }\n});\nconst pageModManager = PageModManager();\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "page-mod"
    }
  }, 
  {
    "pk": 72, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Felipe Gomes <felipc@gmail.com> (Original Author)\n *   Myk Melez <myk@mozilla.org>\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Symbiont } = require(\"content\");\nconst { Trait } = require(\"traits\");\n\nif (!require(\"xul-app\").isOneOf([\"Firefox\", \"Thunderbird\"])) {\n  throw new Error([\n    \"The page-worker module currently supports only Firefox and Thunderbird. \",\n    \"In the future, we would like it to support other applications, however. \",\n    \"Please see https://bugzilla.mozilla.org/show_bug.cgi?id=546740 for more \",\n    \"information.\"\n  ].join(\"\"));\n}\n\nconst Page = Trait.compose(\n  Symbiont.resolve({\n    constructor: '_initSymbiont'\n  }),\n  {\n    _frame: Trait.required,\n    _initFrame: Trait.required,\n    postMessage: Symbiont.required,\n    on: Symbiont.required,\n    destroy: Symbiont.required,\n\n    constructor: function Page(options) {\n      options = options || {};\n\n      this.contentURL = 'contentURL' in options ? options.contentURL\n        : 'about:blank';\n      if ('contentScriptWhen' in options)\n        this.contentScriptWhen = options.contentScriptWhen;\n      if ('contentScriptFile' in options)\n        this.contentScriptFile = options.contentScriptFile;\n      if ('contentScript' in options)\n        this.contentScript = options.contentScript;\n      if ('allow' in options)\n        this.allow = options.allow;\n      if ('onError' in options)\n        this.on('error', options.onError);\n      if ('onMessage' in options)\n        this.on('message', options.onMessage);\n\n      this.on('propertyChange', this._onChange.bind(this));\n\n      this._initSymbiont();\n    },\n    \n    _onChange: function _onChange(e) {\n      if ('contentURL' in e && this._frame) {\n        // Cleanup the worker before injecting the content script in the new\n        // document\n        this._workerCleanup();\n        this._initFrame(this._frame);\n      }\n    }\n  }\n);\nexports.Page = function(options) Page(options);\nexports.Page.prototype = Page.prototype;\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "page-worker"
    }
  }, 
  {
    "pk": 82, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org> (Original Author)\n *   Irakli Gozalishvili <gozala@mazilla.com>\n *   Mihai Sucan <mihai.sucan@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The panel module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=jetpack-panel-apps \",\n    \"for more information.\"\n  ].join(\"\"));\n}\n\nconst { Ci } = require(\"chrome\");\nconst { validateOptions: valid } = require(\"api-utils\");\nconst { Symbiont } = require(\"content\");\nconst { EventEmitter } = require('events');\nconst timer = require(\"timer\");\n\nrequire(\"xpcom\").utils.defineLazyServiceGetter(\n  this,\n  \"windowMediator\",\n  \"@mozilla.org/appshell/window-mediator;1\",\n  \"nsIWindowMediator\"\n);\n\nconst XUL_NS = \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n      ON_SHOW = 'popupshown',\n      ON_HIDE = 'popuphidden',\n      validNumber = { is: ['number', 'undefined', 'null'] };\n\n/**\n * Emits show and hide events.\n */\nconst Panel = Symbiont.resolve({\n  constructor: '_init',\n  _onInit: '_onSymbiontInit',\n  destroy: '_symbiontDestructor'\n}).compose({\n  _frame: Symbiont.required,\n  _init: Symbiont.required,\n  _onSymbiontInit: Symbiont.required,\n  _symbiontDestructor: Symbiont.required,\n  _emit: Symbiont.required,\n  _asyncEmit: Symbiont.required,\n  on: Symbiont.required,\n  removeListener: Symbiont.required,\n  _destructor: Symbiont.required,\n\n  _inited: false,\n\n  /**\n   * If set to `true` frame loaders between xul panel frame and\n   * hidden frame are swapped. If set to `false` frame loaders are\n   * set back to normal. Setting the value that was already set will\n   * have no effect.\n   */\n  set _frameLoadersSwapped(value) {\n    if (this.__frameLoadersSwapped == value) return;\n    this._frame.QueryInterface(Ci.nsIFrameLoaderOwner)\n      .swapFrameLoaders(this._viewFrame);\n    this.__frameLoadersSwapped = value;\n  },\n  __frameLoadersSwapped: false,\n\n  constructor: function Panel(options) {\n    this._onShow = this._onShow.bind(this);\n    this._onHide = this._onHide.bind(this);\n    this.on('inited', this._onSymbiontInit.bind(this));\n\n    options = options || {};\n    if ('onShow' in options)\n      this.on('show', options.onShow);\n    if ('onHide' in options)\n      this.on('hide', options.onHide);\n    if ('width' in options)\n      this.width = options.width;\n    if ('height' in options)\n      this.height = options.height;\n    if ('contentURL' in options)\n      this.contentURL = options.contentURL;\n\n    this._init(options);\n  },\n  _destructor: function _destructor() {\n    this.hide();\n    this._removeAllListeners('show');\n    // defer cleanup to be performed after panel gets hidden\n    this._xulPanel = null;\n    this._symbiontDestructor(this);\n    this._removeAllListeners(this, 'hide');\n  },\n  destroy: function destroy() {\n    this._destructor();\n  },\n  /* Public API: Panel.width */\n  get width() this._width,\n  set width(value)\n    this._width = valid({ $: value }, { $: validNumber }).$ || this._width,\n  _width: 320,\n  /* Public API: Panel.height */\n  get height() this._height,\n  set height(value)\n    this._height =  valid({ $: value }, { $: validNumber }).$ || this._height,\n  _height: 240,\n\n  /* Public API: Panel.isShowing */\n  get isShowing() !!this._xulPanel && this._xulPanel.state == \"open\",\n\n  /* Public API: Panel.show */\n  show: function show(anchor) {\n    anchor = anchor || null;\n    let document = getWindow(anchor).document;\n    let xulPanel = this._xulPanel;\n    if (!xulPanel) {\n      xulPanel = this._xulPanel = document.createElementNS(XUL_NS, 'panel');\n      xulPanel.setAttribute(\"type\", \"arrow\");\n      \n      // One anonymous node has a big padding that doesn't work well with \n      // Jetpack, as we would like to display an iframe that completely fills \n      // the panel. \n      // -> Use a XBL wrapper with inner stylesheet to remove this padding.\n      let css = \".panel-inner-arrowcontent, .panel-arrowcontent {padding: 0;}\";\n      let originalXBL = \"chrome://global/content/bindings/popup.xml#arrowpanel\";\n      let binding = \n      '<bindings xmlns=\"http://www.mozilla.org/xbl\">' +\n        '<binding id=\"id\" extends=\"' + originalXBL + '\">' + \n          '<resources>' + \n            '<stylesheet src=\"data:text/css,' + \n              document.defaultView.encodeURIComponent(css) + '\"/>' +\n          '</resources>' +\n        '</binding>' +\n      '</bindings>';\n      xulPanel.style.MozBinding = 'url(\"data:text/xml,' + \n        document.defaultView.encodeURIComponent(binding) + '\")';\n      \n      let frame = document.createElementNS(XUL_NS, 'iframe');\n      frame.setAttribute('type', 'content');\n      frame.setAttribute('flex', '1');\n      frame.setAttribute('transparent', 'transparent');\n      \n      // Load an empty document in order to have an immediatly loaded iframe, \n      // so swapFrameLoaders is going to work without having to wait for load.\n      frame.setAttribute(\"src\",\"data:,\"); \n      \n      xulPanel.appendChild(frame);\n      document.getElementById(\"mainPopupSet\").appendChild(xulPanel);\n    }\n    let { width, height } = this, x, y, position;\n    \n    if (!anchor) {\n      // Open the popup in the middle of the window.\n      x = document.documentElement.clientWidth / 2 - width / 2;\n      y = document.documentElement.clientHeight / 2 - height / 2;\n      position = null;\n    } \n    else {\n      // Open the popup by the anchor.\n      let rect = anchor.getBoundingClientRect();\n      \n      let window = anchor.ownerDocument.defaultView;\n      \n      let zoom = window.mozScreenPixelsPerCSSPixel;\n      let screenX = rect.left + window.mozInnerScreenX * zoom;\n      let screenY = rect.top + window.mozInnerScreenY * zoom;\n      \n      // Set up the vertical position of the popup relative to the anchor\n      // (always display the arrow on anchor center)\n      let horizontal, vertical;\n      if (screenY > window.screen.availHeight / 2 + height)\n        vertical = \"top\";\n      else\n        vertical = \"bottom\";\n      \n      if (screenY > window.screen.availWidth / 2 + width)\n        horizontal = \"left\";\n      else\n        horizontal = \"right\";\n      \n      let verticalInverse = vertical == \"top\" ? \"bottom\" : \"top\";\n      position = vertical + \"center \" + verticalInverse + horizontal;\n      \n      // Allow panel to flip itself if the panel can't be displayed at the\n      // specified position (useful if we compute a bad position or if the \n      // user moves the window and panel remains visible)\n      xulPanel.setAttribute(\"flip\",\"both\");\n    }\n    \n    // Resize the iframe instead of using panel.sizeTo\n    // because sizeTo doesn't work with arrow panels\n    xulPanel.firstChild.style.width = width + \"px\";\n    xulPanel.firstChild.style.height = height + \"px\";\n    \n    // Wait for the XBL binding to be constructed\n    function waitForBinding() {\n      if (!xulPanel.openPopup) {\n        timer.setTimeout(waitForBinding, 50);\n        return;\n      }\n      xulPanel.openPopup(anchor, position, x, y);\n    }\n    waitForBinding();\n    \n    return this._public;\n  },\n  /* Public API: Panel.hide */\n  hide: function hide() {\n    // The popuphiding handler takes care of swapping back the frame loaders\n    // and removing the XUL panel from the application window, we just have to\n    // trigger it by hiding the popup.\n    // XXX Sometimes I get \"TypeError: xulPanel.hidePopup is not a function\"\n    // when quitting the host application while a panel is visible.  To suppress\n    // them, this now checks for \"hidePopup\" in xulPanel before calling it.\n    // It's not clear if there's an actual issue or the error is just normal.\n    let xulPanel = this._xulPanel;\n    if (xulPanel && \"hidePopup\" in xulPanel)\n      xulPanel.hidePopup();\n    return this._public;\n  },\n\n  /* Public API: Panel.resize */\n  resize: function resize(width, height) {\n    this.width = width;\n    this.height = height;\n    this._xulPanel.sizeTo(width, height);\n  },\n\n  // While the panel is visible, this is the XUL <panel> we use to display it.\n  // Otherwise, it's null.\n  get _xulPanel() this.__xulPanel,\n  set _xulPanel(value) {\n    let xulPanel = this.__xulPanel;\n    if (value === xulPanel) return;\n    if (xulPanel) {\n      xulPanel.removeEventListener(ON_HIDE, this._onHide, false);\n      xulPanel.removeEventListener(ON_SHOW, this._onShow, false);\n      xulPanel.parentNode.removeChild(xulPanel);\n    }\n    if (value) {\n      value.addEventListener(ON_HIDE, this._onHide, false);\n      value.addEventListener(ON_SHOW, this._onShow, false);\n    }\n    this.__xulPanel = value;\n  },\n  __xulPanel: null,\n  get _viewFrame() this.__xulPanel.children[0], \n  /**\n   * When the XUL panel becomes hidden, we swap frame loaders back to move\n   * the content of the panel to the hidden frame & remove panel element.\n   */\n  _onHide: function _onHide() {\n    try {\n      this._frameLoadersSwapped = false;\n      this._xulPanel = null;\n      this._emit('hide');\n    } catch(e) {\n      this._emit('error', e);\n    }\n  },\n  /**\n   * When the XUL panel becomes shown, we swap frame loaders between panel\n   * frame and hidden frame to preserve state of the content dom.\n   */\n  _onShow: function _onShow() {\n    try {\n      if (!this._inited) // defer if not initialized yet\n        return this.on('inited', this._onShow.bind(this));\n      this._frameLoadersSwapped = true;\n\n      // Retrieve computed text color style in order to apply to the iframe\n      // document. As MacOS background is dark gray, we need to use skin's text\n      // color.\n      let win = this._xulPanel.ownerDocument.defaultView;\n      let node = win.document.getAnonymousElementByAttribute(this._xulPanel,\n                 \"class\", \"panel-inner-arrowcontent\");\n      let textColor = win.getComputedStyle(node).getPropertyValue(\"color\");\n      let doc = this._xulPanel.firstChild.contentDocument;\n      let style = doc.createElement(\"style\");\n      style.textContent = \"body { color: \" + textColor + \"; }\";\n      let container = doc.head ? doc.head : doc.documentElement;\n      if (container.firstChild)\n        container.insertBefore(style, container.firstChild);\n      else\n        container.appendChild(style);\n\n\n      this._emit('show');\n    } catch(e) {\n      this._emit('error', e);\n    }\n  },\n  /**\n   * Notification that panel was fully initialized.\n   */\n  _onInit: function _onInit() {\n    this._inited = true;\n    // perform all deferred tasks like initSymbiont, show, hide ...\n    // TODO: We're publicly exposing a private event here; this\n    // 'inited' event should really be made private, somehow.\n    this._emit('inited');\n    this._removeAllListeners('inited');\n  }\n});\nexports.Panel = function(options) Panel(options)\nexports.Panel.prototype = Panel.prototype;\n\nfunction getWindow(anchor) {\n  let window;\n\n  if (anchor) {\n    let anchorWindow = anchor.ownerDocument.defaultView.top;\n    let anchorDocument = anchorWindow.document;\n\n    let enumerator = windowMediator.getEnumerator(\"navigator:browser\");\n    while (enumerator.hasMoreElements()) {\n      let enumWindow = enumerator.getNext();\n\n      // Check if the anchor is in this browser window.\n      if (enumWindow == anchorWindow) {\n        window = anchorWindow;\n        break;\n      }\n\n      // Check if the anchor is in a browser tab in this browser window.\n      let browser = enumWindow.gBrowser.getBrowserForDocument(anchorDocument);\n      if (browser) {\n        window = enumWindow;\n        break;\n      }\n\n      // Look in other subdocuments (sidebar, etc.)?\n    }\n  }\n\n  // If we didn't find the anchor's window (or we have no anchor),\n  // return the most recent browser window.\n  if (!window)\n    window = windowMediator.getMostRecentWindow(\"navigator:browser\");\n\n  return window;\n}\n\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "panel"
    }
  }, 
  {
    "pk": 83, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst { Trait } = require(\"light-traits\");\nconst utils = require(\"passwords/utils\");\nconst defer = require(\"utils/function\").Enqueued;\n\n/**\n * Utility function that returns `onComplete` and `onError` callbacks form the\n * given `options` objects. Also properties are removed from the passed\n * `options` objects.\n * @param {Object} options\n *    Object that is passed to the exported functions of this module.\n * @returns {Function[]}\n *    Array with two elements `onComplete` and `onError` functions.\n */\nfunction getCallbacks(options) {\n  let value = [\n    'onComplete' in options ? options.onComplete : null,\n    'onError' in options ? defer(options.onError) : console.exception\n  ];\n\n  delete options.onComplete;\n  delete options.onError;\n\n  return value;\n};\n\n/**\n * Creates a wrapper function that tries to call `onComplete` with a return\n * value of the wrapped function or falls back to `onError` if wrapped function\n * throws an exception.\n */\nfunction createWrapperMethod(wrapped) {\n  return function (options) {\n    let [ onComplete, onError ] = getCallbacks(options);\n    try {\n      let value = wrapped(options);\n      if (onComplete) {\n        defer(function() {\n          try {\n            onComplete(value);\n          } catch (exception) {\n            onError(exception);\n          }\n        })();\n      }\n    } catch (exception) {\n      onError(exception);\n    }\n  };\n}\n\nexports.search = createWrapperMethod(utils.search);\nexports.store = createWrapperMethod(utils.store);\nexports.remove = createWrapperMethod(utils.remove);\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "passwords"
    }
  }, 
  {
    "pk": 40, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack Packages.\n *\n * The Initial Developer of the Original Code is Red Hat.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Mat\u011bj Cepl <mcepl@redhat.com> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Cc, Ci, components: { Constructor: CConstructor } } = require(\"chrome\");\nconst { uri: ADDON_URI } = require(\"self\");\nconst loginManager = Cc[\"@mozilla.org/login-manager;1\"].\n                     getService(Ci.nsILoginManager);\nconst { URL: parseURL } = require(\"url\");\nconst LoginInfo = CConstructor(\"@mozilla.org/login-manager/loginInfo;1\",\n                               \"nsILoginInfo\", \"init\");\n\nfunction filterMatchingLogins(loginInfo)\n  Object.keys(this).every(function(key) loginInfo[key] === this[key], this);\n\n/**\n * Removes `user`, `password` and `path` fields from the given `url` if it's\n * 'http', 'https' or 'ftp'. All other URLs are returned unchanged.\n * @example\n * http://user:pass@www.site.com/foo/?bar=baz#bang -> http://www.site.com\n */\nfunction normalizeURL(url) {\n  let { scheme, host, port } = parseURL(url);\n  // We normalize URL only if it's `http`, `https` or `ftp`. All other types of\n  // URLs (`resource`, `chrome`, etc..) should not be normalized as they are\n  // used with add-on associated credentials path.\n  return scheme === \"http\" || scheme === \"https\" || scheme === \"ftp\" ?\n         scheme + \"://\" + (host || \"\") + (port ? \":\" + port : \"\") :\n         url\n}\n\nfunction Login(options) {\n  let login = Object.create(Login.prototype);\n  Object.keys(options || {}).forEach(function(key) {\n    if (key === 'url')\n      login.hostname = normalizeURL(options.url);\n    else if (key === 'formSubmitURL')\n      login.formSubmitURL = options.formSubmitURL ?\n                            normalizeURL(options.formSubmitURL) : null;\n    else if (key === 'realm')\n      login.httpRealm = options.realm;\n    else \n      login[key] = options[key];\n  });\n\n  return login;\n}\nLogin.prototype.toJSON = function toJSON() {\n  return {\n    url: this.hostname || ADDON_URI,\n    realm: this.httpRealm || null,\n    formSubmitURL: this.formSubmitURL || null,\n    username: this.username || null,\n    password: this.password || null,\n    usernameField: this.usernameField || '',\n    passwordField: this.passwordField || '',\n  }\n};\nLogin.prototype.toLoginInfo = function toLoginInfo() {\n  let { url, realm, formSubmitURL, username, password, usernameField,\n        passwordField } = this.toJSON();\n\n  return new LoginInfo(url, formSubmitURL, realm, username, password,\n                       usernameField, passwordField);\n};\n\nfunction loginToJSON(value) Login(value).toJSON()\n\n/**\n * Returns array of `nsILoginInfo` objects that are stored in the login manager\n * and have all the properties with matching values as a given `options` object.\n * @param {Object} options\n * @returns {nsILoginInfo[]}\n */\nexports.search = function search(options) {\n  return loginManager.getAllLogins()\n                     .filter(filterMatchingLogins, Login(options))\n                     .map(loginToJSON);\n};\n\n/**\n * Stores login info created from the given `options` to the applications\n * built-in login management system.\n * @param {Object} options.\n */\nexports.store = function store(options) {\n  loginManager.addLogin(Login(options).toLoginInfo());\n};\n\n/**\n * Removes login info from the applications built-in login management system.\n * _Please note: When removing a login info the specified properties must\n * exactly match to the one that is already stored or exception will be thrown._\n * @param {Object} options.\n */\nexports.remove = function remove(options) {\n  loginManager.removeLogin(Login(options).toLoginInfo());\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "passwords/utils"
    }
  }, 
  {
    "pk": 64, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\nfunction stringify(arg) {\n  try {\n    return String(arg);\n  }\n  catch(ex) {\n    return \"<toString() error>\";\n  }\n}\n\nfunction stringifyArgs(args) {\n  return Array.map(args, stringify).join(\" \");\n}\n\nfunction message(print, level, args) {\n  print(level + \": \" + stringifyArgs(args) + \"\\n\");\n}\n\nvar Console = exports.PlainTextConsole = function PlainTextConsole(print) {\n  if (!print)\n    print = dump;\n  if (print === dump) {\n    // If we're just using dump(), auto-enable preferences so\n    // that the developer actually sees the console output.\n    var prefs = Cc[\"@mozilla.org/preferences-service;1\"]\n                .getService(Ci.nsIPrefBranch);\n    prefs.setBoolPref(\"browser.dom.window.dump.enabled\", true);\n  }\n  this.print = print;\n\n  // Binding all the public methods to an instance so that they can be used\n  // as callback / listener functions straightaway.\n  this.log = this.log.bind(this);\n  this.info = this.info.bind(this);\n  this.warn = this.warn.bind(this);\n  this.error = this.error.bind(this);\n  this.debug = this.debug.bind(this);\n  this.exception = this.exception.bind(this);\n  this.trace = this.trace.bind(this);\n};\n\nConsole.prototype = {\n  log: function log() {\n    message(this.print, \"info\", arguments);\n  },\n\n  info: function info() {\n    message(this.print, \"info\", arguments);\n  },\n\n  warn: function warn() {\n    message(this.print, \"warning\", arguments);\n  },\n\n  error: function error() {\n    message(this.print, \"error\", arguments);\n  },\n\n  debug: function debug() {\n    message(this.print, \"debug\", arguments);\n  },\n\n  exception: function exception(e) {\n    var fullString = (\"An exception occurred.\\n\" +\n                      require(\"traceback\").format(e) + \"\\n\" + e);\n    this.error(fullString);\n  },\n\n  trace: function trace() {\n    var traceback = require(\"traceback\");\n    var stack = traceback.get();\n    stack.splice(-1, 1);\n    message(this.print, \"info\", [traceback.format(stack)]);\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "plain-text-console"
    }
  }, 
  {
    "pk": 57, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Preferences.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2008\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Myk Melez <myk@mozilla.org>\n *   Daniel Aquino <mr.danielaquino@gmail.com>\n *   Atul Varma <atul@mozilla.com>\n *   Erik Vold <erikvvold@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// The minimum and maximum integers that can be set as preferences.\n// The range of valid values is narrower than the range of valid JS values\n// because the native preferences code treats integers as NSPR PRInt32s,\n// which are 32-bit signed integers on all platforms.\nconst MAX_INT = 0x7FFFFFFF;\nconst MIN_INT = -0x80000000;\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\n\nvar prefSvc = Cc[\"@mozilla.org/preferences-service;1\"].\n              getService(Ci.nsIPrefService).getBranch(null);\n\nvar get = exports.get = function get(name, defaultValue) {\n  switch (prefSvc.getPrefType(name)) {\n  case Ci.nsIPrefBranch.PREF_STRING:\n    return prefSvc.getComplexValue(name, Ci.nsISupportsString).data;\n\n  case Ci.nsIPrefBranch.PREF_INT:\n    return prefSvc.getIntPref(name);\n\n  case Ci.nsIPrefBranch.PREF_BOOL:\n    return prefSvc.getBoolPref(name);\n\n  case Ci.nsIPrefBranch.PREF_INVALID:\n    return defaultValue;\n\n  default:\n    // This should never happen.\n    throw new Error(\"Error getting pref \" + name +\n                    \"; its value's type is \" +\n                    prefSvc.getPrefType(name) +\n                    \", which I don't know \" +\n                    \"how to handle.\");\n  }\n};\n\nvar set = exports.set = function set(name, value) {\n  var prefType;\n  if (typeof value != \"undefined\" && value != null)\n    prefType = value.constructor.name;\n\n  switch (prefType) {\n  case \"String\":\n    {\n      var string = Cc[\"@mozilla.org/supports-string;1\"].\n                   createInstance(Ci.nsISupportsString);\n      string.data = value;\n      prefSvc.setComplexValue(name, Ci.nsISupportsString, string);\n    }\n    break;\n\n  case \"Number\":\n    // We throw if the number is outside the range, since the result\n    // will never be what the consumer wanted to store, but we only warn\n    // if the number is non-integer, since the consumer might not mind\n    // the loss of precision.\n    if (value > MAX_INT || value < MIN_INT)\n      throw new Error(\"you cannot set the \" + name +\n                      \" pref to the number \" + value +\n                      \", as number pref values must be in the signed \" +\n                      \"32-bit integer range -(2^31) to 2^31-1.  \" +\n                      \"To store numbers outside that range, store \" +\n                      \"them as strings.\");\n    if (value % 1 != 0)\n      throw new Error(\"cannot store non-integer number: \" + value);\n    prefSvc.setIntPref(name, value);\n    break;\n\n  case \"Boolean\":\n    prefSvc.setBoolPref(name, value);\n    break;\n\n  default:\n    throw new Error(\"can't set pref \" + name + \" to value '\" + value +\n                    \"'; it isn't a String, Number, or Boolean\");\n  }\n};\n\nvar has = exports.has = function has(name) {\n  return (prefSvc.getPrefType(name) != Ci.nsIPrefBranch.PREF_INVALID);\n};\n\nvar isSet = exports.isSet = function isSet(name) {\n  return (has(name) && prefSvc.prefHasUserValue(name));\n};\n\nvar reset = exports.reset = function reset(name) {\n  try {\n    prefSvc.clearUserPref(name);\n  } catch (e if e.result == Cr.NS_ERROR_UNEXPECTED) {\n    // The pref service throws NS_ERROR_UNEXPECTED when the caller tries\n    // to reset a pref that doesn't exist or is already set to its default\n    // value.  This interface fails silently in those cases, so callers\n    // can unconditionally reset a pref without having to check if it needs\n    // resetting first or trap exceptions after the fact.  It passes through\n    // other exceptions, however, so callers know about them, since we don't\n    // know what other exceptions might be thrown and what they might mean.\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "preferences-service"
    }
  }, 
  {
    "pk": 74, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *  Paul O\u2019Shannessy <paul@oshannessy.com>\n *  Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst observers = require(\"observer-service\");\nconst { EventEmitter } = require(\"events\");\nconst { setTimeout } = require(\"timer\");\nconst unload = require(\"unload\");\n\nconst ON_START = \"start\";\nconst ON_STOP = \"stop\";\nconst ON_TRANSITION = \"private-browsing-transition-complete\";\n\nlet pbService;\n// Currently, only Firefox implements the private browsing service.\nif (require(\"xul-app\").is(\"Firefox\")) {\n  pbService = Cc[\"@mozilla.org/privatebrowsing;1\"].\n              getService(Ci.nsIPrivateBrowsingService);\n}\n\nfunction toggleMode(value) pbService.privateBrowsingEnabled = !!value\n\nconst privateBrowsing = EventEmitter.compose({\n  constructor: function PrivateBrowsing() {\n    // Binding method to instance since it will be used with `setTimeout`.\n    this._emitOnObject = this._emitOnObject.bind(this);\n    this.unload = this.unload.bind(this);\n    // Report unhandled errors from listeners\n    this.on(\"error\", console.exception.bind(console));\n    unload.ensure(this);\n    // We only need to add observers if `pbService` exists.\n    if (pbService) {\n      observers.add(ON_TRANSITION, this.onTransition.bind(this));\n      this._isActive = pbService.privateBrowsingEnabled;\n    }\n  },\n  unload: function _destructor() {\n    this._removeAllListeners(ON_START);\n    this._removeAllListeners(ON_STOP);\n  },\n  // We don't need to do anything with cancel here.\n  onTransition: function onTransition() {\n    let isActive = this._isActive = pbService.privateBrowsingEnabled;\n    setTimeout(this._emitOnObject, 0, exports, isActive ? ON_START : ON_STOP);\n  },\n  get isActive() this._isActive,\n  set isActive(value) {\n    if (pbService)\n      // We toggle private browsing mode asynchronously in order to work around\n      // bug 659629.  Since private browsing transitions are asynchronous\n      // anyway, this doesn't significantly change the behavior of the API.\n      setTimeout(toggleMode, 0, value);\n  },\n  _isActive: false\n})()\n\nObject.defineProperty(exports, \"isActive\", {\n  get: function() privateBrowsing.isActive\n});\nexports.activate = function activate() privateBrowsing.isActive = true;\nexports.deactivate = function deactivate() privateBrowsing.isActive = false;\nexports.on = privateBrowsing.on;\nexports.once = privateBrowsing.once;\nexports.removeListener = privateBrowsing.removeListener;\n\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "private-browsing"
    }
  }, 
  {
    "pk": 81, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Paul O\u2019Shannessy <paul@oshannessy.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst xpcom = require(\"xpcom\");\nconst xhr = require(\"xhr\");\nconst errors = require(\"errors\");\nconst apiUtils = require(\"api-utils\");\n\n// Ugly but will fix with: https://bugzilla.mozilla.org/show_bug.cgi?id=596248\nconst EventEmitter = require('events').EventEmitter.compose({\n  constructor: function EventEmitter() this\n});\n\n// Instead of creating a new validator for each request, just make one and reuse it.\nconst validator = new OptionsValidator({\n  url: {\n    //XXXzpao should probably verify that url is a valid url as well\n    is:  [\"string\"]\n  },\n  headers: {\n    map: function (v) v || {},\n    is:  [\"object\"],\n  },\n  content: {\n    map: function (v) v || null,\n    is:  [\"string\", \"object\", \"null\"],\n  },\n  contentType: {\n    map: function (v) v || \"application/x-www-form-urlencoded\",\n    is:  [\"string\"]\n  }\n});\n\nconst REUSE_ERROR = \"This request object has been used already. You must \" +\n                    \"create a new one to make a new request.\"\n\nfunction Request(options) {\n  const self = EventEmitter(),\n        _public = self._public;\n  // request will hold the actual XHR object\n  let request;\n  let response;\n\n  if ('onComplete' in options)\n    self.on('complete', options.onComplete)\n  options = validator.validateOptions(options);\n\n  // function to prep the request since it's the same between GET and POST\n  function makeRequest(mode) {\n    // If this request has already been used, then we can't reuse it. Throw an error.\n    if (request) {\n      throw new Error(REUSE_ERROR);\n    }\n\n    request = new xhr.XMLHttpRequest();\n\n    let url = options.url;\n    // Build the data to be set. For GET requests, we want to append that to\n    // the URL before opening the request.\n    let data = makeQueryString(options.content);\n    if (mode == \"GET\" && data) {\n      // If the URL already has ? in it, then we want to just use &\n      url = url + (/\\?/.test(url) ? \"&\" : \"?\") + data;\n    }\n\n    // open the request\n    request.open(mode, url);\n\n    // request header must be set after open, but before send\n    request.setRequestHeader(\"Content-Type\", options.contentType);\n\n    // set other headers\n    for (let k in options.headers) {\n      request.setRequestHeader(k, options.headers[k]);\n    }\n\n    // handle the readystate, create the response, and call the callback\n    request.onreadystatechange = function () {\n      if (request.readyState == 4) {\n        response = new Response(request);\n        errors.catchAndLog(function () {\n          self._emit('complete', response);\n        })();\n      }\n    }\n\n    // actually send the request. we only want to send data on POST requests\n    request.send(mode == \"POST\" ? data : null);\n  }\n\n  // Map these setters/getters to the options\n  [\"url\", \"headers\", \"content\", \"contentType\"].forEach(function (k) {\n    _public.__defineGetter__(k, function () options[k]);\n    _public.__defineSetter__(k, function (v) {\n      // This will automatically rethrow errors from apiUtils.validateOptions.\n      return options[k] = validator.validateSingleOption(k, v);\n    });\n  });\n\n  // response should be available as a getter\n  _public.__defineGetter__(\"response\", function () response);\n\n  _public.get = function () {\n    makeRequest(\"GET\");\n    return this;\n  };\n\n  _public.post = function () {\n    makeRequest(\"POST\");\n    return this;\n  };\n\n  return _public;\n}\nexports.Request = Request;\n\n// Converts an object of unordered key-vals to a string that can be passed\n// as part of a request\nfunction makeQueryString(content) {\n  // Explicitly return null if we have null, and empty string, or empty object.\n  if (!content) {\n    return null;\n  }\n\n  // If content is already a string, just return it as is.\n  if (typeof(content) == \"string\") {\n    return content;\n  }\n\n  // At this point we have a k:v object. Iterate over it and encode each value.\n  // Arrays and nested objects will get encoded as needed. For example...\n  //\n  //   { foo: [1, 2, { omg: \"bbq\", \"all your base!\": \"are belong to us\" }], bar: \"baz\" }\n  //\n  // will be encoded as\n  //\n  //   foo[0]=1&foo[1]=2&foo[2][omg]=bbq&foo[2][all+your+base!]=are+belong+to+us&bar=baz\n  //\n  // Keys (including \"[\" and \"]\") and values will be encoded with\n  // fixedEncodeURIComponent before returning.\n  //\n  // Execution was inspired by jQuery, but some details have changed and numeric\n  // array keys are included (whereas they are not in jQuery).\n\n  let encodedContent = [];\n  function add(key, val) {\n    encodedContent.push(fixedEncodeURIComponent(key) + \"=\" +\n                        fixedEncodeURIComponent(val));\n  }\n\n  function make(key, val) {\n    if (typeof(val) == \"object\") {\n      for ([k, v] in Iterator(val)) {\n        make(key + \"[\" + k + \"]\", v);\n      }\n    }\n    else {\n      add(key, val)\n    }\n  }\n  for ([k, v] in Iterator(content)) {\n    make(k, v);\n  }\n  return encodedContent.join(\"&\");\n\n  //XXXzpao In theory, we can just use a FormData object on 1.9.3, but I had\n  //        trouble getting that working. It would also be nice to stay\n  //        backwards-compat as long as possible. Keeping this in for now...\n  // let formData = Cc[\"@mozilla.org/files/formdata;1\"].\n  //                createInstance(Ci.nsIDOMFormData);\n  // for ([k, v] in Iterator(content)) {\n  //   formData.append(k, v);\n  // }\n  // return formData;\n}\n\n\n// encodes a string safely for application/x-www-form-urlencoded\n// adheres to RFC 3986\n// see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Functions/encodeURIComponent\nfunction fixedEncodeURIComponent (str) {\n  return encodeURIComponent(str).replace(/%20/g, \"+\").replace(/!/g, \"%21\").\n                                 replace(/'/g, \"%27\").replace(/\\(/g, \"%28\").\n                                 replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\n\nfunction Response(request) {\n  // Define the straight mappings of our value to original request value\n  xpcom.utils.defineLazyGetter(this, \"text\", function () request.responseText);\n  xpcom.utils.defineLazyGetter(this, \"xml\", function () {\n    throw new Error(\"Sorry, the 'xml' property is no longer available. \" +\n                    \"see bug 611042 for more information.\");\n  });\n  xpcom.utils.defineLazyGetter(this, \"status\", function () request.status);\n  xpcom.utils.defineLazyGetter(this, \"statusText\", function () request.statusText);\n\n  // this.json should be the JS object, so we need to attempt to parse it.\n  xpcom.utils.defineLazyGetter(this, \"json\", function () {\n    let _json = null;\n    try {\n      _json = JSON.parse(this.text);\n    }\n    catch (e) {}\n    return _json;\n  });\n\n  // this.headers also should be a JS object, so we need to split up the raw\n  // headers string provided by the request.\n  xpcom.utils.defineLazyGetter(this, \"headers\", function () {\n    let _headers = {};\n    let lastKey;\n    // Since getAllResponseHeaders() will return null if there are no headers,\n    // defend against it by defaulting to \"\"\n    let rawHeaders = request.getAllResponseHeaders() || \"\";\n    rawHeaders.split(\"\\n\").forEach(function (h) {\n      // According to the HTTP spec, the header string is terminated by an empty\n      // line, so we can just skip it.\n      if (!h.length) {\n        return;\n      }\n\n      let index = h.indexOf(\":\");\n      // The spec allows for leading spaces, so instead of assuming a single\n      // leading space, just trim the values.\n      let key = h.substring(0, index).trim(),\n          val = h.substring(index + 1).trim();\n\n      // For empty keys, that means that the header value spanned multiple lines.\n      // In that case we should append the value to the value of lastKey with a\n      // new line. We'll assume lastKey will be set because there should never\n      // be an empty key on the first pass.\n      if (key) {\n        _headers[key] = val;\n        lastKey = key;\n      }\n      else {\n        _headers[lastKey] += \"\\n\" + val;\n      }\n    });\n    return _headers;\n  })\n}\n\n// apiUtils.validateOptions doesn't give the ability to easily validate single\n// options, so this is a wrapper that provides that ability.\nfunction OptionsValidator(rules) {\n  this.rules = rules;\n\n  this.validateOptions = function (options) {\n    return apiUtils.validateOptions(options, this.rules);\n  }\n\n  this.validateSingleOption = function (field, value) {\n    // We need to create a single rule object from our listed rules. To avoid\n    // JavaScript String warnings, check for the field & default to an empty object.\n    let singleRule = {};\n    if (field in this.rules) {\n      singleRule[field] = this.rules[field];\n    }\n    let singleOption = {};\n    singleOption[field] = value;\n    // This should throw if it's invalid, which will bubble up & out.\n    return apiUtils.validateOptions(singleOption, singleRule)[field];\n  }\n}\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "request"
    }
  }, 
  {
    "pk": 38, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Cc, Ci } = require(\"chrome\");\nconst runtime = Cc[\"@mozilla.org/xre/app-info;1\"].getService(Ci.nsIXULRuntime);\n\nexports.inSafeMode = runtime.inSafeMode;\nexports.OS = runtime.OS;\nexports.processType = runtime.processType;\nexports.widgetToolkit = runtime.widgetToolkit;\nexports.XPCOMABI = runtime.XPCOMABI;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "runtime"
    }
  }, 
  {
    "pk": 14, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2009-2010 the Mozilla Foundation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *  * Neither the name of the Mozilla Foundation nor the names\n *    of its contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n(function(global) {\n   const Cc = Components.classes;\n   const Ci = Components.interfaces;\n   const Cu = Components.utils;\n   const Cr = Components.results;\n\n   var exports = {};\n\n   var ios = Cc['@mozilla.org/network/io-service;1']\n             .getService(Ci.nsIIOService);\n\n   var systemPrincipal = Cc[\"@mozilla.org/systemprincipal;1\"]\n                         .createInstance(Ci.nsIPrincipal);\n\n   // Even though manifest.py does some dependency scanning, that\n   // scan is done as part of an evaluation of what the add-on needs\n   // for security purposes. The following regexps are used to scan for\n   // dependencies inside a simplified define() callback:\n   // define(function(require, exports, module){ var a = require('a'); });\n   // and are used at runtime ensure the dependencies needed by\n   // the define factory function are already evaluated and ready.\n   // Even though this loader is a sync loader, and could fetch the module\n   // as the require() call happens, it would differ in behavior as\n   // compared to the async browser case, which would make sure to execute\n   // the dependencies first before executing the define() factory function.\n   // So this dependency scanning and evaluation is kept to match the\n   // async behavior.\n   var commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg;\n   var cjsRequireRegExp = /require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g;\n   var cjsStandardDeps = ['require', 'exports', 'module'];\n\n   function resolvePrincipal(principal, defaultPrincipal) {\n     if (principal === undefined)\n       return defaultPrincipal;\n     if (principal == \"system\")\n       return systemPrincipal;\n     return principal;\n   }\n\n   // The base URI to we use when we're given relative URLs, if any.\n   var baseURI = null;\n   if (global.window)\n     baseURI = ios.newURI(global.location.href, null, null);\n   exports.baseURI = baseURI;\n\n   // The \"parent\" chrome URI to use if we're loading code that\n   // needs chrome privileges but may not have a filename that\n   // matches any of SpiderMonkey's defined system filename prefixes.\n   // The latter is needed so that wrappers can be automatically\n   // made for the code. For more information on this, see\n   // bug 418356:\n   //\n   // https://bugzilla.mozilla.org/show_bug.cgi?id=418356\n   var parentChromeURIString;\n   if (baseURI)\n     // We're being loaded from a chrome-privileged document, so\n     // use its URL as the parent string.\n     parentChromeURIString = baseURI.spec;\n   else\n     // We're being loaded from a chrome-privileged JS module or\n     // SecurableModule, so use its filename (which may itself\n     // contain a reference to a parent).\n     parentChromeURIString = Components.stack.filename;\n\n   function maybeParentifyFilename(filename) {\n     var doParentifyFilename = true;\n     try {\n       // TODO: Ideally we should just make\n       // nsIChromeRegistry.wrappersEnabled() available from script\n       // and use it here. Until that's in the platform, though,\n       // we'll play it safe and parentify the filename unless\n       // we're absolutely certain things will be ok if we don't.\n       var filenameURI = ios.newURI(options.filename,\n                                    null,\n                                    baseURI);\n       if (filenameURI.scheme == 'chrome' &&\n           filenameURI.path.indexOf('/content/') == 0)\n         // Content packages will always have wrappers made for them;\n         // if automatic wrappers have been disabled for the\n         // chrome package via a chrome manifest flag, then\n         // this still works too, to the extent that the\n         // content package is insecure anyways.\n         doParentifyFilename = false;\n     } catch (e) {}\n     if (doParentifyFilename)\n       return parentChromeURIString + \" -> \" + filename;\n     return filename;\n   }\n\n   function getRootDir(urlStr) {\n     // TODO: This feels hacky, and like there will be edge cases.\n     return urlStr.slice(0, urlStr.lastIndexOf(\"/\") + 1);\n   }\n\n   exports.SandboxFactory = function SandboxFactory(defaultPrincipal) {\n     // Unless specified otherwise, use a principal with limited\n     // privileges.\n     this._defaultPrincipal = resolvePrincipal(defaultPrincipal,\n                                               \"http://www.mozilla.org\");\n   },\n\n   exports.SandboxFactory.prototype = {\n     createSandbox: function createSandbox(options) {\n       var principal = resolvePrincipal(options.principal,\n                                        this._defaultPrincipal);\n\n       return {\n         _sandbox: new Cu.Sandbox(principal),\n         _principal: principal,\n         get globalScope() {\n           return this._sandbox;\n         },\n         defineProperty: function defineProperty(name, value) {\n           this._sandbox[name] = value;\n         },\n         getProperty: function getProperty(name) {\n           return this._sandbox[name];\n         },\n         evaluate: function evaluate(options) {\n           if (typeof(options) == 'string')\n             options = {contents: options};\n           options = {__proto__: options};\n           if (typeof(options.contents) != 'string')\n             throw new Error('Expected string for options.contents');\n           if (options.lineNo === undefined)\n             options.lineNo = 1;\n           if (options.jsVersion === undefined)\n             options.jsVersion = \"1.8\";\n           if (typeof(options.filename) != 'string')\n             options.filename = '<string>';\n\n           if (this._principal == systemPrincipal)\n             options.filename = maybeParentifyFilename(options.filename);\n\n           return Cu.evalInSandbox(options.contents,\n                                   this._sandbox,\n                                   options.jsVersion,\n                                   options.filename,\n                                   options.lineNo);\n         }\n       };\n     }\n   };\n\n   exports.Loader = function Loader(options) {\n     options = {__proto__: options};\n     if (options.fs === undefined) {\n       var rootPaths = options.rootPath || options.rootPaths;\n       if (rootPaths) {\n         if (rootPaths.constructor.name != \"Array\")\n           rootPaths = [rootPaths];\n         var fses = [new exports.LocalFileSystem(path)\n                     for each (path in rootPaths)];\n         options.fs = new exports.CompositeFileSystem({\n           fses: fses,\n           metadata: options.metadata,\n           uriPrefix: options.uriPrefix,\n           name: options.name\n         });\n       } else\n         options.fs = new exports.LocalFileSystem();\n     }\n     if (options.sandboxFactory === undefined)\n       options.sandboxFactory = new exports.SandboxFactory(\n         options.defaultPrincipal\n       );\n     if ('modules' in options)\n       throw new Error('options.modules is no longer supported');\n     // pathAccessed used to know if a module was accessed/required\n     // by another module, and in that case, assigning the module value\n     // via a define callback is not allowed.\n     if (options.pathAccessed === undefined)\n       options.pathAccessed = {};\n     if (options.globals === undefined)\n       options.globals = {};\n\n     this.fs = options.fs;\n     this.sandboxFactory = options.sandboxFactory;\n     this.sandboxes = {};\n     this.modules = {};\n     this.pathAccessed = options.pathAccessed;\n     this.defineUsed = {};\n     this.globals = options.globals;\n     this.getModuleExports = options.getModuleExports;\n     this.modifyModuleSandbox = options.modifyModuleSandbox;\n     this.manifest = options.manifest || {};\n   };\n\n   exports.Loader.prototype = {\n     _makeApi: function _makeApi(basePath) {\n       /*\n        * _makeApi() creates a pair of specialized require()/define()\n        * functions for use by the code that comes from 'basePath' (which is\n        * a resource: URI pointing to some module, e.g. main.js). This\n        * require/define pair knows what main.js is allowed to import, in\n        * particular it knows what the link-time module search algorithm has\n        * found for each imported name (so if they require \"panel\", they'll\n        * get the one from addon-kit, not from some other package).\n        *\n        * When some other module (e.g. panel.js) is loaded, they'll get a\n        * different require/define pair, specialized for them.\n        */\n       var self = this;\n       let reqs;\n       if (basePath && (basePath in self.manifest))\n         reqs = self.manifest[basePath].requirements;\n\n       function syncRequire(module) {\n         if (reqs) {\n           // if we know about you, you must follow the manifest\n           if (module in reqs)\n             return loadMaybeMagicModule(module, reqs[module]);\n           // if you invoke chrome, you can go off-manifest and search\n           if (\"chrome\" in reqs)\n             return loadMaybeMagicModule(module, null);\n           throw new Error(\"Module at \"+basePath+\" not allowed to require\"+\"(\"+module+\")\");\n         } else {\n           // if we don't know about you, you can do anything you want.\n           // You're going to have to search for your own modules, though.\n           return loadMaybeMagicModule(module, null);\n         }\n       }\n\n       function loadMaybeMagicModule(moduleName, moduleData) {\n         /*\n          * If we get here, we're allowed to import this module, we just have\n          * to figure out how.\n          *\n          * 'moduleName' is the unmodified argument passed to require(),\n          * so it might be \"panel\" or \"pkg/foo\" or even \"./bar\" for relative\n          * imports. 'moduleData' is the manifest entry that tells us how\n          * we're supposed to import this module: usually it's an object with\n          * a .uri, but for certain \"magic\" modules it might be empty. If\n          * it's 'null' then we're supposed to search all known packages for\n          * it.\n          */\n\n         if (self.getModuleExports) {\n           /* this currently handles 'chrome' and 'parent-loader' */\n           let exports = self.getModuleExports(basePath, moduleName);\n           if (exports)\n             return exports;\n         }\n         if (moduleName == \"self\") {\n           /* The 'self' module is magic: when someone requires 'self', the\n            * module they get is supposed to be specialized for the *package*\n            * that they live in (so pkg1/foo.js will get 'self' for pkg1,\n            * while pkg2/bar.js will get a 'self' for pkg2). To accomplish\n            * this, we don't give them the real self.js module directly:\n            * instead, we load self.js and invoke its makeSelfModule()\n            * function, passing in the manifest's moduleData, which will\n            * include enough information to create the specialized module.\n            */\n           if (!moduleData) {\n             // we don't know where you live, so we must search for your data\n             // resource://api-utils-api-utils-tests/test-self.js\n             // make a prefix of resource://api-utils-api-utils-data/\n             let doubleslash = basePath.indexOf(\"//\");\n             let prefix = basePath.slice(0, doubleslash+2);\n             let rest = basePath.slice(doubleslash+2);\n             let slash = rest.indexOf(\"/\");\n             prefix = prefix + rest.slice(0, slash);\n             prefix = prefix.slice(0, prefix.lastIndexOf(\"-\")) + \"-data/\";\n             moduleData = { \"dataURIPrefix\": prefix };\n             // moduleData also wants mapName and mapSHA256, but they're\n             // currently unused\n           }\n           if (false) // force scanner to copy self-maker.js into the XPI\n             require(\"self-maker\"); \n           let makerModData = {uri: self.fs.resolveModule(null, \"self-maker\")};\n           if (!makerModData.uri)\n             throw new Error(\"Unable to find self-maker, from \"+basePath);\n           let selfMod = loadFromModuleData(makerModData, \"self-maker\");\n           // selfMod is not cached\n           return selfMod.makeSelfModule(moduleData);\n         }\n\n         if (!moduleData) {\n           // search\n           let path = self.fs.resolveModule(basePath, moduleName);\n           if (!path)\n             throw new Error('Module \"' + moduleName + '\" not found');\n           moduleData = {uri: path};\n         }\n\n         // Track accesses to this module via its normalized path. This lets\n         // us detect cases where foo.js uses define() with a callback that\n         // wants to return a new value for the 'foo' module, but something\n         // inside that callback (probably in some sub-function) references\n         // 'foo' too early. If this happens, we throw an exception when the\n         // callback finishes. The code for that is in define() below: search\n         // for self.pathAccessed .\n         if (!self.pathAccessed[moduleData.uri]) {\n           self.pathAccessed[moduleData.uri] = 0;\n         }\n         self.pathAccessed[moduleData.uri] += 1;\n\n         if (moduleData.uri in self.modules) {\n           // already loaded: return from cache\n           return self.modules[moduleData.uri];\n         }\n         return loadFromModuleData(moduleData, moduleName); // adds to cache\n       }\n\n       function loadFromModuleData(moduleData, moduleName) {\n         // moduleName is passed solely for error messages: by this point,\n         // everything is controlled by moduleData\n         if (!moduleData.uri) {\n           throw new Error(\"loadFromModuleData with null URI, from basePath \"\n                           +basePath+\" importing (\"+moduleName+\")\");\n         }\n         // any manifest-based permission checks have already been done\n         let path = moduleData.uri;\n\n         let moduleContents = self.fs.getFile(path);\n         var sandbox = self.sandboxFactory.createSandbox(moduleContents);\n         self.sandboxes[path] = sandbox;\n         for (name in self.globals)\n           sandbox.defineProperty(name, self.globals[name]);\n         var api = self._makeApi(path);\n         sandbox.defineProperty('require', api.require);\n         sandbox.defineProperty('define', api.define);\n         if (self.modifyModuleSandbox)\n           self.modifyModuleSandbox(sandbox, moduleContents);\n         /* set up an environment in which module code can use CommonJS\n            patterns like:\n              module.exports = newobj;\n              module.setExports(newobj);\n              if (module.id == \"main\") stuff();\n              define(\"async\", function() {return newobj});\n          */\n         sandbox.evaluate(\"var module = {exports: {}};\");\n         sandbox.evaluate(\"module.setExports = function(obj) {module.exports = obj; return obj;};\");\n         sandbox.evaluate(\"var exports = module.exports;\");\n         sandbox.evaluate(\"module.id = '\" + path + \"';\");\n         var preeval_exports = sandbox.getProperty(\"exports\");\n         self.modules[path] = sandbox.getProperty(\"exports\");\n         sandbox.evaluate(moduleContents);\n         var posteval_exports = sandbox.getProperty(\"module\").exports;\n         if (posteval_exports !== preeval_exports) {\n           /* if they used module.exports= or module.setExports(), get\n              the new value now. If they used define(), we must be\n              careful to leave self.modules[path] alone, as it will have\n              been modified in the asyncMain() callback-handling code,\n              fired during sandbox.evaluate(). */\n           if (self.defineUsed[path]) {\n             // you can do one or the other, not both\n             throw new Error(\"define() was used, so module.exports= and \"\n                             + \"module.setExports() may not be used: \"\n                             + path);\n           }\n           self.modules[path] = posteval_exports;\n         }\n         return self.modules[path]; // these are the exports\n       }\n\n       // START support Async module-style require and define calls.\n       // If the only argument to require is a string, then the module that\n       // is represented by that string is fetched for the appropriate context.\n       //\n       // If the first argument is an array, then it will be treated as an array\n       // of dependency string names to fetch. An optional function callback can\n       // be specified to execute when all of those dependencies are available.\n       function asyncRequire(deps, callback) {\n         if (typeof deps === \"string\" && !callback) {\n           // Just return the module wanted via sync require.\n           return syncRequire(deps);\n         } else {\n           asyncMain(null, basePath, null, deps, callback);\n           return undefined;\n         }\n       }\n\n       // The function that handles definitions of modules. Differs from\n       // require() in that a string for the module should be the first\n       // argument, and the function to execute after dependencies are loaded\n       // should return a value to define the module corresponding to the first\n       // argument's name.\n       function define (name, deps, callback) {\n\n         // Only allow one call to define per module/file.\n         if (self.defineUsed[basePath]) {\n           throw new Error(\"Only one call to define() allowed per file: \" +\n                            basePath);\n         } else {\n           self.defineUsed[basePath] = true;\n         }\n\n         // For anonymous modules, the namePath is the basePath\n         var namePath = basePath,\n             exports = {}, exported;\n\n         // Adjust args if an anonymous module\n         if (typeof name !== 'string') {\n           callback = deps;\n           deps = name;\n           name = null;\n         }\n\n         // If just a define({}) call (no dependencies),\n         // adjust args accordingly.\n         if (!Array.isArray(deps)) {\n           callback = deps;\n           deps = null;\n         }\n\n         // If the callback is not an actual function, it means it already\n         // has the definition of the module as a literal value.\n         if (!deps && callback && typeof callback !== 'function') {\n           self.modules[namePath] = callback;\n           return;\n         }\n\n         // Set the exports value now in case other modules need a handle\n         // on it for cyclical cases.\n         self.modules[namePath] = exports;\n\n         // Load dependencies and call the module's definition function.\n         exported = asyncMain(name, namePath, exports, deps, callback);\n\n         // Assign output of function to name, if exports was not\n         // in play (which asyncMain already figured out).\n         if (exported !== undefined) {\n           if (self.pathAccessed[namePath] > 1) {\n             // Another module already accessed the exported value,\n             // need to throw to avoid nasty circular dependency weirdness\n             throw new Error('Module \"' + (name || namePath) + '\" cannot use ' +\n                             'return from define to define the module ' +\n                             'after another module has referenced its ' +\n                             'exported value.');\n           } else {\n             self.modules[namePath] = exported;\n           }\n         }\n       }\n\n       // The function that handles the main async module work, for both\n       // require([], function(){}) calls and define calls.\n       // It makes sure all the dependencies exist before calling the\n       // callback function. It will return the result of the callback\n       // function if \"exports\" is not a dependency.\n       function asyncMain (name, namePath, exports, deps, callback) {\n\n         if (typeof deps === 'function') {\n           callback = deps;\n           deps = null;\n         }\n\n         if (!deps) {\n           deps = [];\n           // The shortened form of the async wrapper for CommonJS modules:\n           // define(function (require, exports, module) {});\n           // require calls could be inside the function, so toString it\n           // and pull out the dependencies.\n\n           // Remove comments from the callback string,\n           // look for require calls, and pull them into the dependencies.\n           // The comment regexp is not very robust, but good enough to\n           // avoid commented out require calls and to find normal, sync\n           // require calls in the function.\n           callback\n               .toString()\n               .replace(commentRegExp, \"\")\n               .replace(cjsRequireRegExp, function (match, dep) {\n                 deps.push(dep);\n               });\n           // Prepend standard require, exports, and module dependencies\n           // (and in that *exact* order per spec), but only add as many as\n           // was asked for via the callback's function argument length.\n           // In particular, do *not* pass exports if it was not asked for.\n           // By asking for exports as a dependency the rest of this\n           // asyncRequire code assumes then that the return value from the\n           // function should not be used as the exported module value.\n           deps = cjsStandardDeps.slice(0, callback.length).concat(deps);\n         }\n\n         var depModules = [],\n             usesExports = false,\n             exported;\n\n         // Load all the dependencies, with the \"require\", \"exports\" and\n         // \"module\" ones getting special handling to match the traditional\n         // CommonJS sync module expectations.\n         deps.forEach(function (dep) {\n             if (dep === \"require\") {\n               depModules.push(asyncRequire);\n             } else if (dep === \"module\") {\n               depModules.push({\n                 id: name\n               });\n             } else if (dep === \"exports\") {\n               usesExports = true;\n               depModules.push(exports);\n             } else {\n               depModules.push(syncRequire(dep));\n             }\n         });\n\n         // Execute the function.\n         if (callback) {\n           exported = callback.apply(null, depModules);\n         }\n\n         if (exported !== undefined) {\n           if (usesExports) {\n             throw new Error('Inside \"' + namePath + '\", cannot use exports ' +\n                             'and also return a value from a define ' +\n                             'definition function');\n           } else {\n             return exported;\n           }\n         }\n         return undefined;\n       };\n\n       return {\n         require: asyncRequire,\n         define: define\n       };\n       // END support for Async module-style\n     },\n\n     // This is only really used by unit tests and other\n     // development-related facilities, allowing access to symbols\n     // defined in the global scope of a module.\n     findSandboxForModule: function findSandboxForModule(module) {\n       var path = this.fs.resolveModule(null, module);\n       if (!path)\n         throw new Error('Module \"' + module + '\" not found');\n       if (!(path in this.sandboxes))\n         this.require(module);\n       if (!(path in this.sandboxes))\n         throw new Error('Internal error: path not in sandboxes: ' +\n                         path);\n       return this.sandboxes[path];\n     },\n\n     require: function require(module, callback) {\n       return (this._makeApi(null).require)(module, callback);\n     },\n\n     runScript: function runScript(options, extraOutput) {\n       if (typeof(options) == 'string')\n         options = {contents: options};\n       options = {__proto__: options};\n       var sandbox = this.sandboxFactory.createSandbox(options);\n       if (extraOutput)\n         extraOutput.sandbox = sandbox;\n       for (name in this.globals)\n         sandbox.defineProperty(name, this.globals[name]);\n       var api = this._makeApi(null);\n       sandbox.defineProperty('require', api.require);\n       sandbox.defineProperty('define', api.define);\n       return sandbox.evaluate(options);\n     }\n   };\n\n   // this is more of a resolver than a filesystem, but test-securable-module\n   // wants to override the getFile() function to avoid using real URIs\n   exports.CompositeFileSystem = function CompositeFileSystem(options) {\n     // We sort file systems in alphabetical order of a package name.\n     this.fses = options.fses.sort(function(a, b) a.root > b.root);\n     this.uriPrefix = options.uriPrefix;\n     this.name = options.name;\n     this.packages = options.metadata || {};\n   };\n\n   function isRelative(path) path.charAt(0) === \".\"\n   function isNested(path) ~path.indexOf(\"/\")\n   function normalizePath(path) path.substr(-3) === \".js\" ? path : path + \".js\"\n   function relatifyPath(path) isRelative(path) ? path : \"./\" + path\n   function getPackageName(path) path.substr(0, path.indexOf(\"/\"))\n   function getInPackagePath(path) path.substr(path.indexOf(\"/\") + 1)\n   function isRelativeTo(path, base) 0 === path.indexOf(base)\n   function resolveTo(path, base) \".\" + path.substr(base.length)\n\n   exports.CompositeFileSystem.prototype = {\n     getPackageURI: function getPackageURI(name) {\n       let uri = this.uriPrefix + name + \"-lib/\";\n       return ios.newURI(uri, null, null).spec;\n     },\n     resolveModule: function resolveModule(base, path) {\n       // If it is relative path we don't need to search anything\n       // as it should be module from the same package.\n       if (isRelative(path)) {\n         // If base is not provided then it's a main module with a relative\n         // path to we use `packageURI` as a base to resolve.\n         base = base || this.getPackageURI(this.name);\n         return this.resolveRelative(base, path);\n       }\n\n       // If path contains only one part then we treat if it as\n       // require(PCKG/{{(package.json).main}}\n       if (!isNested(path))\n         return this.resolveMain(path) || this.searchModule(path);\n\n       // If path contains more then one part than we try to interpret that\n       // as `require(PCKG/module)` first and fall back to search.\n       return this.resolveModuleFromPackage(path) || this.searchModule(path);\n\n     },\n     resolveRelative: function resolveRelative(base, path) {\n        path = normalizePath(path);\n        let uri = ios.newURI(path, null, ios.newURI(base, null, null));\n\n        try {\n          let channel = ios.newChannelFromURI(uri);\n          channel.open().close();\n        } catch (e) {\n          return null;\n        }\n        return uri.spec;\n     },\n     searchModule: function seachModule(path) {\n       for each (let fs in this.fses) {\n         let id = fs.resolveModule(null, path);\n         if (id)\n           return id;\n       }\n       return null;\n     },\n     resolveModuleFromPackage: function resolveModuleFromPackage(path) {\n       let name = getPackageName(path);\n       if (name in this.packages) {\n         let base = this.getPackageURI(name);\n         return this.resolveRelative(base, getInPackagePath(path));\n       }\n       return null;\n     },\n     resolveMain: function resolveMain(name) {\n       if (name in this.packages) {\n         let base = this.getPackageURI(name);\n         let path = relatifyPath(this.packages[name].main || \"main\");\n\n         // We need to make sure to strip out directory from the main if it\n         // contains \"lib\" part. Unfortunately if main out of the lib folder\n         // requiring main module will fail as it will be out of the mapped\n         // resource URI.\n         let dirs = this.packages[name].directories;\n         let lib = relatifyPath(dirs ? dirs.lib || \"./lib\" : \"./lib\");\n         if (isRelativeTo(path, lib))\n           path = resolveTo(path, lib);\n\n         return this.resolveRelative(base, path);\n       }\n       return null;\n     },\n     getFile: function getFile(path) {\n       return loadFile(path);\n     }\n   };\n\n   exports.LocalFileSystem = function LocalFileSystem(root) {\n     if (root === undefined) {\n       if (!baseURI)\n         throw new Error(\"Need a root path for module filesystem\");\n       root = baseURI;\n     }\n     if (typeof(root) == 'string')\n       root = ios.newURI(root, null, baseURI);\n     if (root instanceof Ci.nsIFile)\n       root = ios.newFileURI(root);\n     if (!(root instanceof Ci.nsIURI))\n       throw new Error('Expected nsIFile, nsIURI, or string for root');\n\n     this.root = root.spec;\n     this._rootURI = root;\n     this._rootURIDir = getRootDir(root.spec);\n   };\n\n   exports.LocalFileSystem.prototype = {\n     resolveModule: function resolveModule(base, path) {\n       path = path + \".js\";\n\n       var baseURI;\n       if (!base || path.charAt(0) != '.')\n         baseURI = this._rootURI;\n       else\n         baseURI = ios.newURI(base, null, null);\n\n       var newURI = ios.newURI(path, null, baseURI);\n       if (newURI.spec.indexOf(this._rootURIDir) == 0) {\n         var channel = ios.newChannelFromURI(newURI);\n         try {\n           channel.open().close();\n         } catch (e if e.result == Cr.NS_ERROR_FILE_NOT_FOUND) {\n           return null;\n         }\n         return newURI.spec;\n       }\n       return null;\n     },\n     getFile: function getFile(path) {\n       return loadFile(path);\n     }\n   };\n\n   function loadFile(path) {\n     var channel = ios.newChannel(path, null, null);\n     var iStream = channel.open();\n     var ciStream = Cc[\"@mozilla.org/intl/converter-input-stream;1\"].\n       createInstance(Ci.nsIConverterInputStream);\n     var bufLen = 0x8000;\n     ciStream.init(iStream, \"UTF-8\", bufLen,\n                   Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n     var chunk = {};\n     var data = \"\";\n     while (ciStream.readString(bufLen, chunk) > 0)\n       data += chunk.value;\n     ciStream.close();\n     iStream.close();\n     return {contents: data, filename: path};\n   };\n\n   if (global.window) {\n     // We're being loaded in a chrome window, or a web page with\n     // UniversalXPConnect privileges.\n     global.SecurableModule = exports;\n   } else if (global.exports) {\n     // We're being loaded in a SecurableModule.\n     for (name in exports) {\n       global.exports[name] = exports[name];\n     }\n   } else {\n     // We're being loaded in a JS module.\n     global.EXPORTED_SYMBOLS = [];\n     for (name in exports) {\n       global.EXPORTED_SYMBOLS.push(name);\n       global[name] = exports[name];\n     }\n   }\n })(this);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "securable-module"
    }
  }, 
  {
    "pk": 78, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Eric H. Jung <eric.jung@yahoo.com>\n *   Irakli Gozalishivili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The selection module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nlet { Ci } = require(\"chrome\"),\n    { setTimeout } = require(\"timer\"),\n    { EventEmitter } = require('events');\n\n// The selection type HTML\nconst HTML = 0x01;\n\n// The selection type TEXT\nconst TEXT = 0x02;\n\n// The selection type DOM (internal use only)\nconst DOM  = 0x03;\n\n/**\n * Creates an object from which a selection can be set, get, etc. Each\n * object has an associated with a range number. Range numbers are the\n * 0-indexed counter of selection ranges as explained at\n * https://developer.mozilla.org/en/DOM/Selection.\n *\n * @param rangeNumber\n *        The zero-based range index into the selection\n */\nfunction Selection(rangeNumber) {\n\n  // In order to hide the private rangeNumber argument from API consumers while\n  // still enabling Selection getters/setters to access it, the getters/setters\n  // are defined as lexical closures in the Selector constructor.\n\n  this.__defineGetter__(\"text\", function () getSelection(TEXT, rangeNumber));\n  this.__defineSetter__(\"text\", function (str) setSelection(str, rangeNumber));\n\n  this.__defineGetter__(\"html\", function () getSelection(HTML, rangeNumber));\n  this.__defineSetter__(\"html\", function (str) setSelection(str, rangeNumber));\n\n  this.__defineGetter__(\"isContiguous\", function () {\n    let sel = getSelection(DOM, rangeNumber);\n    // It isn't enough to check that rangeCount is zero. If one or more ranges\n    // are selected and then unselected, rangeCount is set to one, not zero.\n    // Therefore, if rangeCount is one, we also check if the selection is\n    // collapsed.\n    if (sel.rangeCount == 0)\n      return null;\n    if (sel.rangeCount == 1) {\n      let range = safeGetRange(sel, 0);\n      return range && range.collapsed ? null : true;\n    }\n    return false;\n  });\n}\n\nrequire(\"xpcom\").utils.defineLazyServiceGetter(this, \"windowMediator\",\n  \"@mozilla.org/appshell/window-mediator;1\", \"nsIWindowMediator\");\n\n/**\n * Returns the most recent content window\n */\nfunction context() {\n  // Overlay names should probably go into the xul-app module instead of here\n  return windowMediator.getMostRecentWindow(\"navigator:browser\").document.\n    commandDispatcher.focusedWindow;\n}\n\n/**\n * Returns the current selection from most recent content window. Depending on\n * the specified |type|, the value returned can be a string of text, stringified\n * HTML, or a DOM selection object as described at\n * https://developer.mozilla.org/en/DOM/Selection.\n *\n * @param type\n *        Specifies the return type of the selection. Valid values are the one\n *        of the constants HTML, TEXT, or DOM.\n *\n * @param rangeNumber\n *        Specifies the zero-based range index of the returned selection.\n */\nfunction getSelection(type, rangeNumber) {\n  let window, selection;\n  try {\n    window = context();\n    selection = window.getSelection();\n  }\n  catch (e) {\n    return null;\n  }\n\n  // Get the selected content as the specified type\n  if (type == DOM)\n    return selection;\n  else if (type == TEXT) {\n    let range = safeGetRange(selection, rangeNumber);\n    return range ? range.toString() : null;\n  }\n  else if (type == HTML) {\n    let range = safeGetRange(selection, rangeNumber);\n    // Another way, but this includes the xmlns attribute for all elements in\n    // Gecko 1.9.2+ :\n    // return Cc[\"@mozilla.org/xmlextras/xmlserializer;1\"].\n    //   createInstance(Ci.nsIDOMSerializer).serializeToSTring(range.\n    //     cloneContents());\n    if (!range)\n      return null;\n    let node = window.document.createElement(\"span\");\n    node.appendChild(range.cloneContents());\n    return node.innerHTML;\n  }\n  throw new Error(\"Type \" + type + \" is unrecognized.\");\n}\n\n/**\n * Returns the specified range in a selection without throwing an exception.\n *\n * @param selection\n *        A selection object as described at\n *         https://developer.mozilla.org/en/DOM/Selection\n *\n * @param rangeNumber\n *        Specifies the zero-based range index of the returned selection.\n */\nfunction safeGetRange(selection, rangeNumber) {\n  try {\n    let range = selection.getRangeAt(rangeNumber);\n    if (!range || range.toString() == \"\")\n      return null;\n    return range;\n  }\n  catch (e) {\n    return null;\n  }\n}\n\n/**\n * Sets the current selection of the most recent content document by changing\n * the existing selected text/HTML range to the specified value.\n *\n * @param val\n *        The value for the new selection\n *\n * @param rangeNumber\n *        The zero-based range index of the selection to be set\n *\n */\nfunction setSelection(val, rangeNumber) {\n    // Make sure we have a window context & that there is a current selection.\n    // Selection cannot be set unless there is an existing selection.\n    let window, range;\n    try {\n      window = context();\n      range = window.getSelection().getRangeAt(rangeNumber);\n    }\n    catch (e) {\n      // Rethrow with a more developer-friendly message than the caught\n      // exception.\n      throw new Error(\"It isn't possible to change the selection, as there isn't currently a selection\");\n    }\n    // Get rid of the current selection and insert our own\n    range.deleteContents();\n    let node = window.document.createElement(\"span\");\n    range.surroundContents(node);\n\n    // Some relevant JEP-111 requirements:\n\n    // Setting the text property replaces the selection with the value to\n    // which the property is set and sets the html property to the same value\n    // to which the text property is being set.\n\n    // Setting the html property replaces the selection with the value to\n    // which the property is set and sets the text property to the text version\n    // of the HTML value.\n\n    // This sets both the HTML and text properties.\n    node.innerHTML = val;\n}\n\nfunction onLoad(event) {\n  SelectionListenerManager.onLoad(event);\n}\n\nfunction onUnload(event) {\n  SelectionListenerManager.onUnload(event);\n}\n\nlet SelectionListenerManager = {\n  QueryInterface: require(\"xpcom\").utils.generateQI([Ci.nsISelectionListener]),\n\n  // The collection of listeners wanting to be notified of selection changes\n  listeners: EventEmitter.compose({\n    emit: function emit(type) this._emitOnObject(exports, type),\n    off: function() this._removeAllListeners.apply(this, arguments)\n  })(),\n  /**\n   * This is the nsISelectionListener implementation. This function is called\n   * by Gecko when a selection is changed interactively.\n   *\n   * We only pay attention to the SELECTALL, KEYPRESS, and MOUSEUP selection\n   * reasons. All reasons are listed here:\n   *\n   * http://mxr.mozilla.org/mozilla1.9.2/source/content/base/public/\n   *   nsISelectionListener.idl\n   *\n   * The other reasons (NO_REASON, DRAG_REASON, MOUSEDOWN_REASON) aren't\n   * applicable to us.\n   */\n  notifySelectionChanged: function notifySelectionChanged(document, selection,\n                                                          reason) {\n    if (![\"SELECTALL\", \"KEYPRESS\", \"MOUSEUP\"].some(function(type) reason &\n      Ci.nsISelectionListener[type + \"_REASON\"]) || selection.toString() == \"\")\n        return;\n    setTimeout(this.listeners.emit, 0, 'select')\n  },\n\n  /**\n   * Part of the Tracker implementation. This function is called by the\n   * tabs module when a browser is being tracked. Often, that means a new tab\n   * has been opened, but it can also mean an addon has been installed while\n   * tabs are already opened. In that case, this function is called for those\n   * already-opened tabs.\n   *\n   * @param browser\n   *        The browser being tracked\n   */\n  onTrack: function onTrack(browser) {\n    browser.addEventListener(\"load\", onLoad, true);\n    browser.addEventListener(\"unload\", onUnload, true);\n  },\n\n  onLoad: function onLoad(event) {\n    // Nothing to do without a useful window\n    let window = event.target.defaultView;\n    if (!window)\n      return;\n\n    // Wrap the add selection call with some number of setTimeout 0 because some\n    // reason it's possible to add a selection listener \"too early\". 2 sometimes\n    // works for gmail, and more consistently with 3, so make it 5 to be safe.\n    let count = 0;\n    let self = this;\n    function wrap(count, func) {\n      if (count-- > 0)\n        require(\"timer\").setTimeout(wrap, 0);\n      else\n        self.addSelectionListener(window);\n    }\n    wrap();\n  },\n\n  addSelectionListener: function addSelectionListener(window) {\n    if (window.jetpack_core_selection_listener)\n      return;\n    let selection = window.getSelection();\n    if (selection instanceof Ci.nsISelectionPrivate)\n      selection.addSelectionListener(this);\n    window.jetpack_core_selection_listener = true;\n  },\n\n  onUnload: function onUnload(event) {\n    // Nothing to do without a useful window\n    let window = event.target.defaultView;\n    if (!window)\n      return;\n    this.removeSelectionListener(window);\n    this.listeners.off('error');\n    this.listeners.off('selection');\n  },\n\n  removeSelectionListener: function removeSelectionListener(window) {\n    if (!window.jetpack_core_selection_listener)\n      return;\n    let selection = window.getSelection();\n    if (selection instanceof Ci.nsISelectionPrivate)\n      selection.removeSelectionListener(this);\n    window.jetpack_core_selection_listener = false;\n  },\n\n  /**\n   * Part of the TabTracker implementation. This function is called by the\n   * tabs module when a browser is being untracked. Usually, that means a tab\n   * has been closed.\n   *\n   * @param browser\n   *        The browser being untracked\n   */\n  onUntrack: function onUntrack(browser) {\n    browser.removeEventListener(\"load\", onLoad, true);\n    browser.removeEventListener(\"unload\", onUnload, true);\n  }\n};\nSelectionListenerManager.listeners.on('error', console.error);\n\n/**\n * Install |SelectionListenerManager| as tab tracker in order to watch\n * tab opening/closing\n */\nrequire(\"tab-browser\").Tracker(SelectionListenerManager);\n\n/**\n * Exports an iterator so that discontiguous selections can be iterated.\n */\nexports.__iterator__ = function __iterator__() {\n  for (let i = 0, sel = getSelection(DOM); i < sel.rangeCount; i++)\n    yield new Selection(i);\n};\n\nexports.on = SelectionListenerManager.listeners.on;\nexports.removeListener = SelectionListenerManager.listeners.removeListener;\n\n// Export the Selection singleton. Its rangeNumber is always zero.\nSelection.call(exports, 0);\n\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "selection"
    }
  }, 
  {
    "pk": 4, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// While this adapter is complete, it most likely isn't very secure,\n// in that it allows the remote addon process to ask for any content\n// on the host filesystem.\n\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (this.chrome) {\n  exports.id = chrome.call(\"self:id\");\n  exports.data = {\n    load: function(path) {\n      return chrome.call(\"self:load\", path, new Error().stack);\n    },\n    url: function(path) {\n      return chrome.call(\"self:url\", path, new Error().stack);\n    }\n  };\n} else {\n  // Here we basically have to reimplement the self module.\n\n  let file = require(\"file\");\n  let url = require(\"url\");\n  let traceback = require(\"traceback\");\n\n  let packageData = packaging.options.packageData;\n  let resourcePackages = packaging.options.resourcePackages;\n  let id = packaging.jetpackID;\n\n  function caller(stack, levels) {\n    var e = {\n      stack: stack\n    };\n    let callerInfo = traceback.fromException(e).slice(-2-levels)[0];\n    let info = url.URL(callerInfo.filename);\n    let pkgName = resourcePackages[info.host];\n    // pkgName is \"my-package\", suitable for lookup in options[\"packageData\"]\n    return pkgName;\n  }\n\n  function getURL(name, stack, level) {\n    let pkgName = caller(stack, level);\n    // packageData[] = \"resource://jetpack-JID-PKGNAME-data/\"\n    if (pkgName in packageData)\n      return url.URL(name, packageData[pkgName]).toString();\n    throw new Error(\"No data for package \" + pkgName);\n  }\n\n  exports.register = function(addon) {\n    addon.registerCall(\"self:id\", function(name) {\n      return id;\n    });\n    addon.registerCall(\"self:name\", function(name) {\n      return packaging.options.name;\n    });\n    addon.registerCall(\"self:load\", function(name, path, stack) {\n      let data_url = getURL(path, stack, 1);\n      let fn = url.toFilename(data_url);\n      let data = file.read(fn);\n      return data;\n    });\n    addon.registerCall(\"self:url\", function(name, path, stack) {\n      return getURL(path, stack, 1);\n    });\n  }\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "self-e10s-adapter"
    }
  }, 
  {
    "pk": 67, 
    "model": "jetpack.module", 
    "fields": {
      "code": "\nlet file = require(\"file\");\nlet url = require(\"url\");\n\nlet jid = packaging.jetpackID;\nlet name = packaging.options.name;\n\n// Some XPCOM APIs require valid URIs as an argument for certain operations (see\n// `nsILoginManager` for example). This property represents add-on associated\n// unique URI string that can be used for that.\nlet uri = \"addon:\" + jid;\n\nexports.makeSelfModule = function (reqdata) {\n  // a module loaded from URI has called require(MODULE)\n  // URI is like resource://jid0-$JID/$PACKAGE-$SECTION/$SUBDIR/$FILENAME\n  // resource://jid0-abc123/reading-data-lib/main.js\n  // and we want resource://jid0-abc123/reading-data-data/\n\n  var data_url = function(name) {\n    // dataURIPrefix ends with a slash\n    var x = reqdata.dataURIPrefix + name;\n    return x;\n  };\n  var data_load = function(name) {\n    let fn = url.toFilename(data_url(name));\n    return file.read(fn);\n  };\n    \n  var self = {\n    id: jid,\n    uri: uri,\n    data: {\n      load: data_load,\n      url: data_url\n    }\n  };\n  return self;\n};\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "self-maker"
    }
  }, 
  {
    "pk": 32, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// Override the default Iterator function with one that passes\n// a second argument to custom iterator methods that identifies\n// the call as originating from an Iterator function so the custom\n// iterator method can return [key, value] pairs just like default\n// iterators called via the default Iterator function.\n\nIterator = (function(DefaultIterator) {\n  return function Iterator(obj, keysOnly) {\n    if (\"__iterator__\" in obj && !keysOnly)\n      return obj.__iterator__.call(obj, false, true);\n    return DefaultIterator(obj, keysOnly);\n  };\n})(Iterator);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "shims"
    }
  }, 
  {
    "pk": 86, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nconst file = require(\"file\");\nconst prefs = require(\"preferences-service\");\nconst jpSelf = require(\"self\");\nconst timer = require(\"timer\");\nconst unload = require(\"unload\");\nconst { EventEmitter } = require(\"events\");\nconst { Trait } = require(\"traits\");\n\nconst WRITE_PERIOD_PREF = \"extensions.addon-sdk.simple-storage.writePeriod\";\nconst WRITE_PERIOD_DEFAULT = 300000; // 5 minutes\n\nconst QUOTA_PREF = \"extensions.addon-sdk.simple-storage.quota\";\nconst QUOTA_DEFAULT = 5242880; // 5 MiB\n\nconst JETPACK_DIR_BASENAME = \"jetpack\";\n\n\n// simpleStorage.storage\nexports.__defineGetter__(\"storage\", function () manager.root);\nexports.__defineSetter__(\"storage\", function (val) manager.root = val);\n\n// simpleStorage.quotaUsage\nexports.__defineGetter__(\"quotaUsage\", function () manager.quotaUsage);\n\n// A generic JSON store backed by a file on disk.  This should be isolated\n// enough to move to its own module if need be...\nfunction JsonStore(options) {\n  this.filename = options.filename;\n  this.quota = options.quota;\n  this.writePeriod = options.writePeriod;\n  this.onOverQuota = options.onOverQuota;\n  this.onWrite = options.onWrite;\n\n  unload.ensure(this);\n\n  this.writeTimer = timer.setInterval(this.write.bind(this),\n                                      this.writePeriod);\n}\n\nJsonStore.prototype = {\n  // The store's root.\n  get root() {\n    return this._root === undefined ? {} : this._root;\n  },\n\n  // Performs some type checking.\n  set root(val) {\n    let types = [\"array\", \"boolean\", \"null\", \"number\", \"object\", \"string\"];\n    if (types.indexOf(typeof(val)) < 0) {\n      throw new Error(\"storage must be one of the following types: \" +\n                      types.join(\", \"));\n    }\n    this._root = val;\n    return val;\n  },\n\n  // Percentage of quota used, as a number [0, Inf).  > 1 implies over quota.\n  // Undefined if there is no quota.\n  get quotaUsage() {\n    return this.quota > 0 ?\n           JSON.stringify(this.root).length / this.quota :\n           undefined;\n  },\n\n  // Removes the backing file and all empty subdirectories.\n  purge: function JsonStore_purge() {\n    try {\n      // This'll throw if the file doesn't exist.\n      file.remove(this.filename);\n      let parentPath = this.filename;\n      do {\n        parentPath = file.dirname(parentPath);\n        // This'll throw if the dir isn't empty.\n        file.rmdir(parentPath);\n      } while (file.basename(parentPath) !== JETPACK_DIR_BASENAME);\n    }\n    catch (err) {}\n  },\n\n  // Initializes the root by reading the backing file.\n  read: function JsonStore_read() {\n    try {\n      let str = file.read(this.filename);\n\n      // Ideally we'd log the parse error with console.error(), but logged\n      // errors cause tests to fail.  Supporting \"known\" errors in the test\n      // harness appears to be non-trivial.  Maybe later.\n      this.root = JSON.parse(str);\n    }\n    catch (err) {\n      this.root = {};\n    }\n  },\n\n  // If the store is under quota, writes the root to the backing file.\n  // Otherwise quota observers are notified and nothing is written.\n  write: function JsonStore_write() {\n    if (this.quotaUsage > 1)\n      this.onOverQuota(this);\n    else\n      this._write();\n  },\n\n  // Cleans up on unload.  If unloading because of uninstall, the store is\n  // purged; otherwise it's written.\n  unload: function JsonStore_unload(reason) {\n    timer.clearInterval(this.writeTimer);\n    this.writeTimer = null;\n\n    if (reason === \"uninstall\")\n      this.purge();\n    else\n      this._write();\n  },\n\n  // True if the root is an empty object.\n  get _isEmpty() {\n    if (this.root && typeof(this.root) === \"object\") {\n      let empty = true;\n      for (let key in this.root) {\n        empty = false;\n        break;\n      }\n      return empty;\n    }\n    return false;\n  },\n\n  // Writes the root to the backing file, notifying write observers when\n  // complete.  If the store is over quota or if it's empty and the store has\n  // never been written, nothing is written and write observers aren't notified.\n  _write: function JsonStore__write() {\n    // If the store is empty and the file doesn't yet exist, don't write.\n    if (this._isEmpty && !file.exists(this.filename))\n      return;\n\n    // If the store is over quota, don't write.  The current under-quota state\n    // should persist.\n    if (this.quotaUsage > 1)\n      return;\n\n    // Finally, write.\n    let stream = file.open(this.filename, \"w\");\n    try {\n      stream.writeAsync(JSON.stringify(this.root), function writeAsync(err) {\n        if (err)\n          console.error(\"Error writing simple storage file: \" + this.filename);\n        else if (this.onWrite)\n          this.onWrite(this);\n      }.bind(this));\n    }\n    catch (err) {\n      // writeAsync closes the stream after it's done, so only close on error.\n      stream.close();\n    }\n  }\n};\n\n\n// This manages a JsonStore singleton and tailors its use to simple storage.\n// The root of the JsonStore is lazy-loaded:  The backing file is only read the\n// first time the root's gotten.\nlet manager = Trait.compose(EventEmitter, Trait.compose({\n  jsonStore: null,\n\n  // The filename of the store, based on the profile dir and extension ID.\n  get filename() {\n    let storeFile = Cc[\"@mozilla.org/file/directory_service;1\"].\n                    getService(Ci.nsIProperties).\n                    get(\"ProfD\", Ci.nsIFile);\n    storeFile.append(JETPACK_DIR_BASENAME);\n    storeFile.append(jpSelf.id);\n    storeFile.append(\"simple-storage\");\n    file.mkpath(storeFile.path);\n    storeFile.append(\"store.json\");\n    return storeFile.path;\n  },\n\n  get quotaUsage() {\n    return this.jsonStore.quotaUsage;\n  },\n\n  get root() {\n    if (!this.rootInited) {\n      this.jsonStore.read();\n      this.rootInited = true;\n    }\n    return this.jsonStore.root;\n  },\n\n  set root(val) {\n    let rv = this.jsonStore.root = val;\n    this.rootInited = true;\n    return rv;\n  },\n\n  unload: function manager_unload() {\n    this._removeAllListeners(\"OverQuota\");\n    this._removeAllListeners(\"error\");\n  },\n\n  constructor: function manager_constructor() {\n    // Log unhandled errors.\n    this.on(\"error\", console.exception.bind(console));\n    unload.ensure(this);\n\n    this.jsonStore = new JsonStore({\n      filename: this.filename,\n      writePeriod: prefs.get(WRITE_PERIOD_PREF, WRITE_PERIOD_DEFAULT),\n      quota: prefs.get(QUOTA_PREF, QUOTA_DEFAULT),\n      onOverQuota: this._emitOnObject.bind(this, exports, \"OverQuota\")\n    });\n  }\n}))();\n\nexports.on = manager.on;\nexports.removeListener = manager.removeListener;\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "simple-storage"
    }
  }, 
  {
    "pk": 19, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Dietrich Ayala <dietrich@mozilla.com>\n *   Felipe Gomes <felipc@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cu} = require(\"chrome\");\nvar NetUtil = {};\nCu.import(\"resource://gre/modules/NetUtil.jsm\", NetUtil);\nNetUtil = NetUtil.NetUtil;\nconst errors = require(\"errors\");\nconst windowUtils = require(\"window-utils\");\nconst apiUtils = require(\"api-utils\");\nconst collection = require(\"collection\");\n\n// TODO: The hard-coding of app-specific info here isn't very nice;\n// ideally such app-specific info should be more decoupled, and the\n// module should be extensible, allowing for support of new apps at\n// runtime, perhaps by inspecting supported packages (e.g. via\n// dynamically-named modules or package-defined extension points).\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The tab-browser module currently supports only Firefox.  In the future \",\n    \"it will support other applications. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\n// Utility function to open a new browser window.\nfunction openBrowserWindow(callback, url) {\n  let ww = Cc[\"@mozilla.org/embedcomp/window-watcher;1\"].\n           getService(Ci.nsIWindowWatcher);\n  let urlString = Cc[\"@mozilla.org/supports-string;1\"].\n                  createInstance(Ci.nsISupportsString);\n  urlString.data = url;\n  let window = ww.openWindow(null, \"chrome://browser/content/browser.xul\",\n                             \"_blank\", \"chrome,all,dialog=no\", urlString);\n  if (callback) {\n    function onLoad(event) {\n      if (event.target && event.target.defaultView == window) {\n        window.removeEventListener(\"load\", onLoad, true);\n        try {\n          require(\"timer\").setTimeout(function () {\n            callback(event);\n          }, 10);\n        } catch (e) { console.exception(e); }\n      }\n    }\n\n    window.addEventListener(\"load\", onLoad, true);\n  }\n\n  return window;\n}\n\n// Open a URL in a new tab\nexports.addTab = function addTab(url, options) {\n  if (!options)\n    options = {};\n  options.url = url;\n\n  options = apiUtils.validateOptions(options, {\n    // TODO: take URL object instead of string (bug 564524)\n    url: {\n      is: [\"string\"],\n      ok: function (v) !!v,\n      msg: \"The url parameter must have be a non-empty string.\"\n    },\n    inNewWindow: {\n      is: [\"undefined\", \"null\", \"boolean\"]\n    },\n    inBackground: {\n      is: [\"undefined\", \"null\", \"boolean\"]\n    },\n    onLoad: {\n      is: [\"undefined\", \"null\", \"function\"]\n    },\n    isPinned: {\n      is: [\"undefined\", \"boolean\"]\n    }\n  });\n\n  var wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"]\n           .getService(Ci.nsIWindowMediator);\n  var win = wm.getMostRecentWindow(\"navigator:browser\");\n  if (!win || options.inNewWindow) {\n    openBrowserWindow(function(e) {\n      if(options.isPinned) {\n        //get the active tab in the recently created window\n        let mainWindow = e.target.defaultView;\n        mainWindow.gBrowser.pinTab(mainWindow.gBrowser.selectedTab);\n      }\n      require(\"errors\").catchAndLog(function(e) options.onLoad(e))(e);\n    }, options.url);\n  } else {\n    let tab = win.gBrowser.addTab(options.url);\n    if (!options.inBackground)\n      win.gBrowser.selectedTab = tab;\n    if (options.onLoad) {\n      let tabBrowser = win.gBrowser.getBrowserForTab(tab);\n      tabBrowser.addEventListener(\"load\", function(e) {\n        if (e.target.defaultView.content.location == \"about:blank\")\n          return;\n        // remove event handler from addTab - don't want notified\n        // for subsequent loads in same tab.\n        tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n        require(\"errors\").catchAndLog(function(e) options.onLoad(e))(e);\n      }, true);\n    }\n  }\n}\n\n// Iterate over a window's tabbrowsers\nfunction tabBrowserIterator(window) {\n  var browsers = window.document.querySelectorAll(\"tabbrowser\");\n  for (var i = 0; i < browsers.length; i++)\n    yield browsers[i];\n}\n\n// Iterate over a tabbrowser's tabs\nfunction tabIterator(tabbrowser) {\n  var tabs = tabbrowser.tabContainer;\n  for (var i = 0; i < tabs.children.length; i++) {\n    yield tabs.children[i];\n  }\n}\n\n// Tracker for all tabbrowsers across all windows,\n// or a single tabbrowser if the window is given.\nfunction Tracker(delegate, window) {\n  this._delegate = delegate;\n  this._browsers = [];\n  this._window = window;\n  this._windowTracker = new windowUtils.WindowTracker(this);\n\n  require(\"unload\").ensure(this);\n}\nTracker.prototype = {\n  __iterator__: function __iterator__() {\n    for (var i = 0; i < this._browsers.length; i++)\n      yield this._browsers[i];\n  },\n  get: function get(index) {\n    return this._browsers[index];\n  },\n  onTrack: function onTrack(window) {\n    if (this._window && window != this._window)\n      return;\n\n    for (browser in tabBrowserIterator(window))\n      this._browsers.push(browser);\n    if (this._delegate)\n      for (browser in tabBrowserIterator(window))\n        this._delegate.onTrack(browser);\n  },\n  onUntrack: function onUntrack(window) {\n    if (this._window && window != this._window)\n      return;\n\n    for (browser in tabBrowserIterator(window)) {\n      let index = this._browsers.indexOf(browser);\n      if (index != -1)\n        this._browsers.splice(index, 1);\n      else\n        console.error(\"internal error: browser tab not found\");\n    }\n    if (this._delegate)\n      for (browser in tabBrowserIterator(window))\n        this._delegate.onUntrack(browser);\n  },\n  get length() {\n    return this._browsers.length;\n  },\n  unload: function unload() {\n    this._windowTracker.unload();\n  }\n};\nexports.Tracker = apiUtils.publicConstructor(Tracker);\n\n// Tracker for all tabs across all windows,\n// or a single window if it's given.\nfunction TabTracker(delegate, window) {\n  this._delegate = delegate;\n  this._tabs = [];\n  this._tracker = new Tracker(this, window);\n  require(\"unload\").ensure(this);\n}\nTabTracker.prototype = {\n  _TAB_EVENTS: [\"TabOpen\", \"TabClose\"],\n  _safeTrackTab: function safeTrackTab(tab) {\n    this._tabs.push(tab);\n    try {\n      this._delegate.onTrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeUntrackTab: function safeUntrackTab(tab) {\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    this._tabs.splice(index, 1);\n    try {\n      this._delegate.onUntrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  handleEvent: function handleEvent(event) {\n    switch (event.type) {\n    case \"TabOpen\":\n      this._safeTrackTab(event.target);\n      break;\n    case \"TabClose\":\n      this._safeUntrackTab(event.target);\n      break;\n    default:\n      throw new Error(\"internal error: unknown event type: \" +\n                      event.type);\n    }\n  },\n  onTrack: function onTrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeTrackTab(tab);\n    var self = this;\n    this._TAB_EVENTS.forEach(\n      function(eventName) {\n        tabbrowser.tabContainer.addEventListener(eventName, self, true);\n      });\n  },\n  onUntrack: function onUntrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeUntrackTab(tab);\n    var self = this;\n    this._TAB_EVENTS.forEach(\n      function(eventName) {\n        tabbrowser.tabContainer.removeEventListener(eventName, self, true);\n      });\n  },\n  unload: function unload() {\n    this._tracker.unload();\n  }\n};\nexports.TabTracker = apiUtils.publicConstructor(TabTracker);\n\nexports.whenContentLoaded = function whenContentLoaded(callback) {\n  var cb = require(\"errors\").catchAndLog(function eventHandler(event) {\n    if (event.target && event.target.defaultView)\n      callback(event.target.defaultView);\n  });\n\n  var tracker = new Tracker({\n    onTrack: function(tabBrowser) {\n      tabBrowser.addEventListener(\"DOMContentLoaded\", cb, false);\n    },\n    onUntrack: function(tabBrowser) {\n      tabBrowser.removeEventListener(\"DOMContentLoaded\", cb, false);\n    }\n  });\n\n  return tracker;\n};\n\nexports.__defineGetter__(\"activeTab\", function() {\n  const wm = Cc[\"@mozilla.org/appshell/window-mediator;1\"].\n             getService(Ci.nsIWindowMediator);\n  let mainWindow = wm.getMostRecentWindow(\"navigator:browser\");\n  return mainWindow.gBrowser.selectedTab;\n});\n\n/******************* TabModule *********************/\n\n// Supported tab events\nconst events = [\n  \"onActivate\",\n  \"onDeactivate\",\n  \"onOpen\",\n  \"onClose\",\n  \"onReady\",\n  \"onLoad\",\n  \"onPaint\"\n];\nexports.tabEvents = events;\n\n/**\n * TabModule\n *\n * Constructor for a module that implements the tabs API\n */\nlet TabModule = exports.TabModule = function TabModule(window) {\n  let self = this;\n  /**\n   * Tab\n   *\n   * Safe object representing a tab.\n   */\n  let tabConstructor = apiUtils.publicConstructor(function(element) {\n    if (!element)\n      throw new Error(\"no tab element.\");\n    let win = element.ownerDocument.defaultView;\n    if (!win)\n      throw new Error(\"element has no window.\");\n    if (window && win != window)\n      throw new Error(\"module's window and element's window don't match.\");\n    let browser = win.gBrowser.getBrowserForTab(element);\n\n    this.__defineGetter__(\"title\", function() browser.contentDocument.title);\n    this.__defineGetter__(\"location\", function() browser.contentDocument.location);\n    this.__defineSetter__(\"location\", function(val) browser.contentDocument.location = val);\n    this.__defineGetter__(\"contentWindow\", function() browser.contentWindow);\n    this.__defineGetter__(\"contentDocument\", function() browser.contentDocument);\n    this.__defineGetter__(\"favicon\", function() {\n      let pageURI = NetUtil.newURI(browser.contentDocument.location);\n      let fs = Cc[\"@mozilla.org/browser/favicon-service;1\"].\n               getService(Ci.nsIFaviconService);\n      let faviconURL;\n      try {\n        let faviconURI = fs.getFaviconForPage(pageURI);\n        faviconURL = fs.getFaviconDataAsDataURL(faviconURI);\n      } catch(ex) {\n        let data = getChromeURLContents(\"chrome://mozapps/skin/places/defaultFavicon.png\");\n        let encoded = browser.contentWindow.btoa(data);\n        faviconURL = \"data:image/png;base64,\" + encoded;\n      }\n      return faviconURL;\n    });\n    this.__defineGetter__(\"style\", function() null); // TODO\n    this.__defineGetter__(\"index\", function() win.gBrowser.getBrowserIndexForDocument(browser.contentDocument));\n    this.__defineGetter__(\"thumbnail\", function() getThumbnailCanvasForTab(element, browser.contentWindow));\n\n    this.close = function() win.gBrowser.removeTab(element);\n    this.move = function(index) {\n      win.gBrowser.moveTabTo(element, index);\n    };\n\n    this.__defineGetter__(\"isPinned\", function() element.pinned);\n    this.pin = function() win.gBrowser.pinTab(element);\n    this.unpin = function() win.gBrowser.unpinTab(element);\n\n    // Set up the event handlers\n    let tab = this;\n    events.filter(function(e) e != \"onOpen\").forEach(function(e) {\n      // create a collection for each event\n      collection.addCollectionProperty(tab, e);\n      // make tabs setter for each event, for adding via property assignment\n      tab.__defineSetter__(e, function(val) tab[e].add(val));\n    });\n\n    // listen for events, filtered on this tab\n    eventsTabDelegate.addTabDelegate(this);\n  });\n\n  /**\n   * tabs.activeTab\n   */\n  this.__defineGetter__(\"activeTab\", function() {\n    try {\n      return window ? tabConstructor(window.gBrowser.selectedTab)\n                    : tabConstructor(exports.activeTab);\n    }\n    catch (e) { }\n    return null;\n  });\n  this.__defineSetter__(\"activeTab\", function(tab) {\n    let [tabElement, win] = getElementAndWindowForTab(tab, window);\n    if (tabElement) {\n      // set as active tab\n      win.gBrowser.selectedTab = tabElement;\n      // focus the window\n      win.focus();\n    }\n  });\n\n  this.open = function TM_open(options) {\n    open(options, tabConstructor, window);\n  }\n\n  // Set up the event handlers\n  events.forEach(function(eventHandler) {\n    // create a collection for each event\n    collection.addCollectionProperty(self, eventHandler);\n    // make tabs setter for each event, for adding via property assignment\n    self.__defineSetter__(eventHandler, function(val) self[eventHandler].add(val));\n  });\n\n  // Tracker that listens for tab events, and proxies\n  // them to registered event listeners.\n  let eventsTabDelegate = {\n    selectedTab: null,\n    tabs: [],\n    addTabDelegate: function TETT_addTabDelegate(tabObj) {\n      this.tabs.push(tabObj);\n    },\n    pushTabEvent: function TETT_pushTabEvent(event, tab) {\n      for (let callback in self[event]) {\n        require(\"errors\").catchAndLog(function(tab) {\n          callback(new tabConstructor(tab));\n        })(tab);\n      }\n\n      if (event != \"onOpen\") {\n        this.tabs.forEach(function(tabObj) {\n          if (tabObj[event].length) {\n            let [tabEl,] = getElementAndWindowForTab(tabObj, window);\n            if (tabEl == tab) {\n              for (let callback in tabObj[event])\n                require(\"errors\").catchAndLog(function() callback())();\n            }\n          }\n          // if being closed, remove the tab object from the cache\n          // of tabs to notify about events.\n          if (event == \"onClose\")\n            this.tabs.splice(this.tabs.indexOf(tabObj), 1);\n        }, this);\n      }\n    },\n    unload: function() {\n      this.selectedTab = null;\n      this.tabs.splice(0);\n    }\n  };\n  require(\"unload\").ensure(eventsTabDelegate);\n\n  let eventsTabTracker = new ModuleTabTracker({\n    onTrack: function TETT_onTrack(tab) {\n      eventsTabDelegate.pushTabEvent(\"onOpen\", tab);\n    },\n    onUntrack: function TETT_onUntrack(tab) {\n      eventsTabDelegate.pushTabEvent(\"onClose\", tab);\n    },\n    onSelect: function TETT_onSelect(tab) {\n      if (eventsTabDelegate.selectedTab)\n        eventsTabDelegate.pushTabEvent(\"onDeactivate\", tab);\n\n      eventsTabDelegate.selectedTab = new tabConstructor(tab);\n\n      eventsTabDelegate.pushTabEvent(\"onActivate\", tab);\n    },\n    onReady: function TETT_onReady(tab) {\n      eventsTabDelegate.pushTabEvent(\"onReady\", tab);\n    },\n    onLoad: function TETT_onLoad(tab) {\n      eventsTabDelegate.pushTabEvent(\"onLoad\", tab);\n    },\n    onPaint: function TETT_onPaint(tab) {\n      eventsTabDelegate.pushTabEvent(\"onPaint\", tab);\n    }\n  }, window);\n  require(\"unload\").ensure(eventsTabTracker);\n\n  // Iterator for all tabs\n  this.__iterator__ = function tabsIterator() {\n    for (let i = 0; i < eventsTabTracker._tabs.length; i++)\n      yield tabConstructor(eventsTabTracker._tabs[i]);\n  }\n\n  this.__defineGetter__(\"length\", function() eventsTabTracker._tabs.length);\n\n  // Cleanup when unloaded\n  this.unload = function TM_unload() {\n    // Unregister tabs event listeners\n    events.forEach(function(e) self[e] = []);\n  }\n  require(\"unload\").ensure(this);\n\n} // End of TabModule constructor\n\n/**\n * tabs.open - open a URL in a new tab\n */\nfunction open(options, tabConstructor, window) {\n  if (typeof options === \"string\")\n    options = { url: options };\n\n  options = apiUtils.validateOptions(options, {\n    url: {\n      is: [\"string\"]\n    },\n    inNewWindow: {\n      is: [\"undefined\", \"boolean\"]\n    },\n    inBackground: {\n      is: [\"undefined\", \"boolean\"]\n    },\n    isPinned: {\n      is: [\"undefined\", \"boolean\"]\n    },\n    onOpen: {\n      is: [\"undefined\", \"function\"]\n    }\n  });\n\n  if (window)\n    options.inNewWindow = false;\n\n  let win = window || require(\"window-utils\").activeBrowserWindow;\n\n  if (!win || options.inNewWindow)\n    openURLInNewWindow(options, tabConstructor);\n  else\n    openURLInNewTab(options, win, tabConstructor);\n}\n\nfunction openURLInNewWindow(options, tabConstructor) {\n  let addTabOptions = {\n    inNewWindow: true\n  };\n  if (options.onOpen) {\n    addTabOptions.onLoad = function(e) {\n      let win = e.target.defaultView;\n      let tabEl = win.gBrowser.tabContainer.childNodes[0];\n      let tabBrowser = win.gBrowser.getBrowserForTab(tabEl);\n      tabBrowser.addEventListener(\"load\", function(e) {\n        tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n        let tab = tabConstructor(tabEl);\n        require(\"errors\").catchAndLog(function(e) options.onOpen(e))(tab);\n      }, true);\n    };\n  }\n  if (options.isPinned) {\n    addTabOptions.isPinned = true;\n  }\n  exports.addTab(options.url.toString(), addTabOptions);\n}\n\nfunction openURLInNewTab(options, window, tabConstructor) {\n  window.focus();\n  let tabEl = window.gBrowser.addTab(options.url.toString());\n  if (!options.inBackground)\n    window.gBrowser.selectedTab = tabEl;\n  if (options.isPinned)\n    window.gBrowser.pinTab(tabEl);\n  if (options.onOpen) {\n    let tabBrowser = window.gBrowser.getBrowserForTab(tabEl);\n    tabBrowser.addEventListener(\"load\", function(e) {\n      // remove event handler from addTab - don't want to be notified\n      // for subsequent loads in same tab.\n      tabBrowser.removeEventListener(\"load\", arguments.callee, true);\n      let tab = tabConstructor(tabEl);\n      require(\"timer\").setTimeout(function() {\n        require(\"errors\").catchAndLog(function(tab) options.onOpen(tab))(tab);\n      }, 10);\n    }, true);\n  }\n}\n\nfunction getElementAndWindowForTab(tabObj, window) {\n  // iterate over open windows, or use single window if provided\n  let windowIterator = window ? function() { yield window; }\n                              : require(\"window-utils\").windowIterator;\n  for (let win in windowIterator()) {\n    if (win.gBrowser) {\n      // find the tab element at tab.index\n      let index = win.gBrowser.getBrowserIndexForDocument(tabObj.contentDocument);\n      if (index > -1)\n        return [win.gBrowser.tabContainer.getItemAtIndex(index), win];\n    }\n  }\n  return [null, null];\n}\n\n// Tracker for all tabs across all windows\n// This is tab-browser.TabTracker, but with\n// support for additional events added.\nfunction ModuleTabTracker(delegate, window) {\n  this._delegate = delegate;\n  this._tabs = [];\n  this._tracker = new Tracker(this, window);\n  require(\"unload\").ensure(this);\n}\nModuleTabTracker.prototype = {\n  _TAB_EVENTS: [\"TabOpen\", \"TabClose\", \"TabSelect\", \"DOMContentLoaded\",\n                \"load\", \"MozAfterPaint\"],\n  _safeTrackTab: function safeTrackTab(tab) {\n    tab.addEventListener(\"load\", this, false);\n    tab.linkedBrowser.addEventListener(\"MozAfterPaint\", this, false);\n    this._tabs.push(tab);\n    try {\n      this._delegate.onTrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeUntrackTab: function safeUntrackTab(tab) {\n    tab.removeEventListener(\"load\", this, false);\n    tab.linkedBrowser.removeEventListener(\"MozAfterPaint\", this, false);\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      throw new Error(\"internal error: tab not found\");\n    this._tabs.splice(index, 1);\n    try {\n      this._delegate.onUntrack(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeSelectTab: function safeSelectTab(tab) {\n    var index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onSelect)\n        this._delegate.onSelect(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeDOMContentLoaded: function safeDOMContentLoaded(event) {\n    let tabBrowser = event.currentTarget;\n    let tabBrowserIndex = tabBrowser.getBrowserIndexForDocument(event.target);\n    // TODO: I'm seeing this when loading data url images\n    if (tabBrowserIndex == -1)\n      return;\n    let tab = tabBrowser.tabContainer.getItemAtIndex(tabBrowserIndex);\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onReady)\n        this._delegate.onReady(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeLoad: function safeLoad(event) {\n    let tab = event.target;\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onLoad)\n        this._delegate.onLoad(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  _safeMozAfterPaint: function safeMozAfterPaint(event) {\n    let win = event.currentTarget.ownerDocument.defaultView;\n    let tabIndex = win.gBrowser.getBrowserIndexForDocument(event.target.document);\n    if (tabIndex == -1)\n      return;\n    let tab = win.gBrowser.tabContainer.getItemAtIndex(tabIndex);\n    let index = this._tabs.indexOf(tab);\n    if (index == -1)\n      console.error(\"internal error: tab not found\");\n    try {\n      if (this._delegate.onPaint)\n        this._delegate.onPaint(tab);\n    } catch (e) {\n      console.exception(e);\n    }\n  },\n  handleEvent: function handleEvent(event) {\n    switch (event.type) {\n    case \"TabOpen\":\n      this._safeTrackTab(event.target);\n      break;\n    case \"TabClose\":\n      this._safeUntrackTab(event.target);\n      break;\n    case \"TabSelect\":\n      this._safeSelectTab(event.target);\n      break;\n    case \"DOMContentLoaded\":\n      this._safeDOMContentLoaded(event);\n      break;\n    case \"load\":\n      this._safeLoad(event);\n      break;\n    case \"MozAfterPaint\":\n      this._safeMozAfterPaint(event);\n      break;\n    default:\n      throw new Error(\"internal error: unknown event type: \" +\n                      event.type);\n    }\n  },\n  onTrack: function onTrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeTrackTab(tab);\n    tabbrowser.tabContainer.addEventListener(\"TabOpen\", this, false);\n    tabbrowser.tabContainer.addEventListener(\"TabClose\", this, false);\n    tabbrowser.tabContainer.addEventListener(\"TabSelect\", this, false);\n    tabbrowser.ownerDocument.defaultView.gBrowser.addEventListener(\"DOMContentLoaded\", this, false);\n  },\n  onUntrack: function onUntrack(tabbrowser) {\n    for (tab in tabIterator(tabbrowser))\n      this._safeUntrackTab(tab);\n    tabbrowser.tabContainer.removeEventListener(\"TabOpen\", this, false);\n    tabbrowser.tabContainer.removeEventListener(\"TabClose\", this, false);\n    tabbrowser.tabContainer.removeEventListener(\"TabSelect\", this, false);\n    tabbrowser.ownerDocument.defaultView.gBrowser.removeEventListener(\"DOMContentLoaded\", this, false);\n  },\n  unload: function unload() {\n    this._tracker.unload();\n  }\n};\n\n// Utility to get a thumbnail canvas from a tab object\nfunction getThumbnailCanvasForTab(tabEl, window) {\n  var thumbnail = window.document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n  thumbnail.mozOpaque = true;\n  var window = tabEl.linkedBrowser.contentWindow;\n  thumbnail.width = Math.ceil(window.screen.availWidth / 5.75);\n  var aspectRatio = 0.5625; // 16:9\n  thumbnail.height = Math.round(thumbnail.width * aspectRatio);\n  var ctx = thumbnail.getContext(\"2d\");\n  var snippetWidth = window.innerWidth * .6;\n  var scale = thumbnail.width / snippetWidth;\n  ctx.scale(scale, scale);\n  ctx.drawWindow(window, window.scrollX, window.scrollY, snippetWidth, snippetWidth * aspectRatio, \"rgb(255,255,255)\");\n  return thumbnail;\n}\n\n// Utility to return the contents of the target of a chrome URL\nfunction getChromeURLContents(chromeURL) {\n  let io = Cc[\"@mozilla.org/network/io-service;1\"].\n           getService(Ci.nsIIOService);\n  let channel = io.newChannel(chromeURL, null, null);\n  let input = channel.open();\n  let stream = Cc[\"@mozilla.org/binaryinputstream;1\"].\n               createInstance(Ci.nsIBinaryInputStream); \n  stream.setInputStream(input);\n  let str = stream.readBytes(input.available());\n  stream.close();\n  input.close();\n  return str;\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "tab-browser"
    }
  }, 
  {
    "pk": 77, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Dietrich Ayala <dietrich@mozilla.com> (Original author)\n *   Felipe Gomes <felipc@gmail.com>\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The tabs module currently supports only Firefox.  In the future \",\n    \"we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nconst { browserWindows } = require(\"windows\");\nconst { tabs } = require(\"windows/tabs\");\n\nObject.defineProperties(tabs, {\n  open: { value: function open(options) {\n    if (options.inNewWindow)\n        // `tabs` option is under review and may be removed.\n        return browserWindows.open({ tabs: [ options ] });\n    // Open in active window if new window was not required.\n    return browserWindows.activeWindow.tabs.open(options);\n  }}\n});\n// It's a hack but we will be able to remove it once will implemnet CommonJS\n// feature that would allow us to override exports.\nexports.__proto__ = tabs;\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "tabs"
    }
  }, 
  {
    "pk": 52, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst ON_PREFIX = \"on\";\nconst TAB_PREFIX = \"Tab\";\n\nconst EVENTS = {\n  ready: \"DOMContentLoaded\",\n  open: \"TabOpen\",\n  close: \"TabClose\",\n  activate: \"TabSelect\",\n  deactivate: null\n}\nexports.EVENTS = EVENTS;\n\nObject.keys(EVENTS).forEach(function(name) {\n  EVENTS[name] = {\n    name: name,\n    listener: ON_PREFIX + name.charAt(0).toUpperCase() + name.substr(1),\n    dom: EVENTS[name]\n  }\n});\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "tabs/events"
    }
  }, 
  {
    "pk": 54, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { EventEmitterTrait: EventEmitter } = require(\"../events\");\nconst { DOMEventAssembler } = require(\"../events/assembler\");\nconst { Trait } = require(\"../light-traits\");\nconst { getActiveTab, getTabs, getTabContainers } = require(\"./utils\");\nconst { windowIterator, isBrowser } = require(\"../window-utils\");\nconst windowObserver = require(\"../windows/observer\");\n\nconst EVENTS = {\n  \"TabOpen\": \"open\",\n  \"TabClose\": \"close\",\n  \"TabSelect\": \"select\",\n  \"TabMove\": \"move\",\n  \"TabPinned\": \"pin\",\n  \"TabUnpinned\": \"unpin\"\n};\n\n\n// Event emitter objects used to register listeners and emit events on them\n// when they occur.\nconst observer = Trait.compose(DOMEventAssembler, EventEmitter).create({\n  /**\n   * Method is implemented by `EventEmitter` and is used just for emitting\n   * events on registered listeners.\n   */\n  _emit: Trait.required,\n  /**\n   * Events that are supported and emitted by the module.\n   */\n  supportedEventsTypes: Object.keys(EVENTS),\n  /**\n   * Function handles all the supported events on all the windows that are\n   * observed. Method is used to proxy events to the listeners registered on\n   * this event emitter.\n   * @param {Event} event\n   *    Keyboard event being emitted.\n   */\n  handleEvent: function handleEvent(event) {\n    this._emit(EVENTS[event.type], event.target, event);\n  }\n});\n\n// Currently gecko does not dispatches any event on the previously selected\n// tab before / after \"TabSelect\" is dispatched. In order to work around this\n// limitation we keep track of selected tab and emit \"deactivate\" event with\n// that before emitting \"activate\" on selected tab.\nvar selectedTab = null;\nfunction onTabSelect(tab) {\n  if (selectedTab !== tab) {\n    if (selectedTab) observer._emit(\"deactivate\", selectedTab);\n    if (tab) observer._emit(\"activate\", selectedTab = tab);\n  }\n};\nobserver.on(\"select\", onTabSelect);\n\n// We also observe opening / closing windows in order to add / remove it's\n// containers to the observed list.\nfunction onWindowOpen(chromeWindow) {\n  if (!isBrowser(chromeWindow)) return; // Ignore if it's not a browser window.\n  getTabContainers(chromeWindow).forEach(function (container) {\n    observer.observe(container);\n  });\n}\nwindowObserver.on(\"open\", onWindowOpen);\n\nfunction onWindowClose(chromeWindow) {\n  if (!isBrowser(chromeWindow)) return; // Ignore if it's not a browser window.\n  getTabContainers(chromeWindow).forEach(function (container) {\n    observer.ignore(container);\n  });\n}\nwindowObserver.on(\"close\", onWindowClose);\n\n\n// Currently gecko does not dispatches \"TabSelect\" events when different\n// window gets activated. To work around this limitation we emulate \"select\"\n// event for this case.\nwindowObserver.on(\"activate\", function onWindowActivate(chromeWindow) {\n  if (!isBrowser(chromeWindow)) return; // Ignore if it's not a browser window.\n  observer._emit(\"select\", getActiveTab(chromeWindow));\n});\n\n// We should synchronize state, since probably we already have at least one\n// window open.\nfor each (let window in windowIterator()) onWindowOpen(window);\n\n// Getting rid of all listeners when add-on is unloaded.\nrequire(\"unload\").when(function() { observer._events = {} });\n\nmodule.exports = observer;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "tabs/observer"
    }
  }, 
  {
    "pk": 53, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Ci } = require('chrome');\nconst { Trait } = require(\"traits\");\nconst { EventEmitter } = require(\"events\");\nconst { validateOptions } = require(\"api-utils\");\nconst { Enqueued } = require(\"utils/function\");\nconst { EVENTS } = require(\"tabs/events\");\nconst { getThumbnailURIForWindow } = require(\"utils/thumbnail\");\nconst { getFaviconURIForLocation } = require(\"utils/data\");\n\n\n\n// Array of the inner instances of all the wrapped tabs.\nconst TABS = [];\n\n/**\n * Trait used to create tab wrappers.\n */\nconst TabTrait = Trait.compose(EventEmitter, {\n  on: Trait.required,\n  _emit: Trait.required,\n  /**\n   * Tab DOM element that is being wrapped.\n   */\n  _tab: null,\n  /**\n   * Window wrapper whose tab this object represents.\n   */\n  window: null,\n  constructor: function Tab(options) {\n    this._onReady = this._onReady.bind(this);\n    this._tab = options.tab;\n    let window = this.window = options.window;\n    // Setting event listener if was passed.\n    for each (let type in EVENTS) {\n      let listener = options[type.listener];\n      if (listener)\n        this.on(type.name, options[type.listener]);\n      if ('ready' != type.name) // window spreads this event.\n        window.tabs.on(type.name, this._onEvent.bind(this, type.name));\n    }\n\n    this.on(EVENTS.close.name, this.destroy.bind(this));\n    this._browser.addEventListener(EVENTS.ready.dom, this._onReady, true);\n\n    if (options.isPinned)\n      this.pin();\n\n    // Since we will have to identify tabs by a DOM elements facade function\n    // is used as constructor that collects all the instances and makes sure\n    // that they more then one wrapper is not created per tab.\n    return this;\n  },\n  destroy: function destroy() {\n    for each (let type in EVENTS)\n      this._removeAllListeners(type.name);\n    this._browser.removeEventListener(EVENTS.ready.dom, this._onReady,\n                                            true);\n  },\n\n  /**\n   * Internal listener that emits public event 'ready' when the page of this\n   * tab is loaded.\n   */\n  _onReady: function _onReady(event) {\n    // IFrames events will bubble so we need to ignore those.\n    if (event.target == this._contentDocument)\n      this._emit(EVENTS.ready.name, this._public);\n  },\n  /**\n   * Internal tab event router. Window will emit tab related events for all it's\n   * tabs, this listener will propagate all the events for this tab to it's\n   * listeners.\n   */\n  _onEvent: function _onEvent(type, tab) {\n    if (tab == this._public)\n      this._emit(type, tab);\n  },\n  /**\n   * Browser DOM element where page of this tab is currently loaded.\n   */\n  get _browser() this._window.gBrowser.getBrowserForTab(this._tab),\n  /**\n   * Window DOM element containing this tab.\n   */\n  get _window() this._tab.ownerDocument.defaultView,\n  /**\n   * Document object of the page that is currently loaded in this tab.\n   */\n  get _contentDocument() this._browser.contentDocument,\n  /**\n   * Window object of the page that is currently loaded in this tab.\n   */\n  get _contentWindow() this._browser.contentWindow,\n\n  /**\n   * The title of the page currently loaded in the tab.\n   * Changing this property changes an actual title.\n   * @type {String}\n   */\n  get title() this._contentDocument.title,\n  set title(value) this._contentDocument.title = String(value),\n  /**\n   * Location of the page currently loaded in this tab.\n   * Changing this property will loads page under under the specified location.\n   * @type {String}\n   */\n  get url() String(this._contentDocument.location),\n  set url(value) this._changeLocation(String(value)),\n  // \"TabOpen\" event is fired when it's still \"about:blank\" is loaded in the\n  // changing `location` property of the `contentDocument` has no effect since\n  // seems to be either ignored or overridden by internal listener, there for\n  // location change is enqueued for the next turn of event loop.\n  _changeLocation: Enqueued(function(url) this._contentDocument.location = url),\n  /**\n   * URI of the favicon for the page currently loaded in this tab.\n   * @type {String}\n   */\n  get favicon() getFaviconURIForLocation(this.url),\n  /**\n   * The CSS style for the tab\n   */\n  get style() null, // TODO\n  /**\n   * The index of the tab relative to other tabs in the application window.\n   * Changing this property will change order of the actual position of the tab.\n   * @type {Number}\n   */\n  get index()\n    this._window.gBrowser.getBrowserIndexForDocument(this._contentDocument),\n  set index(value) this._window.gBrowser.moveTabTo(this._tab, value),\n  /**\n   * Thumbnail data URI of the page currently loaded in this tab.\n   * @type {String}\n   */\n  getThumbnail: function getThumbnail()\n    getThumbnailURIForWindow(this._contentWindow),\n  /**\n   * Whether or not tab is pinned (Is an app-tab).\n   * @type {Boolean}\n   */\n  get isPinned() this._tab.pinned,\n  pin: function pin() {\n    this._window.gBrowser.pinTab(this._tab);\n  },\n  unpin: function unpin() {\n    this._window.gBrowser.unpinTab(this._tab);\n  },\n  \n  /**\n   * Create a worker for this tab, first argument is options given to Worker.\n   * @type {Worker}\n   */\n  attach: function attach(options) {\n    let { Worker } = require(\"content/worker\");\n    options.window = this._contentWindow.wrappedJSObject;\n    let worker = Worker(options);\n    worker.once(\"detach\", function detach() {\n      worker.destroy();\n    });\n    return worker;\n  },\n  \n  /**\n   * Make this tab active.\n   * Please note: That this function is called synchronous since in E10S that\n   * will be the case. Besides this function is called from a constructor where\n   * we would like to return instance before firing a 'TabActivated' event.\n   */\n  activate: Enqueued(function activate() {\n    if (this._window) // Ignore if window is closed by the time this is invoked.\n      this._window.gBrowser.selectedTab = this._tab;\n  }),\n  /**\n   * Close the tab\n   */\n  close: function close(callback) {\n    if (callback)\n      this.once(EVENTS.close.name, callback);\n    this._window.gBrowser.removeTab(this._tab);\n  }\n});\n\nfunction Tab(options) {\n  let chromeTab = options.tab;\n  for each (let tab in TABS) {\n    if (chromeTab == tab._tab)\n      return tab._public;\n  }\n  let tab = TabTrait(options);\n  TABS.push(tab);\n  return tab._public;\n}\nTab.prototype = TabTrait.prototype;\nexports.Tab = Tab;\n\nfunction Options(options) {\n  if (\"string\" === typeof options)\n    options = { url: options };\n\n  return validateOptions(options, {\n    url: { is: [\"string\"] },\n    inBackground: { is: [\"undefined\", \"boolean\"] },\n    isPinned: { is: [\"undefined\", \"boolean\"] },\n    onOpen: { is: [\"undefined\", \"function\"] },\n    onClose: { is: [\"undefined\", \"function\"] },\n    onReady: { is: [\"undefined\", \"function\"] },\n    onActivate: { is: [\"undefined\", \"function\"] },\n    onDeactivate: { is: [\"undefined\", \"function\"] }\n  });\n}\nexports.Options = Options;\n\n\nexports.getTabForWindow = function (win) {\n  // Get browser window\n  let topWindow = win.QueryInterface(Ci.nsIInterfaceRequestor)\n                     .getInterface(Ci.nsIWebNavigation)\n                     .QueryInterface(Ci.nsIDocShellTreeItem)\n                     .rootTreeItem\n                     .QueryInterface(Ci.nsIInterfaceRequestor)\n                     .getInterface(Ci.nsIDOMWindow);\n  if (!topWindow.gBrowser) return null;\n  \n  // Get top window object, in case we are in a content iframe\n  let topContentWindow;\n  try {\n    topContentWindow = win.top;\n  } catch(e) {\n    // It may throw if win is not a valid content window\n    return null;\n  }\n  \n  function getWindowID(obj) {\n    return obj.QueryInterface(Ci.nsIInterfaceRequestor)\n              .getInterface(Ci.nsIDOMWindowUtils)\n              .currentInnerWindowID;\n  }\n  \n  // Search for related Tab\n  let topWindowId = getWindowID(topContentWindow);\n  for (let i = 0; i < topWindow.gBrowser.browsers.length; i++) {\n    let w = topWindow.gBrowser.browsers[i].contentWindow;\n    if (getWindowID(w) == topWindowId) {\n      return Tab({\n        window: require(\"windows\").BrowserWindow({ window: topWindow }),\n        tab: topWindow.gBrowser.tabs[i]\n      });\n    }\n  }\n  \n  // We were unable to find the related tab!\n  return null;\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "tabs/tab"
    }
  }, 
  {
    "pk": 51, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nfunction getTabContainer(tabBrowser) {\n  return tabBrowser.tabContainer;\n}\nexports.getTabContainer = getTabContainer;\n\nfunction getTabBrowsers(window) {\n  return Array.slice(window.document.getElementsByTagName(\"tabbrowser\"));\n}\nexports.getTabBrowsers = getTabBrowsers;\n\nfunction getTabContainers(window) {\n  return getTabBrowsers(window).map(getTabContainer);\n}\nexports.getTabContainers = getTabContainers;\n\nfunction getTabs(window) {\n  return getTabContainers(window).reduce(function (tabs, container) {\n    tabs.push.apply(tabs, container.children);\n    return tabs;\n  }, []);\n}\nexports.getTabs = getTabs;\n\nfunction getActiveTab(window) {\n  return window.gBrowser.selectedTab;\n}\nexports.getActiveTab = getActiveTab;\n\nfunction getOwnerWindow(tab) {\n  return tab.ownerDocument.defaultView;\n}\nexports.getOwnerWindow = getOwnerWindow;\n\nfunction openTab(window, url) {\n  return window.gBrowser.addTab(url);\n}\nexports.openTab = openTab;\n\nfunction activateTab(tab) {\n  getOwnerWindow(tab).gBrowser.selectedTab = tab;\n}\nexports.activateTab = activateTab;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "tabs/utils"
    }
  }, 
  {
    "pk": 59, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:ts=2:sts=2:sw=2:\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst BaseAssert = require(\"./test/assert\").Assert;\nconst { isFunction, isObject } = require(\"type\");\n\n/**\n * Function takes test `suite` object in CommonJS format and defines all of the\n * tests from that suite and nested suites in a jetpack format on a given\n * `target` object. Optionally third argument `prefix` can be passed to prefix\n * all the test names.\n */\nfunction defineTestSuite(target, suite, prefix) {\n  prefix = prefix || \"\";\n  // If suite defines `Assert` that's what `assert` object have to be created\n  // from and passed to a test function (This allows custom assertion functions)\n  // See for details: http://wiki.commonjs.org/wiki/Unit_Testing/1.1\n  let Assert = suite.Assert || BaseAssert;\n  // Going through each item in the test suite and wrapping it into a\n  // Jetpack test format.\n  Object.keys(suite).forEach(function(key) {\n     // If name starts with test then it's a test function or suite.\n    if (key.indexOf(\"test\") === 0) {\n      let test = suite[key];\n\n      // For each test function so we create a wrapper test function in a\n      // jetpack format and copy that to a `target` exports.\n      if (isFunction(test)) {\n\n        // Since names of the test may match across suites we use full object\n        // path as a name to avoid overriding same function.\n        target[prefix + key] = function(options) {\n\n          // Creating `assert` functions for this test.\n          let assert = Assert(options);\n\n          // If CommonJS test function expects more than one argument\n          // it means that test is async and second argument is a callback\n          // to notify that test is finished.\n          if (1 < test.length) {\n\n            // Letting test runner know that test is executed async and\n            // creating a callback function that CommonJS tests will call\n            // once it's done.\n            options.waitUntilDone();\n            test(assert, function() {\n              options.done();\n            });\n          }\n\n          // Otherwise CommonJS test is synchronous so we call it only with\n          // one argument.\n          else {\n            test(assert);\n          }\n        }\n      }\n\n      // If it's an object then it's a test suite containing test function\n      // and / or nested test suites. In that case we just extend prefix used\n      // and call this function to copy and wrap tests from nested suite.\n      else if (isObject(test)) {\n        test.Assert = test.Assert || Assert;\n        defineTestSuite(target, test, prefix + key + \".\");\n      }\n    }\n  });\n}\n\n/**\n * This function is a CommonJS test runner function, but since Jetpack test\n * runner and test format is different from CommonJS this function shims given\n * `exports` with all its tests into a Jetpack test format so that the built-in\n * test runner will be able to run CommonJS test without manual changes.\n */\nexports.run = function run(exports) {\n\n  // We can't leave old properties on exports since those are test in a CommonJS\n  // format that why we move everything to a new `suite` object.\n  let suite = {};\n  Object.keys(exports).forEach(function(key) {\n    suite[key] = exports[key];\n    delete exports[key];\n  });\n\n  // Now we wrap all the CommonJS tests to a Jetpack format and define\n  // those to a given `exports` object since that where jetpack test runner\n  // will look for them.\n  defineTestSuite(exports, suite);\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "test"
    }
  }, 
  {
    "pk": 3, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:ts=2:sts=2:sw=2:\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { isFunction, isNull, isObject, isString, isRegExp, isArray, isDate,\n        isPrimitive, isUndefined, instanceOf, source } = require(\"type\");\n\n/**\n * The `AssertionError` is defined in assert.\n * @extends Error\n * @example\n *  new assert.AssertionError({\n *    message: message,\n *    actual: actual,\n *    expected: expected\n *  })\n */\nfunction AssertionError(options) {\n  let assertionError = Object.create(AssertionError.prototype);\n\n  if (isString(options))\n    options = { message: options };\n  if (\"actual\" in options)\n    assertionError.actual = options.actual;\n  if (\"expected\" in options)\n    assertionError.expected = options.expected;\n  if (\"operator\" in options)\n    assertionError.operator = options.operator;\n\n  assertionError.message = options.message;\n  assertionError.stack = new Error().stack;\n  return assertionError;\n}\nAssertionError.prototype = Object.create(Error.prototype, {\n  constructor: { value: AssertionError },\n  name: { value: \"AssertionError\", enumerable: true },\n  toString: { value: function toString() {\n    let value;\n    if (this.message) {\n      value = this.name + \" : \" + this.message;\n    }\n    else {\n      value = [\n        this.name + \" : \",\n        source(this.expected),\n        this.operator,\n        source(this.actual)\n      ].join(\" \");\n    }\n    return value;\n  }}\n});\nexports.AssertionError = AssertionError;\n\nfunction Assert(logger) {\n  return Object.create(Assert.prototype, { _log: { value: logger }});\n}\nAssert.prototype = {\n  fail: function fail(e) {\n    this._log.fail(e.message);\n  },\n  pass: function pass(message) {\n    this._log.pass(message);\n  },\n  error: function error(e) {\n    this._log.exception(e);\n  },\n  ok: function ok(value, message) {\n    if (!!!value) {\n      this.fail({\n        actual: value,\n        expected: true,\n        message: message,\n        operator: \"==\"\n      });\n    }\n    else {\n      this.pass(message);\n    }\n  },\n\n  /**\n   * The equality assertion tests shallow, coercive equality with `==`.\n   * @example\n   *    assert.equal(1, 1, \"one is one\");\n   */\n  equal: function equal(actual, expected, message) {\n    if (actual == expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"==\"\n      });\n    }\n  },\n\n  /**\n   * The non-equality assertion tests for whether two objects are not equal\n   * with `!=`.\n   * @example\n   *    assert.notEqual(1, 2, \"one is not two\");\n   */\n  notEqual: function notEqual(actual, expected, message) {\n    if (actual != expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"!=\",\n      });\n    }\n  },\n\n  /**\n   * The equivalence assertion tests a deep (with `===`) equality relation.\n   * @example\n   *    assert.deepEqual({ a: \"foo\" }, { a: \"foo\" }, \"equivalent objects\")\n   */\n   deepEqual: function deepEqual(actual, expected, message) {\n    if (isDeepEqual(actual, expected)) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"deepEqual\"\n      });\n    }\n  },\n\n  /**\n   * The non-equivalence assertion tests for any deep (with `===`) inequality.\n   * @example\n   *    assert.notDeepEqual({ a: \"foo\" }, Object.create({ a: \"foo\" }),\n   *                        \"object's inherit from different prototypes\");\n   */\n  notDeepEqual: function notDeepEqual(actual, expected, message) {\n    if (!isDeepEqual(actual, expected)) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"notDeepEqual\"\n      });\n    }\n  },\n\n  /**\n   * The strict equality assertion tests strict equality, as determined by\n   * `===`.\n   * @example\n   *    assert.strictEqual(null, null, \"`null` is `null`\")\n   */\n  strictEqual: function strictEqual(actual, expected, message) {\n    if (actual === expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"===\"\n      });\n    }\n  },\n\n  /**\n   * The strict non-equality assertion tests for strict inequality, as\n   * determined by `!==`.\n   * @example\n   *    assert.notStrictEqual(null, undefined, \"`null` is not `undefined`\");\n   */\n  notStrictEqual: function notStrictEqual(actual, expected, message) {\n    if (actual !== expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"!==\"\n      })\n    }\n  },\n\n  /**\n   * The assertion whether or not given `block` throws an exception. If optional\n   * `Error` argument is provided and it's type of function thrown error is\n   * asserted to be an instance of it, if type of `Error` is string then message\n   * of throw exception is asserted to contain it.\n   * @param {Function} block\n   *    Function that is expected to throw.\n   * @param {Error|RegExp} [Error]\n   *    Error constructor that is expected to be thrown or a string that\n   *    must be contained by a message of the thrown exception, or a RegExp\n   *    matching a message of the thrown exception.\n   * @param {String} message\n   *    Description message\n   *\n   * @examples\n   *\n   *    assert.throws(function block() {\n   *      doSomething(4)\n   *    }, \"Object is expected\", \"Incorrect argument is passed\");\n   *\n   *    assert.throws(function block() {\n   *      Object.create(5)\n   *    }, TypeError, \"TypeError is thrown\");\n   */\n  throws: function throws(block, Error, message) {\n    let threw = false;\n    let exception = null;\n\n    // If third argument is not provided and second argument is a string it\n    // means that optional `Error` argument was not passed, so we shift\n    // arguments.\n    if (isString(Error) && isUndefined(message)) {\n      message = Error;\n      Error = undefined;\n    }\n\n    // Executing given `block`.\n    try {\n      block();\n    }\n    catch (e) {\n      threw = true;\n      exception = e;\n    }\n\n    // If exception was thrown and `Error` argument was not passed assert is\n    // passed.\n    if (threw && (isUndefined(Error) ||\n                 // If passed `Error` is RegExp using it's test method to\n                 // assert thrown exception message.\n                 (isRegExp(Error) && Error.test(exception.message)) ||\n                 // If passed `Error` is a constructor function testing if\n                 // thrown exception is an instance of it.\n                 (isFunction(Error) && instanceOf(exception, Error))))\n    {\n      this.pass(message);\n    }\n\n    // Otherwise we report assertion failure.\n    else {\n      let failure = {\n        message: message,\n        operator: \"throws\"\n      };\n\n      if (exception)\n        failure.actual = exception;\n\n      if (Error)\n        failure.expected = Error;\n\n      this.fail(failure);\n    }\n  }\n};\nexports.Assert = Assert;\n\nfunction isDeepEqual(actual, expected) {\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  else if (isDate(actual) && isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n  }\n\n  // XXX specification bug: this should be specified\n  else if (isPrimitive(actual) || isPrimitive(expected)) {\n    return expected === actual;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == \"object\",\n  // equivalence is determined by ==.\n  else if (!isObject(actual) && !isObject(expected)) {\n    return actual == expected;\n  }\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \"prototype\" property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  else {\n    return actual.prototype === expected.prototype &&\n           isEquivalent(actual, expected);\n  }\n}\n\nfunction isEquivalent(a, b, stack) {\n  return isArrayEquivalent(Object.keys(a).sort(),\n                           Object.keys(b).sort()) &&\n          Object.keys(a).every(function(key) {\n            return isDeepEqual(a[key], b[key], stack)\n          });\n}\n\nfunction isArrayEquivalent(a, b, stack) {\n  return isArray(a) && isArray(b) &&\n         a.every(function(value, index) {\n           return isDeepEqual(value, b[index]);\n         });\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "test/assert"
    }
  }, 
  {
    "pk": 34, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-\n * vim:set ts=2 sw=2 sts=2 et filetype=javascript\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Drew Willcoxon <adw@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cu,components} = require(\"chrome\");\nvar NetUtil = {};\nCu.import(\"resource://gre/modules/NetUtil.jsm\", NetUtil);\nNetUtil = NetUtil.NetUtil;\n\n// NetUtil.asyncCopy() uses this buffer length, and since we call it, for best\n// performance we use it, too.\nconst BUFFER_BYTE_LEN = 0x8000;\nconst PR_UINT32_MAX = 0xffffffff;\nconst DEFAULT_CHARSET = \"UTF-8\";\n\nexports.TextReader = TextReader;\nexports.TextWriter = TextWriter;\n\n/**\n * An input stream that reads text from a backing stream using a given text\n * encoding.\n *\n * @param inputStream\n *        The stream is backed by this nsIInputStream.  It must already be\n *        opened.\n * @param charset\n *        Text in inputStream is expected to be in this character encoding.  If\n *        not given, \"UTF-8\" is assumed.  See nsICharsetConverterManager.idl for\n *        documentation on how to determine other valid values for this.\n */\nfunction TextReader(inputStream, charset) {\n  const self = this;\n  charset = checkCharset(charset);\n\n  let stream = Cc[\"@mozilla.org/intl/converter-input-stream;1\"].\n               createInstance(Ci.nsIConverterInputStream);\n  stream.init(inputStream, charset, BUFFER_BYTE_LEN,\n              Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n  let manager = new StreamManager(this, stream);\n\n  /**\n   * Reads a string from the stream.  If the stream is closed, an exception is\n   * thrown.\n   *\n   * @param  numChars\n   *         The number of characters to read.  If not given, the remainder of\n   *         the stream is read.\n   * @return The string read.  If the stream is already at EOS, returns the\n   *         empty string.\n   */\n  this.read = function TextReader_read(numChars) {\n    manager.ensureOpened();\n\n    let readAll = false;\n    if (typeof(numChars) === \"number\")\n      numChars = Math.max(numChars, 0);\n    else\n      readAll = true;\n\n    let str = \"\";\n    let totalRead = 0;\n    let chunkRead = 1;\n\n    // Read in numChars or until EOS, whichever comes first.  Note that the\n    // units here are characters, not bytes.\n    while (true) {\n      let chunk = {};\n      let toRead = readAll ?\n                   PR_UINT32_MAX :\n                   Math.min(numChars - totalRead, PR_UINT32_MAX);\n      if (toRead <= 0 || chunkRead <= 0)\n        break;\n\n      // The converter stream reads in at most BUFFER_BYTE_LEN bytes in a call\n      // to readString, enough to fill its byte buffer.  chunkRead will be the\n      // number of characters encoded by the bytes in that buffer.\n      chunkRead = stream.readString(toRead, chunk);\n      str += chunk.value;\n      totalRead += chunkRead;\n    }\n\n    return str;\n  };\n}\n\n/**\n * A buffered output stream that writes text to a backing stream using a given\n * text encoding.\n *\n * @param outputStream\n *        The stream is backed by this nsIOutputStream.  It must already be\n *        opened.\n * @param charset\n *        Text will be written to outputStream using this character encoding.\n *        If not given, \"UTF-8\" is assumed.  See nsICharsetConverterManager.idl\n *        for documentation on how to determine other valid values for this.\n */\nfunction TextWriter(outputStream, charset) {\n  const self = this;\n  charset = checkCharset(charset);\n\n  let stream = outputStream;\n\n  // Buffer outputStream if it's not already.\n  let ioUtils = Cc[\"@mozilla.org/io-util;1\"].getService(Ci.nsIIOUtil);\n  if (!ioUtils.outputStreamIsBuffered(outputStream)) {\n    stream = Cc[\"@mozilla.org/network/buffered-output-stream;1\"].\n             createInstance(Ci.nsIBufferedOutputStream);\n    stream.init(outputStream, BUFFER_BYTE_LEN);\n  }\n\n  // I'd like to use nsIConverterOutputStream.  But NetUtil.asyncCopy(), which\n  // we use below in writeAsync(), naturally expects its sink to be an instance\n  // of nsIOutputStream, which nsIConverterOutputStream's only implementation is\n  // not.  So we use uconv and manually convert all strings before writing to\n  // outputStream.\n  let uconv = Cc[\"@mozilla.org/intl/scriptableunicodeconverter\"].\n              createInstance(Ci.nsIScriptableUnicodeConverter);\n  uconv.charset = charset;\n\n  let manager = new StreamManager(this, stream);\n\n  /**\n   * Flushes the backing stream's buffer.\n   */\n  this.flush = function TextWriter_flush() {\n    manager.ensureOpened();\n    stream.flush();\n  };\n\n  /**\n   * Writes a string to the stream.  If the stream is closed, an exception is\n   * thrown.\n   *\n   * @param str\n   *        The string to write.\n   */\n  this.write = function TextWriter_write(str) {\n    manager.ensureOpened();\n    let istream = uconv.convertToInputStream(str);\n    let len = istream.available();\n    while (len > 0) {\n      stream.writeFrom(istream, len);\n      len = istream.available();\n    }\n    istream.close();\n  };\n\n  /**\n   * Writes a string on a background thread.  After the write completes, the\n   * backing stream's buffer is flushed, and both the stream and the backing\n   * stream are closed, also on the background thread.  If the stream is already\n   * closed, an exception is thrown immediately.\n   *\n   * @param str\n   *        The string to write.\n   * @param callback\n   *        An optional function.  If given, it's called as callback(error) when\n   *        the write completes.  error is an Error object or undefined if there\n   *        was no error.  Inside callback, |this| is the stream object.\n   */\n  this.writeAsync = function TextWriter_writeAsync(str, callback) {\n    manager.ensureOpened();\n    let istream = uconv.convertToInputStream(str);\n    NetUtil.asyncCopy(istream, stream, function (result) {\n        let err = components.isSuccessCode(result) ? undefined :\n        new Error(\"An error occured while writing to the stream: \" + result);\n      if (err)\n        console.error(err);\n\n      // asyncCopy() closes its output (and input) stream.\n      manager.opened = false;\n\n      if (typeof(callback) === \"function\") {\n        try {\n          callback.call(self, err);\n        }\n        catch (exc) {\n          console.exception(exc);\n        }\n      }\n    });\n  };\n}\n\n// This manages the lifetime of stream, a TextReader or TextWriter.  It defines\n// closed and close() on stream and registers an unload listener that closes\n// rawStream if it's still opened.  It also provides ensureOpened(), which\n// throws an exception if the stream is closed.\nfunction StreamManager(stream, rawStream) {\n  const self = this;\n  this.rawStream = rawStream;\n  this.opened = true;\n\n  /**\n   * True iff the stream is closed.\n   */\n  stream.__defineGetter__(\"closed\", function stream_closed() {\n    return !self.opened;\n  });\n\n  /**\n   * Closes both the stream and its backing stream.  If the stream is already\n   * closed, an exception is thrown.  For TextWriters, this first flushes the\n   * backing stream's buffer.\n   */\n  stream.close = function stream_close() {\n    self.ensureOpened();\n    self.unload();\n  };\n\n  require(\"unload\").ensure(this);\n}\n\nStreamManager.prototype = {\n  ensureOpened: function StreamManager_ensureOpened() {\n    if (!this.opened)\n      throw new Error(\"The stream is closed and cannot be used.\");\n  },\n  unload: function StreamManager_unload() {\n    // TextWriter.writeAsync() causes rawStream to close and therefore sets\n    // opened to false, so check that we're still opened.\n    if (this.opened) {\n      // Calling close() on both an nsIUnicharInputStream and\n      // nsIBufferedOutputStream closes their backing streams.  It also forces\n      // nsIOutputStreams to flush first.\n      this.rawStream.close();\n      this.opened = false;\n    }\n  }\n};\n\nfunction checkCharset(charset) {\n  return typeof(charset) === \"string\" ? charset : DEFAULT_CHARSET;\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "text-streams"
    }
  }, 
  {
    "pk": 58, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *   Erik Vold <erikvvold@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\nvar xpcom = require(\"xpcom\");\n\nvar timerClass = Cc[\"@mozilla.org/timer;1\"];\nvar nextID = 1;\nvar timers = {};\n\nfunction TimerCallback(timerID, callback, params) {\n  this._callback = callback;\n  this._params = params;\n};\nTimerCallback.prototype = {\n  QueryInterface : xpcom.utils.generateQI([Ci.nsITimerCallback])\n};\n\nfunction TimeoutCallback(timerID, callback, params) {\n  memory.track(this);\n  TimerCallback.apply(this, arguments)\n  this._timerID = timerID;\n};\nTimeoutCallback.prototype = new TimerCallback();\nTimeoutCallback.prototype.notify = function notifyOnTimeout(timer) {\n  try {\n    delete timers[this._timerID];\n    this._callback.apply(null, this._params);\n  } catch (e) {\n    console.exception(e);\n  }\n};\n\nfunction IntervalCallback(timerID, callback, params) {\n  memory.track(this);\n  TimerCallback.apply(this, arguments)\n};\nIntervalCallback.prototype = new TimerCallback();\nIntervalCallback.prototype.notify = function notifyOnInterval() {\n  try {\n    this._callback.apply(null, this._params);\n  } catch (e) {\n    console.exception(e);\n  }\n};\n\n\nvar setTimeout = exports.setTimeout = function setTimeout(callback, delay) {\n  return makeTimer(\n    Ci.nsITimer.TYPE_ONE_SHOT,\n    callback,\n    TimeoutCallback,\n    delay,\n    Array.slice(arguments, 2));\n};\n\nvar clearTimeout = exports.clearTimeout = function clearTimeout(timerID) {\n  cancelTimer(timerID);\n};\n\nvar setInterval = exports.setInterval = function setInterval(callback, delay) {\n  return makeTimer(\n    Ci.nsITimer.TYPE_REPEATING_SLACK,\n    callback,\n    IntervalCallback,\n    delay,\n    Array.slice(arguments, 2));\n};\n\nvar clearInterval = exports.clearInterval = function clearInterval(timerID) {\n  cancelTimer(timerID);\n};\n\nfunction makeTimer(type, callback, callbackType, delay, params) {\n  var timer = timerClass.createInstance(Ci.nsITimer);\n\n  memory.track(timer, \"nsITimer\");\n\n  var timerID = nextID++;\n  timers[timerID] = timer;\n\n  timer.initWithCallback(\n    new callbackType(timerID, callback, params),\n    delay || 0,\n    type\n  );\n  return timerID;\n}\n\nfunction cancelTimer(timerID) {\n  var timer = timers[timerID];\n  if (timer) {\n    timer.cancel();\n    delete timers[timerID];\n  }\n}\n\nrequire(\"unload\").when(\n  function cancelAllPendingTimers() {\n    var timerIDs = [timerID for (timerID in timers)];\n    timerIDs.forEach(function(timerID) { cancelTimer(timerID); });\n  });\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "timer"
    }
  }, 
  {
    "pk": 65, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// This implementation is neither secure nor complete,\n// because timer functionality should be implemented\n// natively in-process by bug 568695.\n\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (this.chrome) {\n  var callbacks = {};\n  exports.setTimeout = function setTimeout(cb, ms) {\n    var id = chrome.call(\"setTimeout\", ms);\n    callbacks[id] = cb;\n    return id;\n  };\n\n  exports.clearTimeout = function clearTimeout(id) {\n    delete callbacks[id];\n    chrome.send(\"clearTimeout\", id);\n  };\n  \n  chrome.on(\"onTimeout\", function(name, id) {\n    var cb = callbacks[id];\n    delete callbacks[id];\n    if (cb)\n      cb(); // yay race conditions\n  });\n} else {\n  exports.register = function(addon) {\n    var timer = require(\"timer\");\n    addon.registerCall(\"setTimeout\", function(name, ms) {\n      var id = timer.setTimeout(function() {\n        addon.send(\"onTimeout\", id);\n      }, ms);\n      return id;\n    });\n    addon.on(\"clearTimeout\", function(name, id) {\n      timer.clearTimeout(id);\n    });\n  };\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "timer-e10s-adapter"
    }
  }, 
  {
    "pk": 76, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// This module just proxies to the low level equivalent \"timer\" in \"api-utils\".\nmodule.exports = require(\"timer\");\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "timers"
    }
  }, 
  {
    "pk": 15, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,components} = require(\"chrome\");\n\n// Undo the auto-parentification of URLs done in bug 418356.\nfunction deParentifyURL(url) {\n  return url ? url.split(\" -> \").slice(-1)[0] : url;\n}\n\n// TODO: We might want to move this function to url or some similar\n// module.\nfunction getLocalFile(path) {\n  var ios = Cc['@mozilla.org/network/io-service;1']\n            .getService(Ci.nsIIOService);\n  var channel = ios.newChannel(path, null, null);\n  var iStream = channel.open();\n  var siStream = Cc['@mozilla.org/scriptableinputstream;1']\n                 .createInstance(Ci.nsIScriptableInputStream);\n  siStream.init(iStream);\n  var data = new String();\n  data += siStream.read(-1);\n  siStream.close();\n  iStream.close();\n  return data;\n}\n\nfunction safeGetFileLine(path, line) {\n  try {\n    var scheme = require(\"url\").URL(path).scheme;\n    // TODO: There should be an easier, more accurate way to figure out\n    // what's the case here.\n    if (!(scheme == \"http\" || scheme == \"https\"))\n      return getLocalFile(path).split(\"\\n\")[line - 1];\n  } catch (e) {}\n  return null;\n}\n\nfunction errorStackToJSON(stack) {\n  var lines = stack.split(\"\\n\");\n\n  var frames = [];\n  lines.forEach(\n    function(line) {\n      if (!line)\n        return;\n      var atIndex = line.indexOf(\"@\");\n      var colonIndex = line.lastIndexOf(\":\");\n      var filename = deParentifyURL(line.slice(atIndex + 1, colonIndex));\n      var lineNo = parseInt(line.slice(colonIndex + 1));\n      var funcSig = line.slice(0, atIndex);\n      var funcName = funcSig.slice(0, funcSig.indexOf(\"(\"));\n      frames.unshift({filename: filename,\n                      funcName: funcName,\n                      lineNo: lineNo});\n    });\n\n  return frames;\n};\n\nfunction nsIStackFramesToJSON(frame) {\n  var stack = [];\n\n  while (frame) {\n    if (frame.filename) {\n      var filename = deParentifyURL(frame.filename);\n      stack.splice(0, 0, {filename: filename,\n                          lineNo: frame.lineNumber,\n                          funcName: frame.name});\n    }\n    frame = frame.caller;\n  }\n\n  return stack;\n};\n\nvar fromException = exports.fromException = function fromException(e) {\n  if (e instanceof Ci.nsIException)\n    return nsIStackFramesToJSON(e.location);\n  if (e.stack && e.stack.length)\n    return errorStackToJSON(e.stack);\n  if (e.fileName && typeof(e.lineNumber == \"number\"))\n    return [{filename: deParentifyURL(e.fileName),\n             lineNo: e.lineNumber,\n             funcName: null}];\n  return [];\n};\n\nvar get = exports.get = function get() {\n  return nsIStackFramesToJSON(components.stack.caller);\n};\n\nvar format = exports.format = function format(tbOrException) {\n  if (tbOrException === undefined) {\n    tbOrException = get();\n    tbOrException.splice(-1, 1);\n  }\n\n  var tb;\n  if (typeof(tbOrException) == \"object\" &&\n      tbOrException.constructor.name == \"Array\")\n    tb = tbOrException;\n  else\n    tb = fromException(tbOrException);\n\n  var lines = [\"Traceback (most recent call last):\"];\n\n  tb.forEach(\n    function(frame) {\n      if (!(frame.filename || frame.lineNo || frame.funcName))\n\treturn;\n      lines.push('  File \"' + frame.filename + '\", line ' +\n                 frame.lineNo + ', in ' + frame.funcName);\n      var sourceLine = safeGetFileLine(frame.filename, frame.lineNo);\n      if (sourceLine)\n        lines.push('    ' + sourceLine.trim());\n    });\n\n  return lines.join(\"\\n\");\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "traceback"
    }
  }, 
  {
    "pk": 5, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst {\n  compose: _compose,\n  override: _override,\n  resolve: _resolve,\n  trait: _trait,\n  //create: _create,\n  required,\n} = require('traits/core');\n\nconst defineProperties = Object.defineProperties,\n      freeze = Object.freeze,\n      create = Object.create;\n\n/**\n * Work around bug 608959 by defining the _create function here instead of\n * importing it from traits/core.  For docs on this function, see the create\n * function in that module.\n *\n * FIXME: remove this workaround in favor of importing the function once that\n * bug has been fixed.\n */\nfunction _create(proto, trait) {\n  let properties = {},\n      keys = Object.getOwnPropertyNames(trait);\n  for each(let key in keys) {\n    let descriptor = trait[key];\n    if (descriptor.required &&\n        !Object.prototype.hasOwnProperty.call(proto, key))\n      throw new Error('Missing required property: ' + key);\n    else if (descriptor.conflict)\n      throw new Error('Remaining conflicting property: ' + key);\n    else\n      properties[key] = descriptor;\n  }\n  return Object.create(proto, properties);\n}\n\n/**\n * Placeholder for `Trait.prototype`\n */\nlet TraitProto = Object.prototype;\n\nfunction Get(key) this[key]\nfunction Set(key, value) this[key] = value\n\n/**\n * Creates anonymous trait descriptor from the passed argument, unless argument\n * is a trait constructor. In later case trait's already existing properties\n * descriptor is returned.\n * This is module's internal function and is used as a gateway to a trait's\n * internal properties descriptor.\n * @param {Function} $\n *    Composed trait's constructor.\n * @returns {Object}\n *    Private trait property of the composition.\n */\nfunction TraitDescriptor(object)\n  (\n    'function' == typeof object &&\n    (object.prototype == TraitProto || object.prototype instanceof Trait)\n  ) ? object._trait(TraitDescriptor) : _trait(object)\n\nfunction Public(instance, trait) {\n  let result = {},\n      keys = Object.getOwnPropertyNames(trait);\n  for each (let key in keys) {\n    if ('_' === key.charAt(0) && '__iterator__' !== key )\n      continue;\n    let property = trait[key],\n        descriptor = {\n          configurable: property.configurable,\n          enumerable: property.enumerable\n        };\n    if (property.get)\n      descriptor.get = property.get.bind(instance);\n    if (property.set)\n      descriptor.set = property.set.bind(instance);\n    if ('value' in property) {\n      let value = property.value;\n      if ('function' === typeof value) {\n        descriptor.value = property.value.bind(instance);\n        descriptor.writable = property.writable;\n      } else {\n        descriptor.get = Get.bind(instance, key);\n        descriptor.set = Set.bind(instance, key);\n      }\n    }\n    result[key] = descriptor;\n  }\n  return result;\n}\n\n/**\n * This is private function that composes new trait with privates.\n */\nfunction Composition(trait) {\n  function Trait() {\n    let self = _create({}, trait);\n    self._public = create(Trait.prototype, Public(self, trait));\n    delete self._public.constructor;\n    if (Object === self.constructor)\n      self.constructor = Trait;\n    else\n      return self.constructor.apply(self, arguments) || self._public;\n    return self._public;\n  }\n  defineProperties(Trait, {\n    prototype: { value: freeze(create(TraitProto, {\n      constructor: { value: constructor, writable: true }\n    }))}, // writable is `true` to avoid getters in custom ES5\n    displayName: { value: (trait.constructor || constructor).name },\n    compose: { value: compose, enumerable: true },\n    override: { value: override, enumerable: true },\n    resolve: { value: resolve, enumerable: true },\n    required: { value: required, enumerable: true },\n    _trait: { value: function _trait(caller)\n        caller ===  TraitDescriptor ? trait : undefined\n    }\n  });\n  return freeze(Trait);\n}\n\n/**\n * Composes new trait out of itself and traits / property maps passed as an\n * arguments. If two or more traits / property maps have properties with the\n * same name, the new trait will contain a \"conflict\" property for that name.\n * This is a commutative and associative operation, and the order of its\n * arguments is not significant.\n * @params {Object|Function}\n *    List of Traits or property maps to create traits from.\n * @returns {Function}\n *    New trait containing the combined properties of all the traits.\n */\nfunction compose() {\n  let traits = Array.slice(arguments, 0);\n  traits.push(this);\n  return Composition(_compose.apply(null, traits.map(TraitDescriptor)));\n}\n\n/**\n * Composes a new trait with all of the combined properties of `this` and the\n * argument traits. In contrast to `compose`, `override` immediately resolves\n * all conflicts resulting from this composition by overriding the properties of\n * later traits. Trait priority is from left to right. I.e. the properties of\n * the leftmost trait are never overridden.\n * @params {Object} trait\n * @returns {Object}\n */\nfunction override() {\n  let traits = Array.slice(arguments, 0);\n  traits.push(this);\n  return Composition(_override.apply(null, traits.map(TraitDescriptor)));\n}\n\n/**\n * Composes new resolved trait, with all the same properties as this\n * trait, except that all properties whose name is an own property of\n * `resolutions` will be renamed to `resolutions[name]`. If it is\n * `resolutions[name]` is `null` value is changed into a required property\n * descriptor.\n */\nfunction resolve(resolutions)\n  Composition(_resolve(resolutions, TraitDescriptor(this)))\n\n/**\n * Base Trait, that all the traits are composed of.\n */\nconst Trait = Composition({\n  /**\n   * Internal property holding public API of this instance.\n   */\n  _public: { value: null, configurable: true, writable: true },\n  toString: { value: function() '[object ' + this.constructor.name + ']' }\n});\nTraitProto = Trait.prototype;\nexports.Trait = Trait;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "traits"
    }
  }, 
  {
    "pk": 63, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n// Design inspired by: http://www.traitsjs.org/\n\n// shortcuts\nconst getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      hasOwn = Object.prototype.hasOwnProperty,\n      _create = Object.create;\n/**\n * Compares two trait custom property descriptors if they are the same. If\n * both are `conflict` or all the properties of descriptor are equal returned\n * value will be `true`, otherwise it will be `false`.\n * @param {Object} desc1\n * @param {Object} desc2\n */\nfunction areSame(desc1, desc2) {\n  return (desc1.conflict && desc2.conflict) || (\n    desc1.get === desc2.get &&\n    desc1.set === desc2.set &&\n    desc1.value === desc2.value &&\n    desc1.enumerable === desc2.enumerable &&\n    desc1.required === desc2.required &&\n    desc1.conflict === desc2.conflict\n  );\n}\n\n/**\n * Converts array to an object whose own property names represent\n * values of array.\n * @param {String[]} names\n * @returns {Object}\n * @example\n *  Map(['foo', ...]) => { foo: true, ...}\n */\nfunction Map(names) {\n  let map = {};\n  for each (let name in names)\n    map[name] = true;\n  return map;\n}\n\n\nconst ERR_CONFLICT = 'Remaining conflicting property: ',\n      ERR_REQUIRED = 'Missing required property: ';\n/**\n * Constant singleton, representing placeholder for required properties.\n * @type {Object}\n */\nconst required = { toString: function()'<Trait.required>' };\nexports.required = required;\n\n/**\n * Generates custom **required** property descriptor. Descriptor contains\n * non-standard property `required` that is equal to `true`.\n * @param {String} name\n *    property name to generate descriptor for.\n * @returns {Object}\n *    custom property descriptor\n */\nfunction Required(name) {\n  function required() { throw new Error(ERR_REQUIRED + name) }\n  return {\n    get: required,\n    set: required,\n    required: true\n  };\n}\n\n/**\n * Generates custom **conflicting** property descriptor. Descriptor contains\n * non-standard property `conflict` that is equal to `true`.\n * @param {String} name\n *    property name to generate descriptor for.\n * @returns {Object}\n *    custom property descriptor\n */\nfunction Conflict(name) {\n  function conflict() { throw new Error(ERR_CONFLICT + name) }\n  return {\n    get: conflict,\n    set: conflict,\n    conflict: true\n  };\n}\n\n/**\n * Function generates custom properties descriptor of the `object`s own\n * properties. All the inherited properties are going to be ignored.\n * Properties with values matching `required` singleton will be marked as\n * 'required' properties.\n * @param {Object} object\n *    Set of properties to generate trait from.\n * @returns {Object}\n *    Properties descriptor of all of the `object`'s own properties.\n */\nfunction trait(properties) {\n  let result = {},\n      keys = getOwnPropertyNames(properties);\n for each (let key in keys) {\n   let descriptor = getOwnPropertyDescriptor(properties, key);\n   result[key] = (required === descriptor.value) ? Required(key) : descriptor;\n }\n return result;\n}\nexports.Trait = exports.trait = trait;\n\n/**\n * Composes new trait. If two or more traits have own properties with the\n * same name, the new trait will contain a 'conflict' property for that name.\n * 'compose' is a commutative and associative operation, and the order of its\n * arguments is not significant.\n *\n * @params {Object} trait\n *    Takes traits as an arguments\n * @returns {Object}\n *    New trait containing the combined own properties of all the traits.\n * @example\n *    var newTrait = compose(trait_1, trait_2, ..., trait_N);\n */\nfunction compose(trait1, trait2) {\n  let traits = Array.slice(arguments, 0),\n      result = {};\n  for each (let trait in traits) {\n    let keys = getOwnPropertyNames(trait);\n    for each (let key in keys) {\n      let descriptor = trait[key];\n      // if property already exists and it's not a requirement\n      if (hasOwn.call(result, key) && !result[key].required) {\n        if (descriptor.required)\n          continue;\n        if (!areSame(descriptor, result[key]))\n          result[key] = Conflict(key);\n      } else {\n        result[key] = descriptor;\n      }\n    }\n  }\n  return result;\n}\nexports.compose = compose;\n\n/**\n * Composes new trait with the same own properties as the original trait,\n * except that all property names appearing in the first argument are replaced\n * by 'required' property descriptors.\n * @param {String[]} keys\n *    Array of strings property names.\n * @param {Object} trait\n *    A trait some properties of which should be excluded.\n * @returns {Object}\n * @example\n *    var newTrait = exclude(['name', ...], trait)\n */\nfunction exclude(keys, trait) {\n  let exclusions = Map(keys),\n      result = {},\n      keys = getOwnPropertyNames(trait);\n  for each (let key in keys) {\n    if (!hasOwn.call(exclusions, key) || trait[key].required)\n      result[key] = trait[key];\n    else\n      result[key] = Required(key);\n  }\n  return result;\n}\n\n/**\n * Composes a new trait with all of the combined properties of the argument\n * traits. In contrast to `compose`, `override` immediately resolves all\n * conflicts resulting from this composition by overriding the properties of\n * later traits. Trait priority is from left to right. I.e. the properties of\n * the leftmost trait are never overridden.\n * @params {Object} trait\n * @returns {Object}\n * @examples\n *    // override is associative:\n *    override(t1,t2,t3)\n *    // is equivalent to\n *    override(t1, override(t2, t3))\n *    // or\n *    to override(override(t1, t2), t3)\n *\n *    // override is not commutative:\n *    override(t1,t2)\n *    // is not equivalent to\n *    override(t2,t1)\n */\nfunction override() {\n  let traits = Array.slice(arguments, 0),\n      result = {};\n  for each (let trait in traits) {\n    let keys = getOwnPropertyNames(trait);\n    for each(let key in keys) {\n      let descriptor = trait[key];\n      if (!hasOwn.call(result, key) || result[key].required)\n        result[key] = descriptor;\n    }\n  }\n  return result;\n}\nexports.override = override;\n\n/**\n * Composes a new trait with the same properties as the original trait, except\n * that all properties whose name is an own property of map will be renamed to\n * map[name], and a 'required' property for name will be added instead.\n * @param {Object} map\n *    An object whose own properties serve as a mapping from old names to new\n *    names.\n * @param {Object} trait\n *    A trait object\n * @returns {Object}\n * @example\n *    var newTrait = rename(map, trait);\n */\nfunction rename(map, trait) {\n  let result = {},\n      keys = getOwnPropertyNames(trait);\n  for each(let key in keys) {\n    // must be renamed & it's not requirement\n    if (hasOwn.call(map, key) && !trait[key].required) {\n      let alias = map[key];\n      if (hasOwn.call(result, alias) && !result[alias].required)\n        result[alias] = Conflict(alias);\n      else\n        result[alias] = trait[key];\n      if (!hasOwn.call(result, key))\n        result[key] = Required(key);\n    } else { // must not be renamed or its a requirement\n      // property is not in result trait yet\n      if (!hasOwn.call(result, key))\n        result[key] = trait[key];\n      // property is already in resulted trait & it's not requirement\n      else if (!trait[key].required)\n        result[key] = Conflict(key);\n    }\n  }\n  return result;\n}\n\n/**\n* Composes new resolved trait, with all the same properties as the original\n* trait, except that all properties whose name is an own property of\n* resolutions will be renamed to `resolutions[name]`. If it is\n* `resolutions[name]` is `null` value is changed into a required property\n* descriptor.\n* function can be implemented as `rename(map,exclude(exclusions, trait))`\n* where map is the subset of mappings from oldName to newName and exclusions\n* is an array of all the keys that map to `null`.\n* Note: it's important to **first** `exclude`, **then** `rename`, since\n* `exclude` and rename are not associative.\n* @param {Object} resolutions\n*   An object whose own properties serve as a mapping from old names to new\n*   names, or to `null` if the property should be excluded.\n* @param {Object} trait\n*   A trait object\n* @returns {Object}\n*   Resolved trait with the same own properties as the original trait.\n*/\nfunction resolve(resolutions, trait) {\n  let renames = {},\n      exclusions = [],\n      keys = getOwnPropertyNames(resolutions);\n  for each (let key in keys) {  // pre-process renamed and excluded properties\n    if (resolutions[key])       // old name -> new name\n      renames[key] = resolutions[key];\n    else                        // name -> undefined\n      exclusions.push(key);\n  }\n  return rename(renames, exclude(exclusions, trait));\n}\nexports.resolve = resolve;\n\n/**\n * `create` is like `Object.create`, except that it ensures that:\n *    - an exception is thrown if 'trait' still contains required properties\n *    - an exception is thrown if 'trait' still contains conflicting\n *      properties\n * @param {Object}\n *    prototype of the completed object\n * @param {Object} trait\n *    trait object to be turned into a complete object\n * @returns {Object}\n *    An object with all of the properties described by the trait.\n */\nfunction create(proto, trait) {\n  let properties = {},\n      keys = getOwnPropertyNames(trait);\n  for each(let key in keys) {\n    let descriptor = trait[key];\n    if (descriptor.required && !hasOwn.call(proto, key))\n      throw new Error(ERR_REQUIRED + key);\n    else if (descriptor.conflict)\n      throw new Error(ERR_CONFLICT + key);\n    else\n      properties[key] = descriptor;\n  }\n  return _create(proto, properties);\n}\nexports.create = create;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "traits/core"
    }
  }, 
  {
    "pk": 62, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:ts=2:sts=2:sw=2:\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\n/**\n * Returns `true` if `value` is `undefined`.\n * @examples\n *    var foo; isUndefined(foo); // true\n *    isUndefined(0); // false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\nexports.isUndefined = isUndefined;\n\n/**\n * Returns `true` if value is `null`.\n * @examples\n *    isNull(null); // true\n *    isNull(undefined); // false\n */\nfunction isNull(value) {\n  return value === null;\n}\nexports.isNull = isNull;\n\n/**\n * Returns `true` if value is a string.\n * @examples\n *    isString(\"moe\"); // true\n */\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nexports.isString = isString;\n\n/**\n * Returns `true` if `value` is a number.\n * @examples\n *    isNumber(8.4 * 5); // true\n */\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nexports.isNumber = isNumber;\n\n/**\n * Returns `true` if `value` is a `RegExp`.\n * @examples\n *    isRegExp(/moe/); // true\n */\nfunction isRegExp(value) {\n  return isObject(value) && instanceOf(value, RegExp);\n}\nexports.isRegExp = isRegExp;\n\n/**\n * Returns true if `value` is a `Date`.\n * @examples\n *    isDate(new Date()); // true\n */\nfunction isDate(value) {\n  return isObject(value) && instanceOf(value, Date);\n}\nexports.isDate = isDate;\n\n/**\n * Returns true if object is a Function.\n * @examples\n *    isFunction(function foo(){}) // true\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nexports.isFunction = isFunction;\n\n/**\n * Returns `true` if `value` is an object (please note that `null` is considered\n * to be an atom and not an object).\n * @examples\n *    isObject({}) // true\n *    isObject(null) // false\n */\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nexports.isObject = isObject;\n\n/**\n * Returns true if `value` is an Array.\n * @examples\n *    isArray([1, 2, 3])  // true\n *    isArray({ 0: 'foo', length: 1 }) // false\n */\nvar isArray = Array.isArray || function isArray(value) {\n  Object.prototype.toString.call(value) === \"[object Array]\";\n}\nexports.isArray = isArray;\n\n/**\n * Returns `true` if `value` is an Arguments object.\n * @examples\n *    (function(){ return isArguments(arguments); })(1, 2, 3); // true\n *    isArguments([1,2,3]); // false\n */\nfunction isArguments(value) {\n  Object.prototype.toString.call(value) === \"[object Arguments]\";\n}\nexports.isArguments = isArguments;\n\n/**\n * Returns true if it is a primitive `value`. (null, undefined, number,\n * boolean, string)\n * @examples\n *    isPrimitive(3) // true\n *    isPrimitive('foo') // true\n *    isPrimitive({ bar: 3 }) // false\n */\nfunction isPrimitive(value) {\n  return !isFunction(value) && !isObject(value);\n}\nexports.isPrimitive = isPrimitive;\n\n/**\n * Returns `true` if given `object` is flat (it is direct decedent of\n * `Object.prototype` or `null`).\n * @examples\n *    isFlat({}) // true\n *    isFlat(new Type()) // false\n */\nfunction isFlat(object) {\n  return isObject(object) && (isNull(Object.getPrototypeOf(object)) ||\n                              isNull(Object.getPrototypeOf(\n                                     Object.getPrototypeOf(object))));\n}\nexports.isFlat = isFlat;\n\n/**\n * Returns `true` if object contains no values.\n */\nfunction isEmpty(object) {\n  if (isObject(object)) {\n    for (var key in object)\n      return false;\n    return true;\n  }\n  return false;\n}\nexports.isEmpty = isEmpty;\n\n/**\n * Returns `true` if `value` is an array / flat object containing only atomic\n * values and other flat objects.\n */\nfunction isJSON(value, visited) {\n    // Adding value to array of visited values.\n    (visited || (visited = [])).push(value);\n            // If `value` is an atom return `true` cause it's valid JSON.\n    return  isPrimitive(value) ||\n            // If `value` is an array of JSON values that has not been visited\n            // yet.\n            (isArray(value) &&  value.every(function(element) {\n                                  return isJSON(element, visited);\n                                })) ||\n            // If `value` is a plain object containing properties with a JSON\n            // values it's a valid JSON.\n            (isFlat(value) && Object.keys(value).every(function(key) {\n                var $ = Object.getOwnPropertyDescriptor(value, key);\n                // Check every proprety of a plain object to verify that\n                // it's neither getter nor setter, but a JSON value, that\n                // has not been visited yet.\n                return  ((!isObject($.value) || !~visited.indexOf($.value)) &&\n                        !('get' in $) && !('set' in $) &&\n                        isJSON($.value, visited));\n            }));\n}\nexports.isJSON = function (value) {\n  return isJSON(value);\n};\n\n/**\n * Returns if `value` is an instance of a given `Type`. This is exactly same as\n * `value instanceof Type` with a difference that `Type` can be from a scope\n * that has a different top level object. (Like in case where `Type` is a\n * function from different iframe / jetpack module / sandbox).\n */\nfunction instanceOf(value, Type) {\n  var isConstructorNameSame;\n  var isConstructorSourceSame;\n\n  // If `instanceof` returned `true` we know result right away.\n  var isInstanceOf = value instanceof Type;\n\n  // If `instanceof` returned `false` we do ducktype check since `Type` may be\n  // from a different sandbox. If a constructor of the `value` or a constructor\n  // of the value's prototype has same name and source we assume that it's an\n  // instance of the Type.\n  if (!isInstanceOf && value) {\n    isConstructorNameSame = value.constructor.name === Type.name;\n    isConstructorSourceSame = String(value.constructor) == String(Type);\n    isInstanceOf = (isConstructorNameSame && isConstructorSourceSame) ||\n                    instanceOf(Object.getPrototypeOf(value), Type);\n  }\n  return isInstanceOf;\n}\nexports.instanceOf = instanceOf;\n\n/**\n * Function returns textual representation of a value passed to it. Function\n * takes additional `indent` argument that is used for indentation. Also\n * optional `limit` argument may be passed to limit amount of detail returned.\n * @param {Object} value\n * @param {String} [indent=\"    \"]\n * @param {Number} [limit]\n */\nfunction source(value, indent, limit, offset, visited) {\n  var result;\n  var names;\n  var nestingIndex;\n  var isCompact = !isUndefined(limit);\n\n  indent = indent || \"    \";\n  offset = (offset || \"\");\n  result = \"\";\n  visited = visited || [];\n\n  if (isUndefined(value)) {\n    result += \"undefined\";\n  }\n  else if (isNull(value)) {\n    result += \"null\";\n  }\n  else if (isString(value)) {\n    result += '\"' + value + '\"';\n  }\n  else if (isFunction(value)) {\n    value = String(value).split(\"\\n\");\n    if (isCompact && value.length > 2) {\n      value = value.splice(0, 2);\n      value.push(\"...}\");\n    }\n    result += value.join(\"\\n\" + offset);\n  }\n  else if (isArray(value)) {\n    if ((nestingIndex = (visited.indexOf(value) + 1))) {\n      result = \"#\" + nestingIndex + \"#\";\n    }\n    else {\n      visited.push(value);\n\n      if (isCompact)\n        value = value.slice(0, limit);\n\n      result += \"[\\n\";\n      result += value.map(function(value) {\n        return offset + indent + source(value, indent, limit, offset + indent,\n                                        visited);\n      }).join(\",\\n\");\n      result += isCompact && value.length > limit ?\n                \",\\n\" + offset + \"...]\" : \"\\n\" + offset + \"]\";\n    }\n  }\n  else if (isObject(value)) {\n    if ((nestingIndex = (visited.indexOf(value) + 1))) {\n      result = \"#\" + nestingIndex + \"#\"\n    }\n    else {\n      visited.push(value)\n\n      names = Object.keys(value);\n\n      result += \"{ // \" + value + \"\\n\";\n      result += (isCompact ? names.slice(0, limit) : names).map(function(name) {\n        var _limit = isCompact ? limit - 1 : limit;\n        var descriptor = Object.getOwnPropertyDescriptor(value, name);\n        var result = offset + indent + \"// \";\n        var accessor;\n        if (0 <= name.indexOf(\" \"))\n          name = '\"' + name + '\"';\n\n        if (descriptor.writable)\n          result += \"writable \";\n        if (descriptor.configurable)\n          result += \"configurable \";\n        if (descriptor.enumerable)\n          result += \"enumerable \";\n\n        result += \"\\n\";\n        if (\"value\" in descriptor) {\n          result += offset + indent + name + \": \";\n          result += source(descriptor.value, indent, _limit, indent + offset,\n                           visited);\n        }\n        else {\n\n          if (descriptor.get) {\n            result += offset + indent + \"get \" + name + \" \";\n            accessor = source(descriptor.get, indent, _limit, indent + offset,\n                              visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n\n          if (descriptor.set) {\n            result += offset + indent + \"set \" + name + \" \";\n            accessor = source(descriptor.set, indent, _limit, indent + offset,\n                              visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n        }\n        return result;\n      }).join(\",\\n\");\n\n      if (isCompact) {\n        if (names.length > limit && limit > 0) {\n          result += \",\\n\" + offset  + indent + \"//...\";\n        }\n      }\n      else {\n        if (names.length)\n          result += \",\";\n\n        result += \"\\n\" + offset + indent + '\"__proto__\": ';\n        result += source(Object.getPrototypeOf(value), indent, 0,\n                         offset + indent);\n      }\n\n      result += \"\\n\" + offset + \"}\";\n    }\n  }\n  else {\n    result += String(value);\n  }\n  return result;\n}\nexports.source = function (value, indentation, limit) {\n  return source(value, indentation, limit);\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "type"
    }
  }, 
  {
    "pk": 26, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:st=2:sts=2:sw=2:\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nvar timer = require(\"timer\");\n\nexports.findAndRunTests = function findAndRunTests(options) {\n  var TestFinder = require(\"unit-test-finder\").TestFinder;\n  var finder = new TestFinder({\n    dirs: options.dirs,\n    filter: options.filter,\n    testInProcess: options.testInProcess,\n    testOutOfProcess: options.testOutOfProcess\n  });\n  var runner = new TestRunner({fs: options.fs});\n  finder.findTests(\n    function (tests) {\n      runner.startMany({tests: tests,\n                        onDone: options.onDone});\n    });\n};\n\nvar TestRunner = exports.TestRunner = function TestRunner(options) {\n  if (options) {\n    this.fs = options.fs;\n  }\n  memory.track(this);\n  this.passed = 0;\n  this.failed = 0;\n  this.testRunSummary = [];\n};\n\nTestRunner.prototype = {\n  toString: function toString() \"[object TestRunner]\",\n\n  DEFAULT_PAUSE_TIMEOUT: 10000,\n  PAUSE_DELAY: 500,\n\n  _logTestFailed: function _logTestFailed(why) {\n    this.test.errors[why]++;\n    if (!this.testFailureLogged) {\n      console.error(\"TEST FAILED: \" + this.test.name + \" (\" + why + \")\");\n      this.testFailureLogged = true;\n    }\n  },\n\n  makeSandboxedLoader: function makeSandboxedLoader(options) {\n    if (!this.fs)\n      console.error(\"Hey, either you didn't pass .fs when building the\" +\n                    \" TestRunner, or you used 'new' when calling\" +\n                    \" test.makeSandboxedLoader. Don't do that.\");\n\n    if (!options)\n      options = {console: console};\n    options.fs = this.fs;\n\n    var Cuddlefish = require(\"cuddlefish\");\n\n    if (\"moduleOverrides\" in options) {\n      var moduleOverrides = options.moduleOverrides;\n      delete options.moduleOverrides;\n      function getModuleExports(basePath, module) {\n        if (module in moduleOverrides)\n          return moduleOverrides[module];\n        return null;\n      }\n      options.getModuleExports = getModuleExports;\n    }\n\n    return new Cuddlefish.Loader(options);\n  },\n\n  pass: function pass(message) {\n    console.info(\"pass:\", message);\n    this.passed++;\n    this.test.passed++;\n  },\n\n  fail: function fail(message) {\n    this._logTestFailed(\"failure\");\n    console.error(\"fail:\", message);\n    console.trace();\n    this.failed++;\n    this.test.failed++;\n  },\n\n  exception: function exception(e) {\n    this._logTestFailed(\"exception\");\n    console.exception(e);\n    this.failed++;\n    this.test.failed++;\n  },\n\n  assertMatches: function assertMatches(string, regexp, message) {\n    if (regexp.test(string)) {\n      if (!message)\n        message = uneval(string) + \" matches \" + uneval(regexp);\n      this.pass(message);\n    } else {\n      var no = uneval(string) + \" doesn't match \" + uneval(regexp);\n      if (!message)\n        message = no;\n      else\n        message = message + \" (\" + no + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertRaises: function assertRaises(func, predicate, message) {\n    try {\n      func();\n      if (message)\n        this.fail(message + \" (no exception thrown)\");\n      else\n        this.fail(\"function failed to throw exception\");\n    } catch (e) {\n      var errorMessage;\n      if (typeof(e) == \"string\")\n        errorMessage = e;\n      else\n        errorMessage = e.message;\n      if (typeof(predicate) == \"string\")\n        this.assertEqual(errorMessage, predicate, message);\n      else\n        this.assertMatches(errorMessage, predicate, message);\n    }\n  },\n\n  assert: function assert(a, message) {\n    if (!a) {\n      if (!message)\n        message = \"assertion failed, value is \" + a;\n      this.fail(message);\n    } else\n      this.pass(message || \"assertion successful\");\n  },\n\n  assertNotEqual: function assertNotEqual(a, b, message) {\n    if (a != b) {\n      if (!message)\n        message = \"a != b != \" + uneval(a);\n      this.pass(message);\n    } else {\n      var equality = uneval(a) + \" == \" + uneval(b);\n      if (!message)\n        message = equality;\n      else\n        message += \" (\" + equality + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertEqual: function assertEqual(a, b, message) {\n    if (a == b) {\n      if (!message)\n        message = \"a == b == \" + uneval(a);\n      this.pass(message);\n    } else {\n      var inequality = uneval(a) + \" != \" + uneval(b);\n      if (!message)\n        message = inequality;\n      else\n        message += \" (\" + inequality + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertNotStrictEqual: function assertNotStrictEqual(a, b, message) {\n    if (a !== b) {\n      if (!message)\n        message = \"a !== b !== \" + uneval(a);\n      this.pass(message);\n    } else {\n      var equality = uneval(a) + \" === \" + uneval(b);\n      if (!message)\n        message = equality;\n      else\n        message += \" (\" + equality + \")\";\n      this.fail(message);\n    }\n  },\n\n  assertStrictEqual: function assertStrictEqual(a, b, message) {\n    if (a === b) {\n      if (!message)\n        message = \"a === b === \" + uneval(a);\n      this.pass(message);\n    } else {\n      var inequality = uneval(a) + \" !== \" + uneval(b);\n      if (!message)\n        message = inequality;\n      else\n        message += \" (\" + inequality + \")\";\n      this.fail(message);\n    }\n  },\n\n  done: function done() {\n    if (!this.isDone) {\n      this.isDone = true;\n      if (this.waitTimeout !== null) {\n        timer.clearTimeout(this.waitTimeout);\n        this.waitTimeout = null;\n      }\n      if (this.test.passed == 0 && this.test.failed == 0) {\n        this._logTestFailed(\"empty test\");\n        this.failed++;\n        this.test.failed++;\n      }\n      \n      this.testRunSummary.push({\n        name: this.test.name,\n        passed: this.test.passed,\n        failed: this.test.failed,\n        errors: [error for (error in this.test.errors)].join(\", \")\n      });\n      \n      if (this.onDone !== null) {\n        var onDone = this.onDone;\n        var self = this;\n        this.onDone = null;\n        timer.setTimeout(function() { onDone(self); }, 0);\n      }\n    }\n  },\n  \n  // Set of assertion functions to wait for an assertion to become true\n  // These functions take the same arguments as the TestRunner.assert* methods.\n  waitUntil: function waitUntil() {\n    return this._waitUntil(this.assert, arguments);\n  },\n  \n  waitUntilNotEqual: function waitUntilNotEqual() {\n    return this._waitUntil(this.assertNotEqual, arguments);\n  },\n  \n  waitUntilEqual: function waitUntilEqual() {\n    return this._waitUntil(this.assertEqual, arguments);\n  },\n  \n  waitUntilMatches: function waitUntilMatches() {\n    return this._waitUntil(this.assertMatches, arguments);\n  },\n  \n  /**\n   * Internal function that waits for an assertion to become true.\n   * @param {Function} assertionMethod\n   *    Reference to a TestRunner assertion method like test.assert, \n   *    test.assertEqual, ...\n   * @param {Array} args\n   *    List of arguments to give to the previous assertion method. \n   *    All functions in this list are going to be called to retrieve current\n   *    assertion values.\n   */\n  _waitUntil: function waitUntil(assertionMethod, args) {\n    let count = 0;\n    let maxCount = this.DEFAULT_PAUSE_TIMEOUT / this.PAUSE_DELAY;\n    \n    let callback = null;\n    let finished = false;\n    \n    let test = this;\n    function loop() {\n      // Build a mockup object to fake TestRunner API and intercept calls to\n      // pass and fail methods, in order to retrieve nice error messages\n      // and assertion result\n      let mock = {\n        pass: function (msg) {\n          test.pass(msg);\n          if (callback)\n            callback();\n          finished = true;\n        },\n        fail: function (msg) {\n          if (++count > maxCount) {\n            test.fail(msg);\n            if (callback)\n              callback();\n            finished = true;\n            return;\n          }\n          timer.setTimeout(loop, test.PAUSE_DELAY);\n        }\n      };\n      \n      // Automatically call args closures in order to build arguments for \n      // assertion function\n      let appliedArgs = [];\n      for (let i = 0, l = args.length; i < l; i++) {\n        let a = args[i];\n        if (typeof a == \"function\") {\n          try {\n            a = a();\n          }\n          catch(e) {\n            mock.fail(\"Exception when calling asynchronous assertion: \" + e);\n          }\n        }\n        appliedArgs.push(a);\n      }\n      \n      // Finally call assertion function with current assertion values\n      assertionMethod.apply(mock, appliedArgs);\n    }\n    loop();\n    \n    // Return an object with `then` method, to offer a way to execute \n    // some code when the assertion passed or failed\n    return {\n      then: function (c) {\n        callback = c;\n        \n        // In case of immediate positive result, we need to execute callback\n        // immediately here:\n        if (finished)\n          callback();\n      }\n    };\n  },\n  \n  waitUntilDone: function waitUntilDone(ms) {\n    if (ms === undefined)\n      ms = this.DEFAULT_PAUSE_TIMEOUT;\n\n    var self = this;\n\n    function tiredOfWaiting() {\n      self._logTestFailed(\"timed out\");\n      self.failed++;\n      self.test.failed++;\n      self.done();\n    }\n\n    this.waitTimeout = timer.setTimeout(tiredOfWaiting, ms);\n  },\n\n  startMany: function startMany(options) {\n    function runNextTest(self) {\n      var test = options.tests.shift();\n      if (test)\n        self.start({test: test, onDone: runNextTest});\n      else\n        options.onDone(self);\n    }\n    runNextTest(this);\n  },\n\n  start: function start(options) {\n    this.test = options.test;\n    this.test.passed = 0;\n    this.test.failed = 0;\n    this.test.errors = {};\n\n    this.isDone = false;\n    this.onDone = options.onDone;\n    this.waitTimeout = null;\n    this.testFailureLogged = false;\n\n    try {\n      this.test.testFunction(this);\n    } catch (e) {\n      this.exception(e);\n    }\n    if (this.waitTimeout === null)\n      this.done();\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "unit-test"
    }
  }, 
  {
    "pk": 8, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n// We don't actually use chrome directly, but we do access the \n// filesystem and scan it to dynamically import modules, so\n// we put this here to tell the module loader to give us\n// permission to require() whatever we want.\nrequire(\"chrome\");\n\nvar file = require(\"file\");\n\nvar TestFinder = exports.TestFinder = function TestFinder(options) {\n  memory.track(this);\n  this.dirs = options.dirs || [];\n  this.filter = options.filter || function() { return true; };\n  this.testInProcess = options.testInProcess === false ? false : true;\n  this.testOutOfProcess = options.testOutOfProcess === true ? true : false;\n};\n\nTestFinder.prototype = {\n  _makeTest: function _makeTest(suite, name, test) {\n    function runTest(runner) {\n      console.info(\"executing '\" + suite + \".\" + name + \"'\");\n      test(runner);\n    }\n    return runTest;\n  },\n\n  findTests: function findTests(cb) {\n    var self = this;\n    var tests = [];\n    var filter;\n\n    if (typeof(this.filter) == \"string\") {\n      var filterRegex = new RegExp(self.filter);\n      filter = function(name) {\n        return filterRegex.test(name);\n      };\n    } else if (typeof(this.filter) == \"function\")\n      filter = this.filter;\n\n    this.dirs.forEach(\n      function(dir) {\n        var suites = [name.slice(0, -3)\n                      for each (name in file.list(dir))\n                      if (/^test-.*\\.js$/.test(name) && filter(name))];\n\n        suites.forEach(\n          function(suite) {\n            var module = require(suite);\n            if (self.testInProcess)\n              for (name in module)\n                  tests.push({\n                    testFunction: self._makeTest(suite, name, module[name]),\n                    name: suite + \".\" + name\n                  });\n          });\n      });\n\n    cb(tests);\n  }\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "unit-test-finder"
    }
  }, 
  {
    "pk": 7, 
    "model": "jetpack.module", 
    "fields": {
      "code": "// Parts of this module were taken from narwhal:\n//\n// http://narwhaljs.org\n\nvar observers = [];\nvar unloaders = [];\n\nvar when = exports.when = function when(observer) {\n  if (observers.indexOf(observer) != -1)\n    return;\n  observers.unshift(observer);\n};\n\nvar send = exports.send = function send(reason) {\n  observers.forEach(function (observer) {\n    observer(reason);\n  });\n};\n\nvar ensure = exports.ensure = function ensure(obj, destructorName) {\n  if (!destructorName)\n    destructorName = \"unload\";\n  if (!(destructorName in obj))\n    throw new Error(\"object has no '\" + destructorName + \"' property\");\n\n  let called = false;\n  let originalDestructor = obj[destructorName];\n\n  function unloadWrapper(reason) {\n    if (!called) {\n      called = true;\n      let index = unloaders.indexOf(unloadWrapper);\n      if (index == -1)\n        throw new Error(\"internal error: unloader not found\");\n      unloaders.splice(index, 1);\n      originalDestructor.call(obj, reason);\n      originalDestructor = null;\n      destructorName = null;\n      obj = null;\n    }\n  };\n\n  unloaders.push(unloadWrapper);\n\n  obj[destructorName] = unloadWrapper;\n};\n\nwhen(\n  function(reason) {\n    unloaders.slice().forEach(\n      function(unloadWrapper) {\n        unloadWrapper(reason);\n      });\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "unload"
    }
  }, 
  {
    "pk": 37, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cr} = require(\"chrome\");\n\nvar ios = Cc['@mozilla.org/network/io-service;1']\n          .getService(Ci.nsIIOService);\n\nvar resProt = ios.getProtocolHandler(\"resource\")\n              .QueryInterface(Ci.nsIResProtocolHandler);\n\nfunction newURI(uriStr, base) {\n  try {\n    let baseURI = base ? ios.newURI(base, null, null) : null;\n    return ios.newURI(uriStr, null, baseURI);\n  }\n  catch (e if e.result == Cr.NS_ERROR_MALFORMED_URI) {\n    throw new Error(\"malformed URI: \" + uriStr);\n  }\n  catch (e if (e.result == Cr.NS_ERROR_FAILURE ||\n               e.result == Cr.NS_ERROR_ILLEGAL_VALUE)) {\n    throw new Error(\"invalid URI: \" + uriStr);\n  }\n}\n\nfunction resolveResourceURI(uri) {\n  var resolved;\n  try {\n    resolved = resProt.resolveURI(uri);\n  } catch (e if e.result == Cr.NS_ERROR_NOT_AVAILABLE) {\n    throw new Error(\"resource does not exist: \" + uri.spec);\n  };\n  return resolved;\n}\n\nlet fromFilename = exports.fromFilename = function fromFilename(path) {\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  return ios.newFileURI(file).spec;\n};\n\nlet toFilename = exports.toFilename = function toFilename(url) {\n  var uri = newURI(url);\n  if (uri.scheme == \"resource\")\n    uri = newURI(resolveResourceURI(uri));\n  if (uri.scheme == \"chrome\") {\n    var channel = ios.newChannelFromURI(uri);\n    try {\n      channel = channel.QueryInterface(Ci.nsIFileChannel);\n      return channel.file.path;\n    } catch (e if e.result == Cr.NS_NOINTERFACE) {\n      throw new Error(\"chrome url isn't on filesystem: \" + url);\n    }\n  }\n  if (uri.scheme == \"file\") {\n    var file = uri.QueryInterface(Ci.nsIFileURL).file;\n    return file.path;\n  }\n  throw new Error(\"cannot map to filename: \" + url);\n};\n\nfunction URL(url, base) {\n  var uri = newURI(url, base);\n\n  var userPass = null;\n  try {\n    userPass = uri.userPass ? uri.userPass : null;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  var host = null;\n  try {\n    host = uri.host;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  var port = null;\n  try {\n    port = uri.port == -1 ? null : uri.port;\n  } catch (e if e.result == Cr.NS_ERROR_FAILURE) {}\n\n  this.__defineGetter__(\"scheme\", function() uri.scheme);\n  this.__defineGetter__(\"userPass\", function() userPass);\n  this.__defineGetter__(\"host\", function() host);\n  this.__defineGetter__(\"port\", function() port);\n  this.__defineGetter__(\"path\", function() uri.path);\n  this.toString = function URL_toString() uri.spec;\n};\nexports.URL = require(\"api-utils\").publicConstructor(URL);\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "url"
    }
  }, 
  {
    "pk": 66, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Add-on SDK.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *   Myk Melez <myk@mozilla.org>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (this.chrome) {\n  exports.toFilename   = function(spec) chrome.call(\"url:toFilename\", spec);\n  exports.fromFilename = function(spec) chrome.call(\"url:fromFilename\", spec);\n\n  let URL = exports.URL = function URL(spec, base) {\n    // We have to force the `spec` and `base` arguments, if defined, to be\n    // strings before sending them across the process boundary, since the\n    // boundary will drop their custom toString() methods if they are URL\n    // objects, and the other side depends on being able to convert them to\n    // strings.\n    let result = chrome.call(\"url:URL\",\n                             typeof spec == \"undefined\" ? spec : \"\" + spec,\n                             typeof base == \"undefined\" ? base : \"\" + base);\n\n    let { scheme, userPass, host, port, path } = result.url;\n\n    return Object.create(URL.prototype, {\n      scheme:   { value: scheme,    enumerable: true },\n      userPass: { value: userPass,  enumerable: true },\n      host:     { value: host,      enumerable: true },\n      port:     { value: port,      enumerable: true },\n      path:     { value: path,      enumerable: true },\n      toString: { value: function() chrome.call(\"url:toString\", result.handle) }\n    });\n  }\n}\nelse {\n  const { URL, toFilename, fromFilename } = require(\"url\");\n\n  exports.register = function register(addon) {\n    addon.registerCall(\"url:toFilename\", function(name, spec) toFilename(spec));\n\n    addon.registerCall(\"url:fromFilename\",\n                       function(name, spec) fromFilename(spec));\n\n    addon.registerCall(\"url:URL\", function(name, spec, base) {\n      let url = URL(spec, base);\n\n      // We create a handle to give the addon process access to the toString()\n      // method, which cannot traverse the process boundary but also can't be\n      // duplicated in the addon process because it accesses private information\n      // (the spec of the URL).  The handle doesn't need to be rooted, as it\n      // can be GCed as soon as all references to it are removed.\n      let handle = addon.createHandle();\n      handle.isRooted = false;\n      handle.url = url;\n\n      return { url: url, handle: handle };\n    });\n\n    addon.registerCall(\"url:toString\",\n                       function(name, handle) handle.url.toString());\n  }\n}\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "url-e10s-adapter"
    }
  }, 
  {
    "pk": 22, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Cc, Ci, Cu } = require(\"chrome\");\nconst IOService = Cc[\"@mozilla.org/network/io-service;1\"].\n  getService(Ci.nsIIOService);\nconst AppShellService = Cc[\"@mozilla.org/appshell/appShellService;1\"].\n  getService(Ci.nsIAppShellService);\n\nCu.import(\"resource://gre/modules/NetUtil.jsm\", this);\nconst FaviconService = Cc[\"@mozilla.org/browser/favicon-service;1\"].\n                          getService(Ci.nsIFaviconService);\n\nconst PNG_B64 = \"data:image/png;base64,\";\nconst DEF_FAVICON_URI = \"chrome://mozapps/skin/places/defaultFavicon.png\";\nlet   DEF_FAVICON = null;\n\n/**\n * Takes URI of the page and returns associated favicon URI.\n * If page under passed uri has no favicon then base64 encoded data URI of\n * default faveicon is returned.\n * @param {String} uri\n * @returns {String}\n */\nexports.getFaviconURIForLocation = function getFaviconURIForLocation(uri) {\n  let pageURI = NetUtil.newURI(uri);\n  try {\n    return FaviconService.getFaviconDataAsDataURL(\n                  FaviconService.getFaviconForPage(pageURI));\n  }\n  catch(e) {\n    if (!DEF_FAVICON) {\n      DEF_FAVICON = PNG_B64 +\n                    base64Encode(getChromeURIContent(DEF_FAVICON_URI));\n    }\n    return DEF_FAVICON;\n  }\n}\n\n/**\n * Takes chrome URI and returns content under that URI.\n * @param {String} chromeURI\n * @returns {String}\n */\nfunction getChromeURIContent(chromeURI) {\n  let channel = IOService.newChannel(chromeURI, null, null);\n  let input = channel.open();\n  let stream = Cc[\"@mozilla.org/binaryinputstream;1\"].\n                createInstance(Ci.nsIBinaryInputStream); \n  stream.setInputStream(input);\n  let content = stream.readBytes(input.available());\n  stream.close();\n  input.close();\n  return content;\n}\nexports.getChromeURIContent = getChromeURIContent;\n\n/**\n * Creates a base-64 encoded ASCII string from a string of binary data.\n */\nfunction base64Encode(data) AppShellService.hiddenDOMWindow.btoa(String(data));\nexports.base64Encode = base64Encode;\n\n/**\n * Decodes a string of data which has been encoded using base-64 encoding.\n */\nfunction base64Decode(data) AppShellService.hiddenDOMWindow.atob(String(data));\nexports.base64Decode = base64Decode;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "utils/data"
    }
  }, 
  {
    "pk": 24, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nvar { setTimeout } = require(\"timer\");\n\n/**\n * Takes a function and returns a wrapped one instead, calling which will call\n * original function in the next turn of event loop. This is basically utility\n * to do `setTimeout(function() { ... }, 0)`, with a difference that returned\n * function is reused, instead of creating a new one each time. This also allows\n * to use this functions as event listeners.\n */\nfunction Enqueued(callee) {\n  return function enqueued()\n    setTimeout(invoke, 0, callee, arguments, this);\n}\nexports.Enqueued = Enqueued;\n\n/**\n * Invokes `callee` by passing `params` as an arguments and `self` as `this`\n * pseudo-variable. Returns value that is returned by a callee.\n * @param {Function} callee\n *    Function to invoke.\n * @param {Array} params\n *    Arguments to invoke function with.\n * @param {Object} self\n *    Object to be passed as a `this` pseudo variable.\n */\nfunction invoke(callee, params, self) callee.apply(self, params);\nexports.invoke = invoke;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "utils/function"
    }
  }, 
  {
    "pk": 25, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { EventEmitter } = require('events');\nconst unload = require(\"unload\");\n\nconst Registry = EventEmitter.compose({\n  _registry: null,\n  _constructor: null,\n  constructor: function Registry(constructor) {\n    this._registry = [];\n    this._constructor = constructor;\n    this.on('error', this._onError = this._onError.bind(this));\n    unload.ensure(this, \"_destructor\");\n  },\n  _destructor: function _destructor() {\n    let _registry = this._registry.slice(0);\n    for each (instance in _registry)\n      this._emit('remove', instance);\n    this._registry.splice(0);\n  },\n  _onError: function _onError(e) {\n    if (!this._listeners('error').length)\n      console.error(e);\n  },\n  has: function has(instance) {\n    let _registry = this._registry;\n    return (\n      (0 <= _registry.indexOf(instance)) ||\n      (instance && instance._public && 0 <= _registry.indexOf(instance._public))\n    );\n  },\n  add: function add(instance) {\n    let { _constructor, _registry } = this; \n    if (!(instance instanceof _constructor))\n      instance = new _constructor(instance);\n    if (0 > _registry.indexOf(instance)) {\n      _registry.push(instance);\n      this._emit('add', instance);\n      return instance;\n    }\n  },\n  remove: function remove(instance) {\n    let _registry = this._registry;\n    let index = _registry.indexOf(instance)\n    if (0 <= index) {\n      this._emit('remove', instance);\n      _registry.splice(index, 1);\n    }\n  }\n});\nexports.Registry = Registry;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "utils/registry"
    }
  }, 
  {
    "pk": 23, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { Cc, Ci, Cu } = require(\"chrome\");\nconst AppShellService = Cc[\"@mozilla.org/appshell/appShellService;1\"].\n  getService(Ci.nsIAppShellService);\n\nconst NS = \"http://www.w3.org/1999/xhtml\";\nconst COLOR = \"rgb(255,255,255)\";\n\n/**\n * Creates canvas element with a thumbnail of the passed window.\n * @param {Window} window\n * @returns {Element}\n */\nfunction getThumbnailCanvasForWindow(window) {\n  let aspectRatio = 0.5625; // 16:9\n  let thumbnail = AppShellService.hiddenDOMWindow.document\n                    .createElementNS(NS, \"canvas\");\n  thumbnail.mozOpaque = true;\n  thumbnail.width = Math.ceil(window.screen.availWidth / 5.75);\n  thumbnail.height = Math.round(thumbnail.width * aspectRatio);\n  let ctx = thumbnail.getContext(\"2d\");\n  let snippetWidth = window.innerWidth * .6;\n  let scale = thumbnail.width / snippetWidth;\n  ctx.scale(scale, scale);\n  ctx.drawWindow(window, window.scrollX, window.scrollY, snippetWidth,\n                snippetWidth * aspectRatio, COLOR);\n  return thumbnail;\n}\nexports.getThumbnailCanvasForWindow = getThumbnailCanvasForWindow;\n\n/**\n * Creates Base64 encoded data URI of the thumbnail for the passed window.\n * @param {Window} window\n * @returns {String}\n */\nexports.getThumbnailURIForWindow = function getThumbnailURIForWindow(window) {\n  return getThumbnailCanvasForWindow(window).toDataURL()\n};\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "utils/thumbnail"
    }
  }, 
  {
    "pk": 84, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Dietrich Ayala <dietrich@mozilla.com> (Original Author)\n *   Drew Willcoxon <adw@mozilla.com>\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *   Alexandre Poirot <apoirot@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc, Ci} = require(\"chrome\");\n\n// Widget content types\nconst CONTENT_TYPE_URI    = 1;\nconst CONTENT_TYPE_HTML   = 2;\nconst CONTENT_TYPE_IMAGE  = 3;\n\nconst ERR_CONTENT = \"No content or contentURL property found. Widgets must \"\n                         + \"have one or the other.\",\n      ERR_LABEL = \"The widget must have a non-empty label property.\",\n      ERR_ID = \"You have to specify a unique value for the id property of \" +\n               \"your widget in order for the application to remember its \" +\n               \"position.\",\n      ERR_DESTROYED = \"The widget has been destroyed and can no longer be used.\";\n\n// Supported events, mapping from DOM event names to our event names\nconst EVENTS = {\n  \"click\": \"click\",\n  \"mouseover\": \"mouseover\",\n  \"mouseout\": \"mouseout\",\n};\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The widget module currently supports only Firefox.  In the future \",\n    \"it will support other applications. Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=560716 for more information.\"\n  ].join(\"\"));\n}\n\nconst { validateOptions } = require(\"api-utils\");\nconst panels = require(\"panel\");\nconst { EventEmitter, EventEmitterTrait } = require(\"events\");\nconst { Trait } = require(\"traits\");\nconst LightTrait = require('light-traits').Trait;\nconst { Loader, Symbiont } = require(\"content\");\nconst timer = require(\"timer\");\nconst { Cortex } = require('cortex');\nconst windowsAPI = require(\"windows\");\nconst unload = require(\"unload\");\n\n// Data types definition\nconst valid = {\n  number: { is: [\"null\", \"undefined\", \"number\"] },\n  string: { is: [\"null\", \"undefined\", \"string\"] },\n  id: {\n    is: [\"string\"],\n    ok: function (v) v.length > 0,\n    msg: ERR_ID,\n    readonly: true\n  },\n  label: {\n    is: [\"string\"],\n    ok: function (v) v.length > 0,\n    msg: ERR_LABEL\n  },\n  panel: {\n    is: [\"null\", \"undefined\", \"object\"],\n    ok: function(v) !v || v instanceof panels.Panel\n  },\n  width: {\n    is: [\"null\", \"undefined\", \"number\"],\n    map: function (v) {\n      if (null === v || undefined === v) v = 16;\n      return v;\n    },\n    defaultValue: 16\n  },\n};\n\n// Widgets attributes definition\nlet widgetAttributes = {\n  label: valid.label,\n  id: valid.id,\n  tooltip: valid.string,\n  width: valid.width,\n  content: valid.string,\n  panel: valid.panel\n};\n\n// Import data definitions from loader, but don't compose with it as Model\n// functions allow us to recreate easily all Loader code.\nlet loaderAttributes = require(\"content/loader\").validationAttributes;\nfor (let i in loaderAttributes)\n  widgetAttributes[i] = loaderAttributes[i];\n\nwidgetAttributes.contentURL.optional = true;\n\n// Widgets public events list, that are automatically binded in options object\nconst WIDGET_EVENTS = [\n  \"click\",\n  \"mouseover\",\n  \"mouseout\",\n  \"error\",\n  \"message\",\n  \"attach\"\n];\n\n// `Model` utility functions that help creating these various Widgets objects\nlet model = {\n\n  // Validate one attribute using api-utils.js:validateOptions function\n  _validate: function _validate(name, suspect, validation) {\n    let $1 = {};\n    $1[name] = suspect;\n    let $2 = {};\n    $2[name] = validation;\n    return validateOptions($1, $2)[name];\n  },\n\n  /**\n   * This method has two purposes:\n   * 1/ Validate and define, on a given object, a set of attribute\n   * 2/ Emit a \"change\" event on this object when an attribute is changed\n   *\n   * @params {Object} object\n   *    Object on which we can bind attributes on and watch for their changes.\n   *    This object must have an EventEmitter interface, or, at least `_emit`\n   *    method\n   * @params {Object} attrs\n   *    Dictionary of attributes definition following api-utils:validateOptions \n   *    scheme\n   * @params {Object} values\n   *    Dictionary of attributes default values\n   */\n  setAttributes: function setAttributes(object, attrs, values) {\n    let properties = {};\n    for (let name in attrs) {\n      let value = values[name];\n      let req = attrs[name];\n      \n      // Retrieve default value from typedef if the value is not defined\n      if ((typeof value == \"undefined\" || value == null) && req.defaultValue)\n        value = req.defaultValue;\n      \n      // Check for valid value if value is defined or mandatory\n      if (!req.optional || typeof value != \"undefined\")\n        value = model._validate(name, value, req);\n      \n      // In any case, define this property on `object`\n      let property = null;\n      if (req.readonly) {\n        property = {\n          value: value,\n          writable: false,\n          enumerable: true,\n          configurable: false\n        };\n      }\n      else {\n        property = model._createWritableProperty(name, value);\n      }\n      \n      properties[name] = property;\n    }\n    Object.defineProperties(object, properties);\n  },\n\n  // Generate ES5 property definition for a given attribute\n  _createWritableProperty: function _createWritableProperty(name, value) {\n    return {\n      get: function () {\n        return value;\n      },\n      set: function (newValue) {\n        value = newValue;\n        // The main goal of all this Model stuff is here:\n        // We want to forward all changes to some listeners\n        this._emit(\"change\", name, value);\n      },\n      enumerable: true,\n      configurable: false\n    };\n  },\n\n  /**\n   * Automagically register listeners in options dictionary\n   * by detecting listener attributes with name starting with `on`\n   *\n   * @params {Object} object\n   *    Target object that need to follow EventEmitter interface, or, at least, \n   *    having `on` method.\n   * @params {Array} events\n   *    List of events name to automatically bind.\n   * @params {Object} listeners\n   *    Dictionary of event listener functions to register.\n   */\n  setEvents: function setEvents(object, events, listeners) {\n    for (let i = 0, l = events.length; i < l; i++) {\n      let name = events[i];\n      let onName = \"on\" + name[0].toUpperCase() + name.substr(1);\n      if (!listeners[onName])\n        continue;\n      object.on(name, listeners[onName].bind(object));\n    }\n  }\n\n};\n\n\n/**\n * Main Widget class: entry point of the widget API\n *\n * Allow to control all widget across all existing windows with a single object.\n * Widget.getView allow to retrieve a WidgetView instance to control a widget\n * specific to one window.\n */\nconst WidgetTrait = LightTrait.compose(EventEmitterTrait, LightTrait({\n  \n  _initWidget: function _initWidget(options) {\n    model.setAttributes(this, widgetAttributes, options);\n    \n    browserManager.validate(this);\n    \n    // We must have at least content or contentURL defined\n    if (!(this.content || this.contentURL))\n      throw new Error(ERR_CONTENT);\n    \n    this._views = [];\n    \n    // Set tooltip to label value if we don't have tooltip defined\n    if (!this.tooltip)\n      this.tooltip = this.label;\n    \n    model.setEvents(this, WIDGET_EVENTS, options);\n    \n    this.on('change', this._onChange.bind(this));\n    \n    let self = this;\n    this._port = EventEmitterTrait.create({\n      emit: function () {\n        let args = arguments;\n        self._views.forEach(function(v) v.port.emit.apply(v.port, args));\n      }\n    });\n    // expose wrapped port, that exposes only public properties. \n    this._port._public = Cortex(this._port);\n    \n    // Register this widget to browser manager in order to create new widget on\n    // all new windows\n    browserManager.addItem(this);\n  },\n  \n  _onChange: function _onChange(name, value) {\n    // Set tooltip to label value if we don't have tooltip defined\n    if (name == 'tooltip' && !value) {\n      // we need to change tooltip again in order to change the value of the \n      // attribute itself\n      this.tooltip = this.label;\n      return;\n    }\n    \n    // Forward attributes changes to WidgetViews\n    if (['width', 'tooltip', 'content', 'contentURL'].indexOf(name) != -1) {\n      this._views.forEach(function(v) v[name] = value);\n    }\n  },\n\n  _onEvent: function _onEvent(type, eventData) {\n    this._emit(type, eventData);\n  },\n  \n  _createView: function _createView() {\n    // Create a new WidgetView instance\n    let view = WidgetView(this);\n    \n    // Keep a reference to it\n    this._views.push(view);\n    \n    // Emit an `attach` event with a WidgetView instance without private attrs\n    this._emit(\"attach\", view._public);\n    \n    return view;\n  },\n  \n  // a WidgetView instance is destroyed\n  _onViewDestroyed: function _onViewDestroyed(view) {\n    let idx = this._views.indexOf(view);\n    this._views.splice(idx, 1);\n  },\n  \n  /**\n   * Called on browser window closed, to destroy related WidgetViews\n   * @params {ChromeWindow} window\n   *         Window that has been closed\n   */\n  _onWindowClosed: function _onWindowClosed(window) {\n    for each (let view in this._views) {\n      if (view._isInChromeWindow(window)) {\n        view.destroy();\n        break;\n      }\n    }\n  },\n  \n  /**\n   * Get the WidgetView instance related to a BrowserWindow instance\n   * @params {BrowserWindow} window\n   *         BrowserWindow reference from \"windows\" module\n   */\n  getView: function getView(window) {\n    for each (let view in this._views) {\n      if (view._isInWindow(window)) {\n        return view._public;\n      }\n    }\n    return null;\n  },\n  \n  get port() this._port._public,\n  set port(v) {}, // Work around Cortex failure with getter without setter\n                  // See bug 653464\n  _port: null,\n  \n  postMessage: function postMessage(message) {\n    this._views.forEach(function(v) v.postMessage(message));\n  },\n\n  destroy: function destroy() {\n    if (this.panel)\n      this.panel.destroy();\n    \n    // Dispatch destroy calls to views\n    // we need to go backward as we remove items from this array in \n    // _onViewDestroyed\n    for (let i = this._views.length - 1; i >= 0; i--)\n      this._views[i].destroy();\n    \n    // Unregister widget to stop creating it over new windows\n    // and allow creation of new widget with same id\n    browserManager.removeItem(this);\n  }\n\n}));\n\n// Widget constructor\nconst Widget = function Widget(options) {\n  let w = WidgetTrait.create(Widget.prototype);\n  w._initWidget(options);\n  \n  // Return a Cortex of widget in order to hide private attributes like _onEvent\n  let _public = Cortex(w);\n  unload.ensure(_public, \"destroy\");\n  return _public;\n}\nexports.Widget = Widget;\n\n\n\n/**\n * WidgetView is an instance of a widget for a specific window.\n *\n * This is an external API that can be retrieved by calling Widget.getView or\n * by watching `attach` event on Widget.\n */\nconst WidgetViewTrait = LightTrait.compose(EventEmitterTrait, LightTrait({\n  \n  // Reference to the matching WidgetChrome\n  // set right after constructor call\n  _chrome: null,\n  \n  // Public interface of the WidgetView, passed in `attach` event or in\n  // Widget.getView\n  _public: null,\n  \n  _initWidgetView: function WidgetView__initWidgetView(baseWidget) {\n    this._baseWidget = baseWidget;\n    \n    model.setAttributes(this, widgetAttributes, baseWidget);\n    \n    this.on('change', this._onChange.bind(this));\n    \n    let self = this;\n    this._port = EventEmitterTrait.create({\n      emit: function () {\n        if (!self._chrome)\n          throw new Error(ERR_DESTROYED);\n        self._chrome.update(self._baseWidget, \"emit\", arguments);\n      }\n    });\n    // expose wrapped port, that exposes only public properties. \n    this._port._public = Cortex(this._port);\n    \n    this._public = Cortex(this);\n  },\n  \n  _onChange: function WidgetView__onChange(name, value) {\n    if (name == 'tooltip' && !value) {\n      this.tooltip = this.label;\n      return;\n    }\n    \n    // Forward attributes changes to WidgetChrome instance\n    if (['width', 'tooltip', 'content', 'contentURL'].indexOf(name) != -1) {\n      this._chrome.update(this._baseWidget, name, value);\n    }\n  },\n\n  _onEvent: function WidgetView__onEvent(type, eventData, domNode) {\n    // Dispatch event in view\n    this._emit(type, eventData);\n    \n    // And forward it to the main Widget object\n    if (\"click\" == type || type.indexOf(\"mouse\") == 0)\n      this._baseWidget._onEvent(type, this._public);\n    else\n      this._baseWidget._onEvent(type, eventData);\n\n    // Special case for click events: if the widget doesn't have a click\n    // handler, but it does have a panel, display the panel.\n    if (\"click\" == type && !this._listeners(\"click\").length && this.panel)\n      this.panel.show(domNode);\n  },\n  \n  _isInWindow: function WidgetView__isInWindow(window) {\n    return windowsAPI.BrowserWindow({\n      window: this._chrome.window\n    }) == window;\n  },\n  \n  _isInChromeWindow: function WidgetView__isInChromeWindow(window) {\n    return this._chrome.window == window;\n  },\n  \n  _onPortEvent: function WidgetView__onPortEvent(args) {\n    let port = this._port;\n    port._emit.apply(port, args);\n    let basePort = this._baseWidget._port;\n    basePort._emit.apply(basePort, args);\n  },\n  \n  get port() this._port._public,\n  set port(v) {}, // Work around Cortex failure with getter without setter\n                  // See bug 653464\n  _port: null,\n  \n  postMessage: function WidgetView_postMessage(message) {\n    if (!this._chrome)\n      throw new Error(ERR_DESTROYED);\n    this._chrome.update(this._baseWidget, \"postMessage\", message);\n  },\n\n  destroy: function WidgetView_destroy() {\n    this._chrome.destroy();\n    delete this._chrome;\n    this._baseWidget._onViewDestroyed(this);\n    this._emit(\"detach\");\n  }\n\n}));\n\nconst WidgetView = function WidgetView(baseWidget) {\n  let w = WidgetViewTrait.create(WidgetView.prototype);\n  w._initWidgetView(baseWidget);\n  return w;\n}\n\n\n\n/** \n * Keeps track of all browser windows.\n * Exposes methods for adding/removing widgets\n * across all open windows (and future ones).\n * Create a new instance of BrowserWindow per window.\n */\nlet browserManager = {\n  items: [],\n  windows: [],\n\n  // Registers the manager to listen for window openings and closings.  Note\n  // that calling this method can cause onTrack to be called immediately if\n  // there are open windows.\n  init: function () {\n    let windowTracker = new (require(\"window-utils\").WindowTracker)(this);\n    unload.ensure(windowTracker);\n  },\n\n  // Registers a window with the manager.  This is a WindowTracker callback.\n  onTrack: function browserManager_onTrack(window) {\n    if (this._isBrowserWindow(window)) {\n      let win = new BrowserWindow(window);\n      win.addItems(this.items);\n      this.windows.push(win);\n    }\n  },\n\n  // Unregisters a window from the manager.  It's told to undo all \n  // modifications.  This is a WindowTracker callback.  Note that when\n  // WindowTracker is unloaded, it calls onUntrack for every currently opened\n  // window.  The browserManager therefore doesn't need to specially handle\n  // unload itself, since unloading the browserManager means untracking all\n  // currently opened windows.\n  onUntrack: function browserManager_onUntrack(window) {\n    if (this._isBrowserWindow(window)) {\n      this.items.forEach(function(i) i._onWindowClosed(window));\n      for (let i = 0; i < this.windows.length; i++) {\n        if (this.windows[i].window == window) {\n          this.windows.splice(i, 1)[0];\n          return;\n        }\n      }\n      \n    }\n  },\n  \n  // Used to validate widget by browserManager before adding it,\n  // in order to check input very early in widget constructor\n  validate : function (item) {\n    let idx = this.items.indexOf(item);\n    if (idx > -1)\n      throw new Error(\"The widget \" + item + \" has already been added.\");\n    if (item.id) {\n      let sameId = this.items.filter(function(i) i.id == item.id);\n      if (sameId.length > 0)\n        throw new Error(\"This widget ID is already used: \" + item.id);\n    } else {\n      item.id = this.items.length;\n    }\n  },\n\n  // Registers an item with the manager. It's added to all currently registered \n  // windows, and when new windows are registered it will be added to them, too.\n  addItem: function browserManager_addItem(item) {\n    this.items.push(item);\n    this.windows.forEach(function (w) w.addItems([item]));\n  },\n\n  // Unregisters an item from the manager.  It's removed from all windows that \n  // are currently registered.\n  removeItem: function browserManager_removeItem(item) {\n    let idx = this.items.indexOf(item);\n    if (idx > -1)\n      this.items.splice(idx, 1);\n  },\n\n  _isBrowserWindow: function browserManager__isBrowserWindow(win) {\n    let winType = win.document.documentElement.getAttribute(\"windowtype\");\n    return winType === \"navigator:browser\";\n  }\n};\n\n\n\n/** \n * Keeps track of a single browser window.\n *\n * This is where the core of how a widget's content is added to a window lives.\n */\nfunction BrowserWindow(window) {\n  this.window = window;\n  this.doc = window.document;\n}\n\nBrowserWindow.prototype = {\n\n  // Adds an array of items to the window.\n  addItems: function BW_addItems(items) {\n    items.forEach(this._addItemToWindow, this);\n  },\n  \n  _addItemToWindow: function BW__addItemToWindow(baseWidget) {\n    // Create a WidgetView instance\n    let widget = baseWidget._createView();\n    \n    // Create a WidgetChrome instance\n    let item = new WidgetChrome({\n      widget: widget,\n      doc: this.doc,\n      window: this.window\n    });\n    \n    widget._chrome = item;\n      \n    this._insertNodeInToolbar(item.node);\n    \n    // We need to insert Widget DOM Node before finishing widget view creation\n    // (because fill creates an iframe and tries to access its docShell)\n    item.fill();\n  },\n  \n  _insertNodeInToolbar: function BW__insertNodeInToolbar(node) {\n    // Add to the customization palette\n    let toolbox = this.doc.getElementById(\"navigator-toolbox\");\n    let palette = toolbox.palette;\n    palette.appendChild(node);\n\n    // Search for widget toolbar by reading toolbar's currentset attribute\n    let container = null;\n    let toolbars = this.doc.getElementsByTagName(\"toolbar\");\n    let id = node.getAttribute(\"id\");\n    for (let i = 0, l = toolbars.length; i < l; i++) {\n      let toolbar = toolbars[i];\n      if (toolbar.getAttribute(\"currentset\").indexOf(id) == -1)\n        continue;\n      container = toolbar;\n    }\n    \n    // if widget isn't in any toolbar, add it to the addon-bar\n    // TODO: we may want some \"first-launch\" module to do this only on very \n    // first execution\n    if (!container) {\n      container = this.doc.getElementById(\"addon-bar\");\n      // TODO: find a way to make the following code work when we use \"cfx run\":\n      // http://mxr.mozilla.org/mozilla-central/source/browser/base/content/browser.js#8586\n      // until then, force display of addon bar directly from sdk code\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=627484\n      if (container.collapsed)\n        this.window.toggleAddonBar();\n    }\n    \n    // Now retrieve a reference to the next toolbar item\n    // by reading currentset attribute on the toolbar\n    let nextNode = null;\n    let currentSet = container.getAttribute(\"currentset\");\n    let ids = (currentSet == \"__empty\") ? [] : currentSet.split(\",\");\n    let idx = ids.indexOf(id);\n    if (idx != -1) {\n      for (let i = idx; i < ids.length; i++) {\n        nextNode = this.doc.getElementById(ids[i]);\n        if (nextNode)\n          break;\n      }\n    }\n    \n    // Finally insert our widget in the right toolbar and in the right position\n    container.insertItem(id, nextNode, null, false);\n    \n    // Update DOM in order to save position if we remove/readd the widget\n    container.setAttribute(\"currentset\", container.currentSet);\n    // Save DOM attribute in order to save position on new window opened\n    this.window.document.persist(container.id, \"currentset\");\n  }\n}\n\n\n/**\n * Final Widget class that handles chrome DOM Node:\n *  - create initial DOM nodes\n *  - receive instruction from WidgetView through update method and update DOM\n *  - watch for DOM events and forward them to WidgetView\n */\nfunction WidgetChrome(options) {\n  this.window = options.window;\n  this._doc = options.doc;\n  this._widget = options.widget;\n  this._symbiont = null; // set later\n  this.node = null; // set later\n  \n  this._createNode();\n}\n\n// Update a property of a widget.\nWidgetChrome.prototype.update = function WC_update(updatedItem, property, value) {\n  switch(property) {\n    case \"contentURL\":\n    case \"content\":\n      this.setContent();\n      break;\n    case \"width\":\n      this.node.style.minWidth = value + \"px\";\n      this.node.querySelector(\"iframe\").style.width = value + \"px\";\n      break;\n    case \"tooltip\":\n      this.node.setAttribute(\"tooltiptext\", value);\n      break;\n    case \"postMessage\":\n      this._symbiont.postMessage(value);\n      break;\n    case \"emit\":\n      let port = this._symbiont.port;\n      port.emit.apply(port, value);\n      break;\n  }\n}\n\n// Add a widget to this window.\nWidgetChrome.prototype._createNode = function WC__createNode() {\n  // XUL element container for widget\n  let node = this._doc.createElement(\"toolbaritem\");\n  let guid = require(\"xpcom\").makeUuid().toString();\n  \n  // Temporary work around require(\"self\") failing on unit-test execution ...\n  let jetpackID = \"testID\";\n  try {\n    jetpackID = require(\"self\").id;\n  } catch(e) {}\n  \n  // Compute an unique and stable widget id with jetpack id and widget.id\n  let id = \"widget:\" + jetpackID + \"-\" + this._widget.id;\n  node.setAttribute(\"id\", id);\n  node.setAttribute(\"label\", this._widget.label);\n  node.setAttribute(\"tooltiptext\", this._widget.tooltip);\n  node.setAttribute(\"align\", \"center\");\n\n  // TODO move into a stylesheet, configurable by consumers.\n  // Either widget.style, exposing the style object, or a URL\n  // (eg, can load local stylesheet file).\n  node.setAttribute(\"style\", [\n      \"overflow: hidden; margin: 1px 2px 1px 2px; padding: 0px;\",\n      \"min-height: 16px;\",\n  ].join(\"\"));\n\n  node.style.minWidth = this._widget.width + \"px\";\n  \n  this.node = node;\n}\n\n// Initial population of a widget's content.\nWidgetChrome.prototype.fill = function WC_fill() {\n  // Create element\n  var iframe = this._doc.createElement(\"iframe\");\n  iframe.setAttribute(\"type\", \"content\");\n  iframe.setAttribute(\"transparent\", \"transparent\");\n  iframe.style.overflow = \"hidden\";\n  iframe.style.height = \"16px\";\n  iframe.style.maxHeight = \"16px\";\n  iframe.style.width = this._widget.width + \"px\";\n  iframe.setAttribute(\"flex\", \"1\");\n  iframe.style.border = \"none\";\n  iframe.style.padding = \"0px\";\n  \n  // Do this early, because things like contentWindow are null\n  // until the node is attached to a document.\n  this.node.appendChild(iframe);\n\n  // add event handlers\n  this.addEventHandlers();\n\n  // set content\n  this.setContent();\n}\n\n// Get widget content type.\nWidgetChrome.prototype.getContentType = function WC_getContentType() {\n  if (this._widget.content)\n    return CONTENT_TYPE_HTML;\n  return (this._widget.contentURL && /\\.(jpg|gif|png|ico)$/.test(this._widget.contentURL))\n    ? CONTENT_TYPE_IMAGE : CONTENT_TYPE_URI;\n}\n\n// Set widget content.\nWidgetChrome.prototype.setContent = function WC_setContent() {\n  let type = this.getContentType();\n  let contentURL = null;\n\n  switch (type) {\n    case CONTENT_TYPE_HTML:\n      contentURL = \"data:text/html,\" + encodeURIComponent(this._widget.content);\n      break;\n    case CONTENT_TYPE_URI:\n      contentURL = this._widget.contentURL;\n      break;\n    case CONTENT_TYPE_IMAGE:\n      let imageURL = this._widget.contentURL;\n      contentURL = \"data:text/html,<html><body><img src='\" +\n                   encodeURI(imageURL) + \"'></body></html>\";\n      break;\n    default:\n      throw new Error(\"The widget's type cannot be determined.\");\n  }\n\n  let iframe = this.node.firstElementChild;\n\n  let self = this;\n  // Cleanup previously created symbiont (in case we are update content)\n  if (this._symbiont)\n    this._symbiont.destroy();\n  \n  this._symbiont = Trait.compose(Symbiont.resolve({\n    _onContentScriptEvent: \"_onContentScriptEvent-not-used\"\n  }), {\n    _onContentScriptEvent: function () {\n      // Redirect events to WidgetView\n      self._widget._onPortEvent(arguments);\n    }\n  })({\n    frame: iframe,\n    contentURL: contentURL,\n    contentScriptFile: this._widget.contentScriptFile,\n    contentScript: this._widget.contentScript,\n    contentScriptWhen: this._widget.contentScriptWhen,\n    allow: this._widget.allow,\n    onMessage: function(message) {\n      timer.setTimeout(function() {\n        self._widget._onEvent(\"message\", message);\n      }, 0);\n    }\n  });\n}\n\n// Detect if document consists of a single image.\nWidgetChrome._isImageDoc = function WC__isImageDoc(doc) {\n  return doc.body.childNodes.length == 1 &&\n         doc.body.firstElementChild &&\n         doc.body.firstElementChild.tagName == \"IMG\";\n}\n\n// Set up all supported events for a widget.\nWidgetChrome.prototype.addEventHandlers = function WC_addEventHandlers() {\n  let contentType = this.getContentType();\n\n  let self = this;\n  let listener = function(e) {\n    // Ignore event firings that target the iframe.\n    if (e.target == self.node.firstElementChild)\n      return;\n\n    // The widget only supports left-click for now,\n    // so ignore right-clicks.\n    if (e.type == \"click\" && e.button == 2)\n      return;\n\n    // Proxy event to the widget\n    timer.setTimeout(function() {\n      self._widget._onEvent(EVENTS[e.type], null, self.node);\n    }, 0);\n  };\n\n  this.eventListeners = {};\n  let iframe = this.node.firstElementChild;\n  for (let [type, method] in Iterator(EVENTS)) {\n    iframe.addEventListener(type, listener, true, true);\n\n    // Store listeners for later removal\n    this.eventListeners[type] = listener;\n  }\n  \n  // On document load, make modifications required for nice default\n  // presentation.\n  let self = this;\n  function loadListener(e) {\n    // Ignore event firings that target the iframe\n    if (e.target == iframe)\n      return;\n    // Ignore about:blank loads\n    if (e.type == \"load\" && e.target.location == \"about:blank\")\n      return;\n    \n    // We may have had an unload event before that cleaned up the symbiont\n    if (!self._symbiont)\n      self.setContent();\n    \n    let doc = e.target;\n    if (contentType == CONTENT_TYPE_IMAGE || WidgetChrome._isImageDoc(doc)) {\n      // Force image content to size.\n      // Add-on authors must size their images correctly.\n      doc.body.firstElementChild.style.width = self._widget.width + \"px\";\n      doc.body.firstElementChild.style.height = \"16px\";\n    }\n\n    // Allow all content to fill the box by default.\n    doc.body.style.margin = \"0\";\n  }\n  iframe.addEventListener(\"load\", loadListener, true);\n  this.eventListeners[\"load\"] = loadListener;\n  \n  // Register a listener to unload symbiont if the toolbaritem is moved\n  // on user toolbars customization\n  function unloadListener(e) {\n    if (e.target.location == \"about:blank\")\n      return;\n    self._symbiont.destroy();\n    self._symbiont = null;\n    // This may fail but not always, it depends on how the node is \n    // moved or removed\n    try {\n      self.setContent();\n    } catch(e) {}\n    \n  }\n  \n  iframe.addEventListener(\"unload\", unloadListener, true);\n  this.eventListeners[\"unload\"] = unloadListener;\n}\n\n// Remove and unregister the widget from everything\nWidgetChrome.prototype.destroy = function WC_destroy(removedItems) {\n  // remove event listeners\n  for (let [type, listener] in Iterator(this.eventListeners))\n    this.node.firstElementChild.removeEventListener(type, listener, true);\n  // remove dom node\n  this.node.parentNode.removeChild(this.node);\n  // cleanup symbiont\n  this._symbiont.destroy();\n  // cleanup itself\n  this.eventListeners = null;\n  this._widget = null;\n  this._symbiont = null;\n}\n\n// Init the browserManager only after setting prototypes and such above, because\n// it will cause browserManager.onTrack to be called immediately if there are\n// open windows.\nbrowserManager.init();\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "widget"
    }
  }, 
  {
    "pk": 12, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\nvar errors = require(\"errors\");\n\nvar gWindowWatcher = Cc[\"@mozilla.org/embedcomp/window-watcher;1\"]\n                     .getService(Ci.nsIWindowWatcher);\n\nconst { EventEmitter } = require('events'),\n      { Trait } = require('traits');\n\n/**\n * An iterator for XUL windows currently in the application.\n * \n * @return A generator that yields XUL windows exposing the\n *         nsIDOMWindow interface.\n */\nvar windowIterator = exports.windowIterator = function windowIterator() {\n  let winEnum = gWindowWatcher.getWindowEnumerator();\n  while (winEnum.hasMoreElements())\n    yield winEnum.getNext().QueryInterface(Ci.nsIDOMWindow);\n};\n\nvar WindowTracker = exports.WindowTracker = function WindowTracker(delegate) {\n  this.delegate = delegate;\n  this._loadingWindows = [];\n  for (window in windowIterator())\n    this._regWindow(window);\n  gWindowWatcher.registerNotification(this);\n  require(\"unload\").ensure(this);\n};\n\nWindowTracker.prototype = {\n  _regLoadingWindow: function _regLoadingWindow(window) {\n    this._loadingWindows.push(window);\n    window.addEventListener(\"load\", this, true);\n  },\n\n  _unregLoadingWindow: function _unregLoadingWindow(window) {\n    var index = this._loadingWindows.indexOf(window);\n\n    if (index != -1) {\n      this._loadingWindows.splice(index, 1);\n      window.removeEventListener(\"load\", this, true);\n    }\n  },\n\n  _regWindow: function _regWindow(window) {\n    if (window.document.readyState == \"complete\") {\n      this._unregLoadingWindow(window);\n      this.delegate.onTrack(window);\n    } else\n      this._regLoadingWindow(window);\n  },\n\n  _unregWindow: function _unregWindow(window) {\n    if (window.document.readyState == \"complete\")\n      this.delegate.onUntrack(window);\n    else\n      this._unregLoadingWindow(window);\n  },\n\n  unload: function unload() {\n    gWindowWatcher.unregisterNotification(this);\n    for (window in windowIterator())\n      this._unregWindow(window);\n  },\n\n  handleEvent: function handleEvent(event) {\n    if (event.type == \"load\" && event.target) {\n      var window = event.target.defaultView;\n      if (window)\n        this._regWindow(window);\n    }\n  },\n\n  observe: function observe(subject, topic, data) {\n    var window = subject.QueryInterface(Ci.nsIDOMWindow);\n    if (topic == \"domwindowopened\")\n      this._regWindow(window);\n    else\n      this._unregWindow(window);\n  }\n};\n\nerrors.catchAndLogProps(WindowTracker.prototype, [\"handleEvent\", \"observe\"]);\n\nconst WindowTrackerTrait = Trait.compose({\n  _onTrack: Trait.required,\n  _onUntrack: Trait.required,\n  constructor: function WindowTrackerTrait() {\n    new WindowTracker({\n      onTrack: this._onTrack.bind(this),\n      onUntrack: this._onUntrack.bind(this)\n    });\n  }\n});\nexports.WindowTrackerTrait = WindowTrackerTrait;\n\nvar gDocsToClose = [];\n\nfunction onDocUnload(event) {\n  var index = gDocsToClose.indexOf(event.target);\n  if (index == -1)\n    throw new Error(\"internal error: unloading document not found\");\n  var document = gDocsToClose.splice(index, 1)[0];\n  // Just in case, let's remove the event listener too.\n  document.defaultView.removeEventListener(\"unload\", onDocUnload, false);\n}\n\nonDocUnload = require(\"errors\").catchAndLog(onDocUnload);\n\nexports.closeOnUnload = function closeOnUnload(window) {\n  window.addEventListener(\"unload\", onDocUnload, false);\n  gDocsToClose.push(window.document);\n};\n\nexports.__defineGetter__(\"activeWindow\", function() {\n  return Cc[\"@mozilla.org/appshell/window-mediator;1\"]\n         .getService(Ci.nsIWindowMediator)\n         .getMostRecentWindow(null);\n});\nexports.__defineSetter__(\"activeWindow\", function(window) {\n  try {\n    window.focus();\n  }\n  catch (e) { }\n});\n\nexports.__defineGetter__(\"activeBrowserWindow\", function() {\n  return Cc[\"@mozilla.org/appshell/window-mediator;1\"]\n         .getService(Ci.nsIWindowMediator)\n         .getMostRecentWindow(\"navigator:browser\");\n});\n\n/**\n * Returns the ID of the window's current inner window.\n */\nexports.getInnerId = function getInnerId(window) {\n  return window.QueryInterface(Ci.nsIInterfaceRequestor).\n                getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;\n};\n\n/**\n * Returns the ID of the window's outer window.\n */\nexports.getOuterId = function getOuterId(window) {\n  return window.QueryInterface(Ci.nsIInterfaceRequestor).\n                getInterface(Ci.nsIDOMWindowUtils).outerWindowID;\n};\n\nexports.isBrowser = function isBrowser(window) {\n  return window.document.documentElement.getAttribute(\"windowtype\") ===\n         \"navigator:browser\";\n};\n\nrequire(\"unload\").when(\n  function() {\n    gDocsToClose.slice().forEach(\n      function(doc) { doc.defaultView.close(); });\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "window-utils"
    }
  }, 
  {
    "pk": 85, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Felipe Gomes <felipc@gmail.com> (Original author)\n *   Irakli Gozalishvili <gozala@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nif (!require(\"xul-app\").is(\"Firefox\")) {\n  throw new Error([\n    \"The windows module currently supports only Firefox. In the future\",\n    \" we would like it to support other applications, however.  Please see \",\n    \"https://bugzilla.mozilla.org/show_bug.cgi?id=571449 for more information.\"\n  ].join(\"\"));\n}\n\nconst { Cc, Ci } = require('chrome'),\n      { Trait } = require('traits'),\n      { List } = require('list'),\n      { EventEmitter } = require('events'),\n      { WindowTabs, WindowTabTracker } = require('windows/tabs'),\n      { WindowDom } = require('windows/dom'),\n      { WindowLoader } = require('windows/loader'),\n      { WindowTrackerTrait } = require('window-utils'),\n      { Options } = require('tabs/tab'),\n      // { Sidebars } = require('window/sidebars');\n      { utils } = require('xpcom'),\n      apiUtils = require('api-utils'),\n      unload = require('unload'),\n\n      WM = Cc['@mozilla.org/appshell/window-mediator;1'].\n        getService(Ci.nsIWindowMediator),\n\n      BROWSER = 'navigator:browser';\n\n/**\n * Window trait composes safe wrappers for browser window that are E10S\n * compatible.\n */\nconst BrowserWindowTrait = Trait.compose(\n  EventEmitter,\n  WindowDom.resolve({ close: '_close' }),\n  WindowTabs,\n  WindowTabTracker,\n  WindowLoader,\n  /* WindowSidebars, */\n  Trait.compose({\n    _emit: Trait.required,\n    _close: Trait.required,\n    _load: Trait.required,\n    /**\n     * Constructor returns wrapper of the specified chrome window.\n     * @param {nsIWindow} window\n     */\n    constructor: function BrowserWindow(options) {\n      // Register this window ASAP, in order to avoid loop that would try\n      // to create this window instance over and over (see bug 648244)\n      windows.push(this);\n      \n      // make sure we don't have unhandled errors\n      this.on('error', console.exception.bind(console));\n\n      if ('onOpen' in options)\n        this.on('open', options.onOpen);\n      if ('onClose' in options)\n        this.on('close', options.onClose);\n      if ('window' in options)\n        this._window = options.window;\n      if ('tabs' in options) {\n        this._tabOptions = Array.isArray(options.tabs) ?\n                           options.tabs.map(Options) :\n                           [ Options(options.tabs) ];\n      }\n      else if ('url' in options) {\n        this._tabOptions = [ Options(options.url) ];\n      }\n      this._load();\n      return this;\n    },\n    _tabOptions: [],\n    _onLoad: function() {\n      try {\n        this._initWindowTabTracker();\n      } catch(e) {\n        this._emit('error', e)\n      }\n      this._emitOnObject(browserWindows, 'open', this._public);\n    },\n    _onUnload: function() {\n      this._destroyWindowTabTracker();\n      this._emitOnObject(browserWindows, 'close', this._public);\n      this._window = null;\n      // Removing reference from the windows array.\n      windows.splice(windows.indexOf(this), 1);\n      this._removeAllListeners('close');\n      this._removeAllListeners('open');\n      this._removeAllListeners('ready');\n    },\n    close: function close(callback) {\n      // maybe we should deprecate this with message ?\n      if (callback) this.on('close', callback);\n      return this._close();\n    }\n  })\n);\n/**\n * Wrapper for `BrowserWindowTrait`. Creates new instance if wrapper for\n * window doesn't exists yet. If wrapper already exists then returns it\n * instead.\n * @params {Object} options\n *    Options that are passed to the the `BrowserWindowTrait`\n * @returns {BrowserWindow}\n * @see BrowserWindowTrait\n */\nfunction BrowserWindow(options) {\n  let chromeWindow = options.window;\n  for each (let window in windows) {\n    if (chromeWindow == window._window)\n      return window._public\n  }\n  let window = BrowserWindowTrait(options);\n  return window._public;\n}\n// to have proper `instanceof` behavior will go away when #596248 is fixed.\nBrowserWindow.prototype = BrowserWindowTrait.prototype;\nexports.BrowserWindow = BrowserWindow\nconst windows = [];\n/**\n * `BrowserWindows` trait is composed out of `List` trait and it represents\n * \"live\" list of currently open browser windows. Instance mutates itself\n * whenever new browser window gets opened / closed.\n */\n// Very stupid to resolve all `toStrings` but this will be fixed by #596248\nconst browserWindows = Trait.resolve({ toString: null }).compose(\n  List.resolve({ constructor: '_initList' }),\n  EventEmitter.resolve({ toString: null }),\n  WindowTrackerTrait.resolve({ constructor: '_initTracker', toString: null }),\n  Trait.compose({\n    _emit: Trait.required,\n    _add: Trait.required,\n    _remove: Trait.required,\n\n    // public API\n\n    /**\n     * Constructor creates instance of `Windows` that represents live list of open\n     * windows.\n     */\n    constructor: function BrowserWindows() {\n      this._trackedWindows = [];\n      this._initList();\n      this._initTracker();\n      unload.ensure(this, \"_destructor\");\n    },\n    _destructor: function _destructor() {\n      this._removeAllListeners('open');\n      this._removeAllListeners('close');\n    },\n    /**\n     * This property represents currently active window.\n     * Property is non-enumerable, in order to preserve array like enumeration.\n     * @type {Window|null}\n     */\n    get activeWindow() {\n      let window = WM.getMostRecentWindow(BROWSER);\n      return this._isBrowser(window) ? BrowserWindow({ window: window }) : null;\n    },\n    open: function open(options) {\n      if (typeof options === \"string\")\n        // `tabs` option is under review and may be removed.\n        options = { tabs: [Options(options)] };\n      return BrowserWindow(options);\n    },\n    /**\n     * Returns true if specified window is a browser window.\n     * @param {nsIWindow} window\n     * @returns {Boolean}\n     */\n    _isBrowser: function _isBrowser(window)\n      BROWSER === window.document.documentElement.getAttribute(\"windowtype\")\n    ,\n     /**\n      * Internal listener which is called whenever new window gets open.\n      * Creates wrapper and adds to this list.\n      * @param {nsIWindow} chromeWindow\n      */\n    _onTrack: function _onTrack(chromeWindow) {\n      if (!this._isBrowser(chromeWindow)) return;\n      let window = BrowserWindow({ window: chromeWindow });\n      this._add(window);\n      this._emit('open', window);\n    },\n    /**\n     * Internal listener which is called whenever window gets closed.\n     * Cleans up references and removes wrapper from this list.\n     * @param {nsIWindow} window\n     */\n    _onUntrack: function _onUntrack(chromeWindow) {\n      if (!this._isBrowser(chromeWindow)) return;\n      let window = BrowserWindow({ window: chromeWindow });\n      // `_onUnload` method of the `BrowserWindow` will remove `chromeWindow`\n      // from the `windows` array.\n      this._remove(window);\n      this._emit('close', window);\n    }\n  }).resolve({ toString: null })\n)();\nexports.browserWindows = browserWindows;\n\n", 
      "revisions": [
        8, 
        7, 
        6, 
        5, 
        4
      ], 
      "author": 1, 
      "filename": "windows"
    }
  }, 
  {
    "pk": 48, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n'use strict';\n\nconst { Trait } = require('traits');\n\nconst WindowDom = Trait.compose({\n  _window: Trait.required,\n  get title() {\n    let window = this._window;\n    return window && window.document ? window.document.title : null\n  },\n  close: function close() {\n    let window = this._window;\n    if (window) window.close();\n    return this._public;\n  },\n  activate: function activate() {\n    let window = this._window;\n    if (window) window.focus();\n    return this._public;\n  }\n});\nexports.WindowDom = WindowDom;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "windows/dom"
    }
  }, 
  {
    "pk": 50, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Cc, Ci } = require('chrome'),\n      { setTimeout } = require(\"timer\"),\n      { Trait } = require('traits'),\n\n      WM = Cc['@mozilla.org/appshell/window-mediator;1'].\n        getService(Ci.nsIWindowMediator),\n\n      URI_BROWSER = 'chrome://browser/content/browser.xul',\n      NAME = '_blank',\n      FEATURES = 'chrome,all,dialog=no',\n      PARAMS = [ URI_BROWSER, NAME, FEATURES ],\n      ON_LOAD = 'load',\n      ON_UNLOAD = 'unload',\n      STATE_LOADED = 'complete',\n      BROWSER = 'navigator:browser';\n\n/**\n * Trait provides private `_window` property and requires `_onLoad` property\n * that will be called when `_window` is loaded. If `_window` property value\n * is changed with already loaded window `_onLoad` still will be called.\n */\nconst WindowLoader = Trait.compose({\n  /**\n   * Internal listener that is called when window is loaded.\n   * Please keep in mind that this trait will not handle exceptions that may\n   * be thrown by this method so method itself should take care of\n   * handling them.\n   * @param {nsIWindow} window\n   */\n  _onLoad: Trait.required,\n  _tabOptions: Trait.required,\n  /**\n   * Internal listener that is called when `_window`'s DOM 'unload' event\n   * is dispatched. Please note that this trait will not handle exceptions that\n   * may be thrown by this method so method itself should take care of\n   * handling them.\n   */\n  _onUnload: Trait.required,\n  _load: function _load() {\n    if (this.__window) return;\n    let params = PARAMS.slice()\n    params.push(this._tabOptions.map(function(options) options.url).join(\"|\"))\n    let browser =  WM.getMostRecentWindow(BROWSER);\n    this._window = browser.openDialog.apply(browser, params);\n  },\n  /**\n   * Private window who's load event is being tracked. Once window is loaded\n   * `_onLoad` is called.\n   * @type {nsIWindow}\n   */\n  get _window() this.__window,\n  set _window(window) {\n    let _window = this.__window;\n    if (!window) window = null;\n    if (window == _window) return;\n    if (_window) {\n      _window.removeEventListener(ON_UNLOAD, this.__unloadListener, false);\n      _window.removeEventListener(ON_LOAD, this.__loadListener, false);\n    }\n    if (!window) return;\n    window.addEventListener(\n      ON_UNLOAD,\n      this.__unloadListener ||\n        (this.__unloadListener = this._unloadListener.bind(this))\n      ,\n      false\n    );\n    this.__window = window;\n    // If window is not loaded yet setting up a listener.\n    if (STATE_LOADED != window.document.readyState) {\n      window.addEventListener(\n        ON_LOAD,\n        this.__loadListener ||\n          (this.__loadListener = this._loadListener.bind(this))\n        ,\n        false\n      );\n    }\n    else { // If window is loaded calling listener next turn of event loop.\n      this._onLoad(window)\n    }\n    return window;\n  },\n  __window: null,\n  /**\n   * Internal method used for listening 'load' event on the `_window`.\n   * Method takes care of removing itself from 'load' event listeners once\n   * event is being handled.\n   */\n  _loadListener: function _loadListener(event) {\n    let window = this._window;\n    if (!event.target || event.target.defaultView != window) return;\n    window.removeEventListener(ON_LOAD, this.__loadListener, false);\n    this._onLoad(window);\n  },\n  __loadListener: null,\n  /**\n   * Internal method used for listening 'unload' event on the `_window`.\n   * Method takes care of removing itself from 'unload' event listeners once\n   * event is being handled.\n   */\n  _unloadListener: function _unloadListener(event) {\n    let window = this._window;\n    if (!event.target\n      || event.target.defaultView != window\n      || STATE_LOADED != window.document.readyState\n    ) return;\n    window.removeEventListener(ON_UNLOAD, this.__unloadListener, false);\n    this._onUnload(window);\n  },\n  __unloadListener: null\n});\nexports.WindowLoader = WindowLoader;\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "windows/loader"
    }
  }, 
  {
    "pk": 49, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* vim:set ts=2 sw=2 sts=2 et: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n\"use strict\";\n\nconst { EventEmitterTrait: EventEmitter } = require(\"../events\");\nconst { WindowTracker, windowIterator } = require(\"../window-utils\");\nconst { DOMEventAssembler } = require(\"../events/assembler\");\nconst { Trait } = require(\"../light-traits\");\n\n// Event emitter objects used to register listeners and emit events on them\n// when they occur.\nconst observer = Trait.compose(DOMEventAssembler, EventEmitter).create({\n  /**\n   * Method is implemented by `EventEmitter` and is used just for emitting\n   * events on registered listeners.\n   */\n  _emit: Trait.required,\n  /**\n   * Events that are supported and emitted by the module.\n   */\n  supportedEventsTypes: [ \"activate\", \"deactivate\" ],\n  /**\n   * Function handles all the supported events on all the windows that are\n   * observed. Method is used to proxy events to the listeners registered on\n   * this event emitter.\n   * @param {Event} event\n   *    Keyboard event being emitted.\n   */\n  handleEvent: function handleEvent(event) {\n    this._emit(event.type, event.target, event);\n  }\n});\n\n// Using `WindowTracker` to track window events.\nnew WindowTracker({\n  onTrack: function onTrack(chromeWindow) {\n    observer._emit(\"open\", chromeWindow);\n    observer.observe(chromeWindow);\n  },\n  onUntrack: function onUntrack(chromeWindow) {\n    observer._emit(\"close\", chromeWindow);\n    observer.ignore(chromeWindow);\n  }\n});\n\n// Making observer aware of already opened windows.\nfor each (let window in windowIterator())\n  observer.observe(window);\n\n// Getting rid of all listeners when add-on is unloaded.\nrequire(\"unload\").when(function() { observer._events = {} });\n\nmodule.exports = observer;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "windows/observer"
    }
  }, 
  {
    "pk": 47, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is\n * the Mozilla Foundation.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Irakli Gozalishvili <gozala@mozilla.com> (Original Author)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\"use strict\";\n\nconst { Trait } = require(\"traits\");\nconst { List } = require(\"list\");\nconst { Tab, Options } = require(\"tabs/tab\");\nconst { EventEmitter } = require(\"events\");\nconst { EVENTS } = require(\"tabs/events\");\nconst { getOwnerWindow, getActiveTab, getTabs,\n        openTab, activateTab } = require(\"../tabs/utils\");\nconst tabsObserver = require(\"../tabs/observer\");\n\nconst TAB_BROWSER = \"tabbrowser\";\n\n/**\n * This is a trait that is used in composition of window wrapper. Trait tracks\n * tab related events of the wrapped window in order to keep truck of open\n * tabs and maintain their wrappers. Every new tab is gets wrapped and jetpack\n * type event is emitted.\n */\nconst WindowTabTracker = Trait.compose({\n  /**\n   * Chrome window whose tabs are tracked.\n   */\n  _window: Trait.required,\n  /**\n   * Function used to emit events.\n   */\n  _emit: EventEmitter.required,\n  _tabOptions: Trait.required,\n  /**\n   * Function to add event listeners.\n   */\n  on: EventEmitter.required,\n  removeListener: EventEmitter.required,\n  /**\n   * Initializes tab tracker for a browser window.\n   */\n  _initWindowTabTracker: function _initWindowTabTracker() {\n    // Ugly hack that we have to remove at some point (see Bug 658059). At this\n    // point it is necessary to invoke lazy `tabs` getter on the windows object\n    // which creates a `TabList` instance.\n    this.tabs;\n    // Binding all methods used as event listeners to the instance.\n    this._onTabReady = this._emitEvent.bind(this, \"ready\");\n    this._onTabOpen = this._onTabEvent.bind(this, \"open\");\n    this._onTabClose = this._onTabEvent.bind(this, \"close\");\n    this._onTabActivate = this._onTabEvent.bind(this, \"activate\");\n    this._onTabDeactivate = this._onTabEvent.bind(this, \"deactivate\");\n\n    for each (let tab in getTabs(this._window)) {\n      // We emulate \"open\" events for all open tabs since gecko does not emits\n      // them on the tabs that new windows are open with. Also this is\n      // necessary to synchronize tabs lists with an actual state.\n      this._onTabOpen(tab);\n    }\n    // We also emulate \"activate\" event so that it's picked up by a tab list.\n    this._onTabActivate(getActiveTab(this._window));\n\n    // Setting up event listeners\n    tabsObserver.on(\"open\", this._onTabOpen);\n    tabsObserver.on(\"close\", this._onTabClose);\n    tabsObserver.on(\"activate\", this._onTabActivate);\n    tabsObserver.on(\"deactivate\", this._onTabDeactivate);\n  },\n  _destroyWindowTabTracker: function _destroyWindowTabTracker() {\n    // We emulate close events on all tabs, since gecko does not emits such\n    // events by itself.\n    for each (let tab in this.tabs)\n      this._emitEvent(\"close\", tab);\n\n    this._tabs._clear();\n\n    tabsObserver.removeListener(\"open\", this._onTabOpen);\n    tabsObserver.removeListener(\"close\", this._onTabClose);\n    tabsObserver.removeListener(\"activate\", this._onTabActivate);\n    tabsObserver.removeListener(\"deactivate\", this._onTabDeactivate);\n  },\n  _onTabEvent: function _onTabEvent(type, tab) {\n    if (this._window === getOwnerWindow(tab)) {\n      let options = this._tabOptions.shift() || {};\n      options.tab = tab;\n      options.window = this._public;\n      // creating tab wrapper and adding listener to \"ready\" events.\n      let wrappedTab = Tab(options);\n\n      // Setting up an event listener for ready events.\n      if (type === \"open\")\n        wrappedTab.on(\"ready\", this._onTabReady);\n\n      this._emitEvent(type, wrappedTab);\n    }\n  },\n  _emitEvent: function _emitEvent(type, tab) {\n    // Notifies combined tab list that tab was added / removed.\n    tabs._emit(type, tab);\n    // Notifies contained tab list that window was added / removed.\n    this._tabs._emit(type, tab);\n  }\n});\nexports.WindowTabTracker = WindowTabTracker;\n\n/**\n * This trait is used to create live representation of open tab lists. Each\n * window wrapper's tab list is represented by an object created from this\n * trait. It is also used to represent list of all the open windows. Trait is\n * composed out of `EventEmitter` in order to emit 'TabOpen', 'TabClose' events.\n * **Please note** that objects created by this trait can't be exposed outside\n * instead you should expose it's `_public` property, see comments in\n * constructor for details.\n */\nconst TabList = List.resolve({ constructor: \"_init\" }).compose(\n  // This is ugly, but necessary. Will be removed by #596248\n  EventEmitter.resolve({ toString: null }),\n  Trait.compose({\n    on: Trait.required,\n    _emit: Trait.required,\n    constructor: function TabList(options) {\n      this._window = options.window;\n      // Add new items to the list\n      this.on(EVENTS.open.name, this._add.bind(this));\n      // Remove closed items from the list\n      this.on(EVENTS.close.name, this._remove.bind(this));\n\n      // Set value whenever new tab becomes active.\n      this.on(\"activate\", function onTabActivate(tab) {\n        this._activeTab = tab;\n      }.bind(this));\n      // Initialize list.\n      this._init();\n      // This list is not going to emit any events, object holding this list\n      // will do it instead, to make that possible we return a private API.\n      return this;\n    },\n    get activeTab() this._activeTab,\n    _activeTab: null,\n\n    open: function open(options) {\n      options = Options(options);\n      this._window._tabOptions.push(options);\n      let tab = openTab(this._window._window, options.url);\n      if (!options.inBackground)\n        activateTab(tab);\n    }\n  // This is ugly, but necessary. Will be removed by #596248\n  }).resolve({ toString: null })\n);\n\n/**\n * Combined list of all open tabs on all the windows.\n * type {TabList}\n */\nvar tabs = TabList({ window: null });\nexports.tabs = tabs._public;\n\n/**\n * Trait is a part of composition that represents window wrapper. This trait is\n * composed out of `WindowTabTracker` that allows it to keep track of open tabs\n * on the window being wrapped.\n */\nconst WindowTabs = Trait.compose(\n  WindowTabTracker,\n  Trait.compose({\n    _window: Trait.required,\n    /**\n     * List of tabs\n     */\n    get tabs() (this._tabs || (this._tabs = TabList({ window: this })))._public,\n    _tabs: null,\n  })\n);\nexports.WindowTabs = WindowTabs;\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "windows/tabs"
    }
  }, 
  {
    "pk": 27, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci} = require(\"chrome\");\n\n// ## Implementation Notes ##\n// \n// Making `XMLHttpRequest` objects available to Jetpack code involves a\n// few key principles universal to all low-level module implementations:\n//\n// * **Unloadability**. A Jetpack-based extension using this module can be \n//   asked to unload itself at any time, e.g. because the user decides to\n//   uninstall or disable the extension. This means we need to keep track of\n//   all in-progress reqests and abort them on unload.\n//\n// * **Developer-Ergonomic Tracebacks**. Whenever an exception is raised\n//   by a Jetpack-based extension, we want it to be logged in a\n//   place that is specific to that extension--so that a developer\n//   can distinguish it from an error on a web page or in another\n//   extension, for instance. We also want it to be logged with a\n//   full stack traceback, which the Mozilla platform doesn't usually\n//   do.\n//\n//   Because of this, we don't actually want to give the Mozilla\n//   platform's \"real\" XHR implementation to clients, but instead provide\n//   a simple wrapper that trivially delegates to the implementation in\n//   all cases except where callbacks are involved: whenever Mozilla\n//   platform code calls into the extension, such as during the XHR's\n//   `onreadystatechange` callback, we want to wrap the client's callback\n//   in a try-catch clause that traps any exceptions raised by the\n//   callback and logs them via console.exception() instead of allowing\n//   them to propagate back into Mozilla platform code.\n\n// This is a private list of all active requests, so we know what to\n// abort if we're asked to unload.\nvar requests = [];\n\n// Events on XHRs that we should listen for, so we know when to remove\n// a request from our private list.\nconst TERMINATE_EVENTS = [\"load\", \"error\", \"abort\"];\n\n// Read-only properties of XMLHttpRequest objects that we want to\n// directly delegate to.\nconst READ_ONLY_PROPS = [\"readyState\", \"responseText\", \"responseXML\",\n                         \"status\", \"statusText\"];\n\n// Methods of XMLHttpRequest that we want to directly delegate to.\nconst DELEGATED_METHODS = [\"abort\", \"getAllResponseHeaders\",\n                           \"getResponseHeader\", \"overrideMimeType\",\n                           \"send\", \"sendAsBinary\", \"setRequestHeader\",\n                           \"open\"];\n\nvar getRequestCount = exports.getRequestCount = function getRequestCount() {\n  return requests.length;\n};\n\nvar XMLHttpRequest = exports.XMLHttpRequest = function XMLHttpRequest() {\n  var req = Cc[\"@mozilla.org/xmlextras/xmlhttprequest;1\"]\n            .createInstance(Ci.nsIXMLHttpRequest);\n  // For the sake of simplicity, don't tie this request to any UI.\n  req.mozBackgroundRequest = true;\n\n  memory.track(req, \"XMLHttpRequest\");\n\n  this._req = req;\n  this._orsc = null;\n\n  requests.push(this);\n\n  var self = this;\n\n  this._boundCleanup = function _boundCleanup() {\n    self._cleanup();\n  };\n\n  TERMINATE_EVENTS.forEach(\n    function(name) {\n      self._req.addEventListener(name, self._boundCleanup, false);\n    });\n};\n\nXMLHttpRequest.prototype = {\n  _cleanup: function _cleanup() {\n    this.onreadystatechange = null;\n    var index = requests.indexOf(this);\n    if (index != -1) {\n      var self = this;\n      TERMINATE_EVENTS.forEach(\n        function(name) {\n          self._req.removeEventListener(name, self._boundCleanup, false);\n        });\n      requests.splice(index, 1);\n    }\n  },\n  _unload: function _unload() {\n    this._req.abort();\n    this._cleanup();\n  },\n  addEventListener: function addEventListener() {\n    throw new Error(\"not implemented\");\n  },\n  removeEventListener: function removeEventListener() {\n    throw new Error(\"not implemented\");\n  },\n  set upload(newValue) {\n    throw new Error(\"not implemented\");\n  },\n  get onreadystatechange() {\n    return this._orsc;\n  },\n  set onreadystatechange(cb) {\n    this._orsc = cb;\n    if (cb) {\n      var self = this;\n      this._req.onreadystatechange = function() {\n        try {\n          self._orsc.apply(self, arguments);\n        } catch (e) {\n          console.exception(e);\n        }\n      };\n    } else\n      this._req.onreadystatechange = null;\n  }\n};\n\nREAD_ONLY_PROPS.forEach(\n   function(name) {\n     XMLHttpRequest.prototype.__defineGetter__(\n       name,\n       function() {\n         return this._req[name];\n       });\n   });\n\nDELEGATED_METHODS.forEach(\n  function(name) {\n    XMLHttpRequest.prototype[name] = function() {\n      return this._req[name].apply(this._req, arguments);\n    };\n  });\n\nrequire(\"unload\").when(\n  function() {\n    requests.slice().forEach(function(request) { request._unload(); });\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "xhr"
    }
  }, 
  {
    "pk": 20, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *   Drew Willcoxon <adw@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc,Ci,Cm,Cr,Cu} = require(\"chrome\");\n\nvar jsm = {};\nCu.import(\"resource://gre/modules/XPCOMUtils.jsm\", jsm);\nvar utils = exports.utils = jsm.XPCOMUtils;\n\nCm.QueryInterface(Ci.nsIComponentRegistrar);\n\nvar factories = [];\n\nfunction Factory(options) {\n  memory.track(this);\n\n  this.wrappedJSObject = this;\n  this.create = options.create;\n  this.uuid = options.uuid;\n  this.name = options.name;\n  this.contractID = options.contractID;\n\n  Cm.registerFactory(this.uuid,\n                     this.name,\n                     this.contractID,\n                     this);\n\n  var self = this;\n\n  factories.push(this);\n}\n\nFactory.prototype = {\n  createInstance: function(outer, iid) {\n    try {\n      if (outer)\n        throw Cr.NS_ERROR_NO_AGGREGATION;\n      return (new this.create()).QueryInterface(iid);\n    } catch (e) {\n      console.exception(e);\n      if (e instanceof Ci.nsIException)\n        throw e;\n      else\n        throw Cr.NS_ERROR_FAILURE;\n    }\n  },\n  unregister: function() {\n    var index = factories.indexOf(this);\n    if (index == -1)\n      throw new Error(\"factory already unregistered\");\n\n    var self = this;\n\n    factories.splice(index, 1);\n    Cm.unregisterFactory(this.uuid, this);\n  },\n  QueryInterface: utils.generateQI([Ci.nsIFactory])\n};\n\nvar makeUuid = exports.makeUuid = function makeUuid() {\n  var uuidGenerator = Cc[\"@mozilla.org/uuid-generator;1\"]\n                      .getService(Ci.nsIUUIDGenerator);\n  var uuid = uuidGenerator.generateUUID();\n  return uuid;\n};\n\nvar autoRegister = exports.autoRegister = function autoRegister(path) {\n  // TODO: This assumes that the url points to a directory\n  // that contains subdirectories corresponding to OS/ABI and then\n  // further subdirectories corresponding to Gecko platform version.\n  // we should probably either behave intelligently here or allow\n  // the caller to pass-in more options if e.g. there aren't\n  // Gecko-specific binaries for a component (which will be the case\n  // if only frozen interfaces are used).\n\n  var appInfo = Cc[\"@mozilla.org/xre/app-info;1\"]\n                .getService(Ci.nsIXULAppInfo);\n  var runtime = Cc[\"@mozilla.org/xre/app-info;1\"]\n                .getService(Ci.nsIXULRuntime);\n\n  var osDirName = runtime.OS + \"_\" + runtime.XPCOMABI;\n  var platformVersion = appInfo.platformVersion.substring(0, 5);\n\n  var file = Cc['@mozilla.org/file/local;1']\n             .createInstance(Ci.nsILocalFile);\n  file.initWithPath(path);\n  file.append(osDirName);\n  file.append(platformVersion);\n\n  if (!(file.exists() && file.isDirectory()))\n    throw new Error(\"component not available for OS/ABI \" +\n                    osDirName + \" and platform \" + platformVersion);\n\n  Cm.QueryInterface(Ci.nsIComponentRegistrar);\n  Cm.autoRegister(file);\n};\n\nvar register = exports.register = function register(options) {\n  options = {__proto__: options};\n  if (!options.uuid)\n    options.uuid = makeUuid();\n  return new Factory(options);\n};\n\nvar getClass = exports.getClass = function getClass(contractID, iid) {\n  if (!iid)\n    iid = Ci.nsISupports;\n  return Cm.getClassObjectByContractID(contractID, iid);\n};\n\nrequire(\"unload\").when(\n  function() {\n    var copy = factories.slice();\n    copy.reverse();\n    copy.forEach(function(factory) { factory.unregister(); });\n  });\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "xpcom"
    }
  }, 
  {
    "pk": 35, 
    "model": "jetpack.module", 
    "fields": {
      "code": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Jetpack.\n *\n * The Initial Developer of the Original Code is Mozilla.\n * Portions created by the Initial Developer are Copyright (C) 2007\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Atul Varma <atul@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nconst {Cc, Ci} = require(\"chrome\");\n\nvar appInfo = Cc[\"@mozilla.org/xre/app-info;1\"]\n              .getService(Ci.nsIXULAppInfo);\n\nvar ID = exports.ID = appInfo.ID;\nvar name = exports.name = appInfo.name;\nvar version = exports.version = appInfo.version;\nvar platformVersion = exports.platformVersion = appInfo.platformVersion;\n\n// The following mapping of application names to GUIDs was taken from:\n// \n//   https://addons.mozilla.org/en-US/firefox/pages/appversions\n//\n// Using the GUID instead of the app's name is preferable because sometimes\n// re-branded versions of a product have different names: for instance,\n// Firefox, Minefield, Iceweasel, and Shiretoko all have the same\n// GUID.\n\nvar ids = exports.ids = {\n  Firefox: \"{ec8030f7-c20a-464f-9b0e-13a3a9e97384}\",\n  Mozilla: \"{86c18b42-e466-45a9-ae7a-9b95ba6f5640}\",\n  Sunbird: \"{718e30fb-e89b-41dd-9da7-e25a45638b28}\",\n  SeaMonkey: \"{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}\",\n  Fennec: \"{a23983c0-fd0e-11dc-95ff-0800200c9a66}\",\n  Thunderbird: \"{3550f703-e582-4d05-9a08-453d09bdfdc6}\"\n};\n\nvar is = exports.is = function is(name) {\n  if (!(name in ids))\n    throw new Error(\"Unkown Mozilla Application: \" + name);\n  return ID == ids[name];\n};\n\nvar isOneOf = exports.isOneOf = function isOneOf(names) {\n  for (var i = 0; i < names.length; i++)\n    if (is(names[i]))\n      return true;\n  return false;\n};\n\n/**\n * Use this to check whether the given version (e.g. xulApp.platformVersion)\n * is in the given range. Versions must be in version comparator-compatible\n * format. See MDC for details:\n * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIVersionComparator\n */\nvar versionInRange = exports.versionInRange =\nfunction versionInRange(version, lowInclusive, highExclusive) {\n  var vc = Cc[\"@mozilla.org/xpcom/version-comparator;1\"]\n           .getService(Ci.nsIVersionComparator);\n  return (vc.compare(version, lowInclusive) >= 0) &&\n         (vc.compare(version, highExclusive) < 0);\n}\n\n", 
      "revisions": [
        3, 
        2, 
        1
      ], 
      "author": 1, 
      "filename": "xul-app"
    }
  }, 
  {
    "pk": 2, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "bootstrap-remote-process", 
      "ext": "js", 
      "path": "addon-sdk-1.0rc2/api-utils/bootstrap-remote-process.js", 
      "revisions": [
        3
      ]
    }
  }, 
  {
    "pk": 5, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "moz_favicon", 
      "ext": "ico", 
      "path": "addon-sdk-1.0rc2/addon-kit/moz_favicon.ico", 
      "revisions": [
        8, 
        7
      ]
    }
  }, 
  {
    "pk": 3, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "test", 
      "ext": "html", 
      "path": "addon-sdk-1.0rc2/addon-kit/test.html", 
      "revisions": [
        8, 
        7, 
        6, 
        5
      ]
    }
  }, 
  {
    "pk": 1, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "test-content-symbiont", 
      "ext": "js", 
      "path": "addon-sdk-1.0rc2/api-utils/test-content-symbiont.js", 
      "revisions": [
        3, 
        2
      ]
    }
  }, 
  {
    "pk": 4, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "test-page-worker", 
      "ext": "html", 
      "path": "addon-sdk-1.0rc2/addon-kit/test-page-worker.html", 
      "revisions": [
        8, 
        7, 
        6
      ]
    }
  }, 
  {
    "pk": 6, 
    "model": "jetpack.attachment", 
    "fields": {
      "mimetype": null, 
      "author": 1, 
      "filename": "test-page-worker", 
      "ext": "js", 
      "path": "addon-sdk-1.0rc2/addon-kit/test-page-worker.js", 
      "revisions": [
        8
      ]
    }
  }, 
  {
    "pk": 1, 
    "model": "jetpack.sdk", 
    "fields": {
      "version": "1.0", 
      "core_lib": 3, 
      "dir": "addon-sdk-1.0rc2", 
      "kit_lib": 8
    }
  }
]
